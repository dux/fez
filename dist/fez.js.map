{
  "version": 3,
  "sources": ["../src/fez/defaults.js", "../src/fez/lib/n.js", "../src/fez/lib/svelte-template.js", "../src/fez/lib/template.js", "../src/fez/instance.js", "../src/fez/vendor/gobber.js", "../src/fez/vendor/idiomorph.js", "../src/fez/utils/dump.js", "../src/fez/utils/highlight_all.js", "../src/fez/connect.js", "../src/fez/compile.js", "../src/fez/lib/global-state.js", "../src/fez/utility.js", "../src/fez/utils/css_mixin.js", "../src/fez/root.js", "../src/fez.js"],
  "sourcesContent": ["// Wrap defaults in a function to avoid immediate execution\nconst loadDefaults = () => {\n  // include fez component by name\n  //<fez-component name=\"some-node\" :props=\"fez.props\"></fez-component>\n  Fez('fez-component', class {\n    init(props) {\n      const tag = document.createElement(props.name)\n      tag.props = props.props || props['data-props'] || props\n\n      while (this.root.firstChild) {\n        this.root.parentNode.insertBefore(this.root.lastChild, tag.nextSibling);\n      }\n\n      this.root.innerHTML = ''\n      this.root.appendChild(tag)\n    }\n  })\n\n  // include remote data from url\n  // <fez-include src=\"./demo/fez/ui-slider.html\"></fez-include>\n  Fez('fez-include', class {\n    init(props) {\n      Fez.fetch(props.src, (data)=>{\n        const dom = Fez.domRoot(data)\n        Fez.head(dom) // include scripts and load fez components\n        this.root.innerHTML = dom.innerHTML\n      })\n    }\n  })\n\n  // include remote data from url\n  // <fez-inline :state=\"{count: 0}\" :wait-for=\"()=>window.SpritePet\">\n  //   <button onclick=\"fez.state.count += 1\">&plus;</button>\n  //   {{ state.count }} * {{ state.count }} = {{ state.count * state.count }}\n  // </fez-inline>\n  Fez('fez-inline', class {\n    init(props) {\n      // <fez-inline :wait-for=\"()=>window.SpritePet\">\n      props['wait-for'] ||= ()=>true\n      Fez.untilTrue(() => {\n        if (props['wait-for']()) {\n          this.mountIt()\n          return true\n        }\n      }, 100)\n    }\n\n    mountIt() {\n      const html = this.root.innerHTML\n\n      if (html) {\n        const hash = Fez.fnv1(this.root.outerHTML)\n        const nodeName = `inline-${hash}`\n        Fez(nodeName, class {\n          HTML = html\n          init() {\n            Object.assign(this.state, this.props.state || {})\n          }\n        })\n\n        const el = document.createElement(nodeName)\n        this.root.after(this.root.lastChild, el);\n        this.root.remove()\n      }\n    }\n  })\n\n  // Show node only if test validates\n  // <fez-if if=\"window.foo\">...\n  Fez('fez-if', class {\n    init(props) {\n      const test = new Function(`return (${props.if || props.test})`)\n      if (!test()) {\n        this.root.remove()\n      }\n    }\n  })\n\n  // Memory store for memoization with size limit\n  const memoStore = new Map()\n  const MEMO_STORE_MAX_SIZE = 50\n\n  // Expose memoStore cleanup to Fez for manual clearing\n  Fez.clearMemoStore = () => {\n    memoStore.clear()\n    Fez.consoleLog('Memoize store cleared')\n  }\n\n  // memoize component content by key\n  // <fez-memoize key=\"unique-key\">content to memoize</fez-memoize>\n  Fez('fez-memoize', class {\n    init(props) {\n      if (!props.key) {\n        Fez.consoleError('fez-memoize: key prop is required')\n        return\n      }\n\n      if (memoStore.has(props.key)) {\n        // Restore from memory in init\n        const storedNode = memoStore.get(props.key)\n        Fez.consoleLog(`Memoize - key: \"${props.key}\" - restore`)\n        this.root.innerHTML = ''\n        this.root.appendChild(storedNode.cloneNode(true))\n      }\n    }\n\n    onMount(props) {\n      // Only store if not already in memory\n      if (!memoStore.has(props.key)) {\n        requestAnimationFrame(() => {\n          // Enforce max size by removing oldest entries\n          if (memoStore.size >= MEMO_STORE_MAX_SIZE) {\n            const oldestKey = memoStore.keys().next().value\n            memoStore.delete(oldestKey)\n            Fez.consoleLog(`Memoize - evicted oldest key: \"${oldestKey}\"`)\n          }\n\n          // Store current DOM content\n          const contentNode = document.createElement('div')\n          contentNode.innerHTML = this.root.innerHTML\n          Fez.consoleLog(`Memoize - key: \"${props.key}\" - set`)\n          memoStore.set(props.key, contentNode)\n        })\n      }\n    }\n  })\n}\n\n// Only load defaults if Fez is available\nif (typeof Fez !== 'undefined' && Fez) {\n  loadDefaults()\n}\n\n// Export for use in tests\nexport { loadDefaults }\n", "// Exposes node building method, that gets node name, attrs and body.\n// n('span', {id: id}), n('.foo', {id: id}, body), n('.foo', {id: id}, [...])\n// * you can switch places for attrs and body, and body can be list of nodes\n// * n('.foo.bar') -> n('div', { class: 'foo bar' })\n//\n// copyright @dux, 2024\n// Licence MIT\n\nexport default function n(name, attrs = {}, data) {\n  if (typeof attrs === 'string') {\n    [attrs, data] = [data, attrs]\n    attrs ||= {}\n  }\n\n  if (attrs instanceof Node) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (Array.isArray(name)) {\n    data = name\n    name = 'div'\n  }\n\n  if (typeof attrs !== 'object' || Array.isArray(attrs)) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (name.includes('.')) {\n    const parts = name.split('.')\n    name = parts.shift() || 'div'\n    const c = parts.join(' ');\n    if (attrs.class) {\n      attrs.class += ` ${c}`;\n    } else {\n      attrs.class = c\n    }\n  }\n\n  const node = document.createElement(name);\n\n  for (const [k, v] of Object.entries(attrs)) {\n    if (typeof v === 'function') {\n      node[k] = v.bind(this)\n    } else {\n      const value = String(v).replaceAll('fez.', this.fezHtmlRoot);\n      node.setAttribute(k, value)\n    }\n  }\n\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const n of data) {\n        node.appendChild(n)\n      }\n    } else if (data instanceof Node) {\n      node.appendChild(data)\n    } else {\n      node.innerHTML = String(data)\n    }\n  }\n\n  return node\n}\n", "// Svelte-like template parser for Fez\n// Compiles to a single function that returns HTML string\n//\n// Supports:\n//   {#if cond}...{:else if cond}...{:else}...{/if}\n//   {#unless cond}...{/unless}\n//   {#each items as item}...{/each}        - implicit index `i` available\n//   {#each items as item, index}...{/each} - explicit index name\n//   {#for item in items}...{/for}          - implicit index `i` available\n//   {#for item, index in items}...{/for}   - explicit index name\n//   {#each obj as key, value, index}       - object iteration (3 params)\n//   {@html rawContent}                     - unescaped HTML\n//   {@json obj}                            - debug JSON output\n//   {expression}                           - escaped expression\n\n/**\n * Parse loop binding to get params and detect object iteration\n */\nfunction parseLoopBinding(binding) {\n  const isDestructured = binding.startsWith('[')\n\n  if (isDestructured) {\n    const match = binding.match(/^\\[([^\\]]+)\\](?:\\s*,\\s*(\\w+))?$/)\n    if (match) {\n      return {\n        params: match[1].split(',').map(s => s.trim()),\n        indexParam: match[2] || null,\n        isDestructured: true\n      }\n    }\n  }\n\n  const parts = binding.split(',').map(s => s.trim())\n  return { params: parts, indexParam: null, isDestructured: false }\n}\n\n/**\n * Get loop variable names from binding\n */\nfunction getLoopVarNames(binding) {\n  const parsed = parseLoopBinding(binding)\n  const names = [...parsed.params]\n  if (parsed.indexParam) names.push(parsed.indexParam)\n  // Add implicit i for single-param\n  if (parsed.params.length === 1 && !names.includes('i')) names.push('i')\n  return names\n}\n\n/**\n * Build collection expression for iteration\n */\nfunction buildCollectionExpr(collection, binding) {\n  const parsed = parseLoopBinding(binding)\n  const isObjectIteration = parsed.isDestructured || parsed.params.length >= 3\n\n  if (isObjectIteration) {\n    return `((_c)=>Array.isArray(_c)?_c:(_c&&typeof _c===\"object\")?Object.entries(_c):[])(${collection})`\n  }\n  return `(${collection}||[])`\n}\n\n/**\n * Build loop callback params\n */\nfunction buildLoopParams(binding) {\n  const parsed = parseLoopBinding(binding)\n\n  if (parsed.isDestructured) {\n    const destructure = '[' + parsed.params.join(', ') + ']'\n    const indexName = parsed.indexParam || (parsed.params.includes('i') ? '_i' : 'i')\n    return destructure + ', ' + indexName\n  }\n\n  if (parsed.params.length >= 3) {\n    const params = [...parsed.params]\n    const index = params.pop()\n    return '[' + params.join(', ') + '], ' + index\n  }\n\n  if (parsed.params.length === 2) {\n    return parsed.params.join(', ')\n  }\n\n  // If loop var is 'i', use '_i' for index to avoid collision\n  const indexName = parsed.params[0] === 'i' ? '_i' : 'i'\n  return parsed.params[0] + ', ' + indexName\n}\n\n/**\n * Check if expression is an arrow function\n */\nfunction isArrowFunction(expr) {\n  // Match: () => ..., (e) => ..., (e, foo) => ..., e => ...\n  return /^\\s*(\\([^)]*\\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>/.test(expr)\n}\n\n/**\n * Transform arrow function to onclick-compatible string\n * Input: \"(e) => removeTask(index)\" with loopVars = ['item', 'index', 'i']\n * Output: \"removeTask(${index})\" (loop vars get interpolated)\n */\nfunction transformArrowToHandler(expr, loopVars = []) {\n  // Extract the arrow function body\n  const arrowMatch = expr.match(/^\\s*(?:\\([^)]*\\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*(.+)$/s)\n  if (!arrowMatch) return expr\n\n  let body = arrowMatch[1].trim()\n\n  // Check if arrow has event param: (e) => or (event) => or e =>\n  const paramMatch = expr.match(/^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)?\\s*(?:,\\s*[^)]+)?\\)?\\s*=>/)\n  const eventParam = paramMatch?.[1]\n  const hasEventParam = eventParam && ['e', 'event', 'ev'].includes(eventParam)\n\n  // Replace event param with 'event' (the actual DOM event)\n  if (hasEventParam && eventParam !== 'event') {\n    // Replace the event param variable in the body with 'event'\n    const eventRegex = new RegExp(`\\\\b${eventParam}\\\\b`, 'g')\n    body = body.replace(eventRegex, 'event')\n  }\n\n  // Interpolate loop variables - they need to be evaluated at render time\n  // e.g., removeTask(index) becomes removeTask(${index})\n  for (const varName of loopVars) {\n    // Match the variable as a standalone identifier (not part of another word)\n    // and not already inside a template literal\n    const varRegex = new RegExp(`(?<!\\\\$\\\\{)\\\\b${varName}\\\\b(?![^{]*\\\\})`, 'g')\n    body = body.replace(varRegex, `\\${${varName}}`)\n  }\n\n  // Prefix bare function calls with fez.\n  // This handles: removeTask(x) -> fez.removeTask(x)\n  // But not: this.foo(), obj.method(), console.log()\n  // Use negative lookbehind to avoid matching after a dot\n  body = body.replace(/(?<![.\\w])([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g, (match, funcName) => {\n    // Don't prefix if it's a known global or already qualified\n    const globals = ['console', 'window', 'document', 'Math', 'JSON', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'parseInt', 'parseFloat', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval', 'alert', 'confirm', 'prompt', 'fetch', 'event']\n    if (globals.includes(funcName)) {\n      return match\n    }\n    return `fez.${funcName}(`\n  })\n\n  return body\n}\n\n/**\n * Extract a braced expression with proper depth counting\n */\nfunction extractBracedExpression(text, startIndex) {\n  let depth = 0\n  let i = startIndex\n\n  while (i < text.length) {\n    const char = text[i]\n    if (char === '{') {\n      depth++\n    } else if (char === '}') {\n      depth--\n      if (depth === 0) {\n        return { expression: text.slice(startIndex + 1, i), endIndex: i }\n      }\n    } else if (char === '\"' || char === \"'\" || char === '`') {\n      // Skip string literals\n      const quote = char\n      i++\n      while (i < text.length && text[i] !== quote) {\n        if (text[i] === '\\\\') i++\n        i++\n      }\n    }\n    i++\n  }\n  throw new Error(`Unmatched brace at ${startIndex}`)\n}\n\n/**\n * Check if position is inside an attribute (attr={...})\n * Returns the attribute name if inside one, null otherwise\n */\nfunction getAttributeContext(text, pos) {\n  // Look backwards for pattern like: attr={\n  // We need to find the last '=' before pos that's preceded by an attribute name\n  let j = pos - 1\n  // Skip whitespace and opening brace\n  while (j >= 0 && (text[j] === '{' || text[j] === ' ' || text[j] === '\\t')) j--\n  if (j >= 0 && text[j] === '=') {\n    // Found '=', now look for attribute name\n    j--\n    while (j >= 0 && (text[j] === ' ' || text[j] === '\\t')) j--\n    // Extract attribute name\n    let attrEnd = j + 1\n    while (j >= 0 && /[a-zA-Z0-9_:-]/.test(text[j])) j--\n    const attrName = text.slice(j + 1, attrEnd)\n    if (attrName && /^[a-zA-Z]/.test(attrName)) {\n      return attrName.toLowerCase()\n    }\n  }\n  return null\n}\n\n/**\n * Check if position is inside an event attribute (onclick=, onchange=, etc.)\n * Returns the attribute name if inside one, null otherwise\n */\nfunction getEventAttributeContext(text, pos) {\n  const attr = getAttributeContext(text, pos)\n  if (attr && /^on[a-z]+$/.test(attr)) {\n    return attr\n  }\n  return null\n}\n\n/**\n * Compile template to a function that returns HTML string\n */\nexport default function createSvelteTemplate(text, opts = {}) {\n  const componentName = opts.name || 'unknown'\n\n  try {\n    // Decode HTML entities that might have been encoded by browser DOM\n    text = text\n      .replaceAll('&#x60;', '`')\n      .replaceAll('&lt;', '<')\n      .replaceAll('&gt;', '>')\n      .replaceAll('&amp;', '&')\n\n    // Process block definitions and references before parsing\n    const blocks = {}\n    text = text.replace(/\\{@block\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/block\\}/g, (_, name, content) => {\n      blocks[name] = content\n      return ''\n    })\n    text = text.replace(/\\{@block:(\\w+)\\}/g, (_, name) => blocks[name] || '')\n\n    // Convert :attr=\"expr\" to use Fez.store for passing values through DOM\n    // This allows loop variables to be passed as props to child components\n    // :file=\"el.file\" -> :file={`Fez.store.delete(${Fez.store.set(el.file)})`}\n    text = text.replace(/:(\\w+)=\"([^\"{}]+)\"/g, (match, attr, expr) => {\n      // Only convert if expr looks like a variable access (not a string literal)\n      if (/^[\\w.[\\]]+$/.test(expr.trim())) {\n        return `:${attr}={\\`Fez.store.delete(\\${Fez.store.set(${expr})})\\`}`\n      }\n      return match\n    })\n\n    // Remove HTML comments\n    text = text.replace(/<!--[\\s\\S]*?-->/g, '')\n\n    // Normalize whitespace between tags\n    text = text.replace(/>\\s+</g, '><').trim()\n\n    // Convert self-closing custom elements to paired tags\n    // <ui-icon name=\"foo\" /> -> <ui-icon name=\"foo\"></ui-icon>\n    // Custom elements contain a hyphen in the tag name\n    text = text.replace(/<([a-z][a-z0-9]*-[a-z0-9-]*)([^>]*?)\\s*\\/>/gi, '<$1$2></$1>')\n\n    // Convert self-closing <slot /> to <slot></slot>\n    text = text.replace(/<slot\\s*\\/>/gi, '<slot></slot>')\n\n    // Parse and build template literal\n    let result = ''\n    let i = 0\n    const ifStack = []  // Track if blocks have else\n    const loopVarStack = []  // Track loop variables for arrow function transformation\n    const loopStack = []  // Track loop info for :else support\n\n    while (i < text.length) {\n      // Escaped brace\n      if (text[i] === '\\\\' && text[i + 1] === '{') {\n        result += '{'\n        i += 2\n        continue\n      }\n\n      // Expression or directive\n      if (text[i] === '{') {\n        const { expression, endIndex } = extractBracedExpression(text, i)\n        const expr = expression.trim()\n\n        // Block directives\n        if (expr.startsWith('#if ')) {\n          const cond = expr.slice(4)\n          result += '${(' + cond + ') ? `'\n          ifStack.push(false)  // No else yet\n        }\n        else if (expr.startsWith('#unless ')) {\n          const cond = expr.slice(8)\n          result += '${!(' + cond + ') ? `'\n          ifStack.push(false)  // No else yet\n        }\n        else if (expr === ':else') {\n          // Check if we're inside a loop (for empty list handling)\n          if (loopStack.length > 0 && !ifStack.length) {\n            // :else inside a loop - for empty array case\n            const loopInfo = loopStack[loopStack.length - 1]\n            loopInfo.hasElse = true\n            result += '`).join(\"\") : `'\n          } else {\n            // :else inside an if block\n            result += '` : `'\n            ifStack[ifStack.length - 1] = true  // Has else\n          }\n        }\n        else if (expr.startsWith(':else if ')) {\n          const cond = expr.slice(9)\n          result += '` : (' + cond + ') ? `'\n          // Keep hasElse as false - still need final else\n        }\n        else if (expr === '/if' || expr === '/unless') {\n          const hasElse = ifStack.pop()\n          result += hasElse ? '`}' : '` : ``}'\n        }\n        else if (expr.startsWith('#each ') || expr.startsWith('#for ')) {\n          const isEach = expr.startsWith('#each ')\n          let collection, binding\n\n          if (isEach) {\n            const rest = expr.slice(6)\n            const asIdx = rest.indexOf(' as ')\n            collection = rest.slice(0, asIdx).trim()\n            binding = rest.slice(asIdx + 4).trim()\n          } else {\n            const rest = expr.slice(5)\n            const inIdx = rest.indexOf(' in ')\n            binding = rest.slice(0, inIdx).trim()\n            collection = rest.slice(inIdx + 4).trim()\n          }\n\n          const collectionExpr = buildCollectionExpr(collection, binding)\n          const loopParams = buildLoopParams(binding)\n\n          // Track loop variables for arrow function transformation\n          loopVarStack.push(getLoopVarNames(binding))\n\n          // Track loop info for :else support\n          // Use a wrapper that allows checking length and provides else support\n          // ((_arr) => _arr.length ? _arr.map(...).join('') : elseContent)(collection)\n          loopStack.push({ collectionExpr, hasElse: false })\n\n          result += '${((_arr) => _arr.length ? _arr.map((' + loopParams + ') => `'\n        }\n        else if (expr === '/each' || expr === '/for') {\n          loopVarStack.pop()  // Remove loop vars when exiting loop\n          const loopInfo = loopStack.pop()\n          if (loopInfo.hasElse) {\n            // Close the else branch\n            result += '`)(' + loopInfo.collectionExpr + ')}'\n          } else {\n            // No else - just close the ternary with empty string\n            result += '`).join(\"\") : \"\")(' + loopInfo.collectionExpr + ')}'\n          }\n        }\n        else if (expr.startsWith('@html ')) {\n          const content = expr.slice(6)\n          result += '${' + content + '}'\n        }\n        else if (expr.startsWith('@json ')) {\n          const content = expr.slice(6)\n          result += '${`<pre class=\"json\">${Fez.htmlEscape(JSON.stringify(' + content + ', null, 2))}</pre>`}'\n        }\n        else if (isArrowFunction(expr)) {\n          // Arrow function - check if we're in an event attribute\n          const eventAttr = getEventAttributeContext(text, i)\n          if (eventAttr) {\n            // Get all current loop variables\n            const allLoopVars = loopVarStack.flat()\n            let handler = transformArrowToHandler(expr, allLoopVars)\n            // Escape double quotes for HTML attribute\n            handler = handler.replace(/\"/g, '&quot;')\n            // Output as quoted attribute value with interpolation for loop vars\n            result += '\"' + handler + '\"'\n          } else {\n            // Arrow function outside event attribute - just output as expression\n            result += '${' + expr + '}'\n          }\n        }\n        else {\n          // Plain expression - check if inside attribute\n          const attrContext = getAttributeContext(text, i)\n          if (attrContext) {\n            // Inside attribute - wrap with quotes and escape\n            result += '\"${Fez.htmlEscape(' + expr + ')}\"'\n          } else {\n            // Regular content - just escape HTML\n            result += '${Fez.htmlEscape(' + expr + ')}'\n          }\n        }\n\n        i = endIndex + 1\n        continue\n      }\n\n      // Escape backticks and $ for template literal\n      if (text[i] === '`') {\n        result += '\\\\`'\n      } else if (text[i] === '$' && text[i + 1] === '{') {\n        result += '\\\\$'\n      } else if (text[i] === '\\\\') {\n        result += '\\\\\\\\'\n      } else {\n        result += text[i]\n      }\n      i++\n    }\n\n    // Build the function\n    const funcBody = `\n      const fez = this;\n      with (this) {\n        return \\`${result}\\`\n      }\n    `\n\n    const tplFunc = new Function(funcBody)\n\n    return (ctx) => {\n      try {\n        return tplFunc.bind(ctx)()\n      } catch (e) {\n        console.error(`FEZ svelte template runtime error in <${ctx.fezName || componentName}>:`, e.message)\n        console.error('Template source:', result.substring(0, 500))\n        return ''\n      }\n    }\n  } catch (e) {\n    console.error(`FEZ svelte template compile error in <${componentName}>:`, e.message)\n    console.error('Template:', text.substring(0, 200))\n    return () => ''\n  }\n}\n", "/**\n * Fez Template Compiler\n *\n * Compiles Svelte-style templates to render functions.\n * Supports legacy {{ }} and [[ ]] syntax via auto-conversion.\n *\n * Syntax:\n *   {expression}        - Output escaped value\n *   {@html expr}        - Output raw HTML\n *   {@json expr}        - Output formatted JSON\n *   {#if cond}...{/if}  - Conditional\n *   {#each arr as item} - Loop\n *   {#for item in arr}  - Loop (alt syntax)\n */\n\nimport createSvelteTemplate from './svelte-template.js'\n\n// Template cache\nconst cache = new Map()\n\n// =============================================================================\n// MAIN EXPORT\n// =============================================================================\n\n/**\n * Create a template render function\n *\n * @param {string} text - Template HTML\n * @param {Object} opts - { name: componentName }\n * @returns {Function} Render function (ctx) => html\n */\nexport default function createTemplate(text, opts = {}) {\n  // Check cache\n  if (cache.has(text)) {\n    return cache.get(text)\n  }\n\n  // Convert legacy syntax if detected\n  if (hasLegacySyntax(text)) {\n    text = convertLegacySyntax(text, opts.name)\n  }\n\n  // Compile\n  const fn = createSvelteTemplate(text, opts)\n  cache.set(text, fn)\n\n  return fn\n}\n\n/**\n * Clear template cache (for testing)\n */\nexport function clearTemplateCache() {\n  cache.clear()\n}\n\n// =============================================================================\n// LEGACY SYNTAX SUPPORT\n// =============================================================================\n\n/**\n * Check if text uses old {{ }} or [[ ]] syntax\n */\nfunction hasLegacySyntax(text) {\n  return (text.includes('{{') && text.includes('}}')) ||\n         (text.includes('[[') && text.includes(']]'))\n}\n\n/**\n * Convert {{ }}/[[ ]] syntax to { } syntax\n *\n * Mappings:\n *   {{ expr }}      -> {expr}\n *   {{if cond}}     -> {#if cond}\n *   {{for x in y}}  -> {#for x in y}\n *   {{each y as x}} -> {#each y as x}\n *   {{raw x}}       -> {@html x}\n *   {{json x}}      -> {@json x}\n *   {{block x}}     -> {@block x}\n */\nfunction convertLegacySyntax(text, componentName) {\n  // Normalize [[ ]] to {{ }}\n  text = text.replaceAll('[[', '{{').replaceAll(']]', '}}')\n\n  // Blocks\n  text = text.replace(/\\{\\{block\\s+(\\w+)\\s*\\}\\}/g, '{@block $1}')\n  text = text.replace(/\\{\\{\\/block\\}\\}/g, '{/block}')\n  text = text.replace(/\\{\\{block:([\\w\\-]+)\\s*\\}\\}/g, '{@block:$1}')\n\n  // Conditionals\n  text = text.replace(/\\{\\{#?if\\s+(.*?)\\}\\}/g, '{#if $1}')\n  text = text.replace(/\\{\\{\\/if\\}\\}/g, '{/if}')\n  text = text.replace(/\\{\\{#?unless\\s+(.*?)\\}\\}/g, '{#unless $1}')\n  text = text.replace(/\\{\\{\\/unless\\}\\}/g, '{/unless}')\n  text = text.replace(/\\{\\{:?else\\}\\}/g, '{:else}')\n\n  // Loops\n  text = text.replace(/\\{\\{#?for\\s+(.*?)\\}\\}/g, '{#for $1}')\n  text = text.replace(/\\{\\{\\/for\\}\\}/g, '{/for}')\n  text = text.replace(/\\{\\{#?each\\s+(.*?)\\}\\}/g, '{#each $1}')\n  text = text.replace(/\\{\\{\\/each\\}\\}/g, '{/each}')\n\n  // Special directives\n  text = text.replace(/\\{\\{#?(?:raw|html)\\s+(.*?)\\}\\}/g, '{@html $1}')\n  text = text.replace(/\\{\\{json\\s+(.*?)\\}\\}/g, '{@json $1}')\n\n  // Expressions\n  text = text.replace(/\\{\\{\\s*(.*?)\\s*\\}\\}/g, '{$1}')\n\n  // Log warning\n  if (componentName) {\n    console.warn(`Fez component \"${componentName}\" uses old {{ ... }} notation, converting.`)\n  }\n\n  return text\n}\n", "/**\n * FezBase - Base class for all Fez components\n *\n * Provides lifecycle hooks, reactive state, DOM utilities, and template rendering\n */\n\nimport parseNode from './lib/n.js'\nimport createTemplate from './lib/template.js'\n\nexport default class FezBase {\n\n  // ===========================================================================\n  // STATIC METHODS\n  // ===========================================================================\n\n  static nodeName = 'div'\n\n  /**\n   * Extract props from a DOM node's attributes\n   * Handles :attr syntax for evaluated expressions and data-props JSON\n   */\n  static getProps(node, newNode) {\n    let attrs = {}\n\n    // Direct props attachment\n    if (node.props) {\n      return node.props\n    }\n\n    // Collect attributes\n    for (const attr of node.attributes) {\n      attrs[attr.name] = attr.value\n    }\n\n    // Evaluate :attr expressions\n    for (const [key, val] of Object.entries(attrs)) {\n      if ([':'].includes(key[0])) {\n        delete attrs[key]\n        try {\n          const newVal = new Function(`return (${val})`).bind(newNode)()\n          attrs[key.replace(/[\\:_]/, '')] = newVal\n        } catch (e) {\n          Fez.onError('attr', `<${node.tagName.toLowerCase()}> Error evaluating ${key}=\"${val}\": ${e.message}`)\n        }\n      }\n    }\n\n    // Handle data-props JSON\n    if (attrs['data-props']) {\n      let data = attrs['data-props']\n      if (typeof data == 'object') {\n        return data\n      } else {\n        if (data[0] != '{') {\n          data = decodeURIComponent(data)\n        }\n        try {\n          attrs = JSON.parse(data)\n        } catch (e) {\n          Fez.onError('props', `<${node.tagName.toLowerCase()}> Invalid JSON in data-props: ${e.message}`)\n        }\n      }\n    }\n    // Handle JSON template\n    else if (attrs['data-json-template']) {\n      const data = newNode.previousSibling?.textContent\n      if (data) {\n        try {\n          attrs = JSON.parse(data)\n          newNode.previousSibling.remove()\n        } catch (e) {\n          Fez.onError('props', `<${node.tagName.toLowerCase()}> Invalid JSON in template: ${e.message}`)\n        }\n      }\n    }\n\n    return attrs\n  }\n\n  /**\n   * Get form data from closest/child form\n   */\n  static formData(node) {\n    const formNode = node.closest('form') || node.querySelector('form')\n    if (!formNode) {\n      Fez.consoleLog('No form found for formData()')\n      return {}\n    }\n    const formData = new FormData(formNode)\n    const formObject = {}\n    formData.forEach((value, key) => {\n      formObject[key] = value\n    });\n    return formObject\n  }\n\n  // ===========================================================================\n  // CONSTRUCTOR & CORE\n  // ===========================================================================\n\n  constructor() {}\n\n  n = parseNode\n  fezBlocks = {}\n\n  /**\n   * Report error with component name always included\n   */\n  fezError(kind, message, context) {\n    const name = this.fezName || this.root?.tagName?.toLowerCase() || 'unknown'\n    return Fez.onError(kind, `<${name}> ${message}`, context)\n  }\n\n  /**\n   * String selector for use in HTML nodes\n   */\n  get fezHtmlRoot() {\n    return `Fez(${this.UID}).`\n  }\n\n  /**\n   * Check if node is attached to DOM\n   */\n  get isConnected() {\n    return !!this.root?.isConnected\n  }\n\n  /**\n   * Get single node property\n   */\n  prop(name) {\n    let v = this.oldRoot[name] || this.props[name]\n    if (typeof v == 'function') {\n      v = v.bind(this.root)\n    }\n    return v\n  }\n\n  // ===========================================================================\n  // LIFECYCLE HOOKS\n  // ===========================================================================\n\n  connect() {}\n  onMount() {}\n  beforeRender() {}\n  afterRender() {}\n  onDestroy() {}\n  onStateChange() {}\n  onGlobalStateChange() {}\n\n  /**\n   * Centralized destroy logic - called by MutationObserver when element is removed\n   */\n  fezOnDestroy() {\n    // Guard against double-cleanup\n    if (this._destroyed) return\n    this._destroyed = true\n\n    // Execute cleanup callbacks (intervals, observers, event listeners)\n    if (this._onDestroyCallbacks) {\n      this._onDestroyCallbacks.forEach(callback => {\n        try {\n          callback()\n        } catch (e) {\n          this.fezError('destroy', 'Error in cleanup callback', e)\n        }\n      })\n      this._onDestroyCallbacks = []\n    }\n\n    // Call user's onDestroy hook\n    this.onDestroy()\n    this.onDestroy = () => {}\n\n    // Clean up root references\n    if (this.root) {\n      this.root.fez = undefined\n    }\n    this.root = undefined\n  }\n\n  /**\n   * Add a cleanup callback for destroy\n   */\n  addOnDestroy(callback) {\n    this._onDestroyCallbacks = this._onDestroyCallbacks || [];\n    this._onDestroyCallbacks.push(callback);\n  }\n\n  // ===========================================================================\n  // RENDERING\n  // ===========================================================================\n\n  /**\n   * Parse HTML and replace fez. references\n   */\n  fezParseHtml(text) {\n    const base = this.fezHtmlRoot.replaceAll('\"', '&quot;')\n    text = text\n      .replace(/([!'\"\\s;])fez\\.(\\w)/g, `$1${base}$2`)\n      .replace(/>\\s+</g, '><')\n    return text.trim()\n  }\n\n  /**\n   * Schedule work on next animation frame (debounced by name)\n   */\n  fezNextTick(func, name) {\n    if (name) {\n      this._nextTicks ||= {}\n      this._nextTicks[name] ||= window.requestAnimationFrame(() => {\n        func.bind(this)()\n        this._nextTicks[name] = null\n      }, name)\n    } else {\n      window.requestAnimationFrame(func.bind(this))\n    }\n  }\n\n  /**\n   * Force a re-render on next frame\n   */\n  fezRefresh() {\n    this.fezNextTick(() => this.fezRender(), 'refresh')\n  }\n\n  /**\n   * Alias for fezRefresh - can be overwritten\n   */\n  refresh() {\n    this.fezRefresh()\n  }\n\n  /**\n   * Render the component template to DOM\n   * Uses Idiomorph for efficient DOM diffing\n   */\n  fezRender(template) {\n    template ||= this?.class?.fezHtmlFunc\n\n    if (!template || !this.root) return\n\n    this.beforeRender()\n\n    const nodeName = typeof this.class.nodeName == 'function' ? this.class.nodeName(this.root) : this.class.nodeName\n    const newNode = document.createElement(nodeName || 'div')\n\n    let renderedTpl\n    if (Array.isArray(template)) {\n      if (template[0] instanceof Node) {\n        template.forEach(n => newNode.appendChild(n))\n      } else {\n        renderedTpl = template.join('')\n      }\n    }\n    else if (typeof template == 'string') {\n      const name = this.root?.tagName?.toLowerCase()\n      renderedTpl = createTemplate(template, { name })(this)\n    }\n    else if (typeof template == 'function') {\n      renderedTpl = template(this)\n    }\n\n    if (renderedTpl) {\n      if (renderedTpl instanceof DocumentFragment || renderedTpl instanceof Node) {\n        newNode.appendChild(renderedTpl)\n      } else {\n        renderedTpl = renderedTpl.replace(/\\s\\w+=\"undefined\"/g, '')\n        newNode.innerHTML = this.fezParseHtml(renderedTpl)\n      }\n    }\n\n    this.fezKeepNode(newNode)\n    this.fezMemoization(newNode)\n\n    Fez.morphdom(this.root, newNode)\n\n    this.fezRenderPostProcess()\n    this.afterRender()\n  }\n\n  /**\n   * Post-render processing for fez-* attributes\n   */\n  fezRenderPostProcess() {\n    const fetchAttr = (name, func) => {\n      this.root.querySelectorAll(`*[${name}]`).forEach((n) => {\n        let value = n.getAttribute(name)\n        n.removeAttribute(name)\n        if (value) {\n          func.bind(this)(value, n)\n        }\n      })\n    }\n\n    // fez-this=\"button\" -> this.button = node\n    fetchAttr('fez-this', (value, n) => {\n      (new Function('n', `this.${value} = n`)).bind(this)(n)\n    })\n\n    // fez-use=\"animate\" -> this.animate(node)\n    fetchAttr('fez-use', (value, n) => {\n      if (value.includes('=>')) {\n        Fez.getFunction(value)(n)\n      }\n      else {\n        if (value.includes('.')) {\n          Fez.getFunction(value).bind(n)()\n        }\n        else {\n          const target = this[value]\n          if (typeof target == 'function') {\n            target(n)\n          } else {\n            this.fezError('fez-use', `\"${value}\" is not a function`)\n          }\n        }\n      }\n    })\n\n    // fez-class=\"dialog animate\" -> add class after init for animation\n    fetchAttr('fez-class', (value, n) => {\n      let classes = value.split(/\\s+/)\n      let lastClass = classes.pop()\n      classes.forEach((c) => n.classList.add(c))\n      if (lastClass) {\n        setTimeout(() => {\n          n.classList.add(lastClass)\n        }, 1)\n      }\n    })\n\n    // fez-bind=\"state.inputNode\" -> two-way binding\n    fetchAttr('fez-bind', (text, n) => {\n      if (['INPUT', 'SELECT', 'TEXTAREA'].includes(n.nodeName)) {\n        const value = (new Function(`return this.${text}`)).bind(this)()\n        const isCb = n.type.toLowerCase() == 'checkbox'\n        const eventName = ['SELECT'].includes(n.nodeName) || isCb ? 'onchange' : 'onkeyup'\n        n.setAttribute(eventName, `${this.fezHtmlRoot}${text} = this.${isCb ? 'checked' : 'value'}`)\n        this.val(n, value)\n      } else {\n        this.fezError('fez-bind', `Can't bind \"${text}\" to ${n.nodeName} (needs INPUT, SELECT or TEXTAREA)`)\n      }\n    })\n\n    // Normalize disabled attribute\n    this.root.querySelectorAll(`*[disabled]`).forEach((n) => {\n      let value = n.getAttribute('disabled')\n      if (['false'].includes(value)) {\n        n.removeAttribute('disabled')\n      } else {\n        n.setAttribute('disabled', 'true')\n      }\n    })\n  }\n\n  /**\n   * Handle fez-keep attributes for preserved nodes\n   */\n  fezKeepNode(newNode) {\n    newNode.querySelectorAll('[fez-keep]').forEach(newEl => {\n      const key = newEl.getAttribute('fez-keep')\n      const isSlot = key === 'default-slot' || key.startsWith('slot-')\n\n      let oldEl\n      if (isSlot) {\n        // Find slot belonging to THIS component, not nested\n        const candidates = this.root.querySelectorAll(`[fez-keep=\"${key}\"]`)\n        for (const el of candidates) {\n          let parent = el.parentElement\n          let isNested = false\n          while (parent && parent !== this.root) {\n            if (parent.classList.contains('fez')) {\n              isNested = true\n              break\n            }\n            parent = parent.parentElement\n          }\n          if (!isNested) {\n            oldEl = el\n            break\n          }\n        }\n      } else {\n        oldEl = this.root.querySelector(`[fez-keep=\"${key}\"]`)\n      }\n\n      if (oldEl) {\n        newEl.parentNode.replaceChild(oldEl, newEl)\n      } else if (isSlot) {\n        if (newEl.getAttribute('hide')) {\n          this.state = null\n          const parent = newEl.parentNode\n          Array.from(this.root.childNodes).forEach(child => {\n            parent.insertBefore(child, newEl)\n          })\n          newEl.remove()\n        } else {\n          const children = Array.from(this.root.childNodes)\n          children.forEach(child => {\n            newEl.appendChild(child)\n          })\n        }\n      }\n    })\n  }\n\n  /**\n   * Handle fez-memoize attributes for cached nodes\n   */\n  fezMemoization(newNode) {\n    const newMemoEl = newNode.querySelector('[fez-memoize]:not(.fez)')\n    if (!newMemoEl) return\n\n    this.fezMemoStore ||= new Map()\n\n    const newMemoElKey = newMemoEl.getAttribute('fez-memoize')\n    const storedNode = this.fezMemoStore.get(newMemoElKey)\n\n    if (storedNode) {\n      Fez.consoleLog(`Memoize restore ${this.fezName}: ${newMemoElKey}`)\n      newMemoEl.parentNode.replaceChild(storedNode.cloneNode(true), newMemoEl)\n    } else {\n      const oldMemoEl = this.root.querySelector('[fez-memoize]:not(.fez)')\n      if (oldMemoEl) {\n        const oldMemoElKey = oldMemoEl.getAttribute('fez-memoize')\n        this.fezMemoStore.set(oldMemoElKey, oldMemoEl.cloneNode(true))\n      }\n    }\n  }\n\n  // ===========================================================================\n  // REACTIVE STATE\n  // ===========================================================================\n\n  /**\n   * Register component: setup CSS, state, and bind methods\n   */\n  fezRegister() {\n    if (this.css) {\n      this.css = Fez.globalCss(this.css, { name: this.fezName, wrap: true })\n    }\n\n    if (this.class.css) {\n      this.class.css = Fez.globalCss(this.class.css, { name: this.fezName })\n    }\n\n    this.state ||= this.fezReactiveStore()\n    this.globalState = Fez.state.createProxy(this)\n    this.fezRegisterBindMethods()\n  }\n\n  /**\n   * Bind all instance methods to this\n   */\n  fezRegisterBindMethods() {\n    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n      .filter(method => method !== 'constructor' && typeof this[method] === 'function')\n    methods.forEach(method => this[method] = this[method].bind(this))\n  }\n\n  /**\n   * Create a reactive store that triggers re-renders on changes\n   */\n  fezReactiveStore(obj, handler) {\n    obj ||= {}\n\n    handler ||= (o, k, v, oldValue) => {\n      if (v != oldValue) {\n        this.onStateChange(k, v, oldValue)\n        this.fezNextTick(this.fezRender, 'fezRender')\n      }\n    }\n\n    handler.bind(this)\n\n    function createReactive(obj, handler) {\n      if (typeof obj !== 'object' || obj === null) {\n        return obj;\n      }\n\n      return new Proxy(obj, {\n        set(target, property, value, receiver) {\n          const currentValue = Reflect.get(target, property, receiver);\n\n          if (currentValue !== value) {\n            if (typeof value === 'object' && value !== null) {\n              value = createReactive(value, handler);\n            }\n\n            const result = Reflect.set(target, property, value, receiver);\n            handler(target, property, value, currentValue);\n            return result;\n          }\n\n          return true;\n        },\n        get(target, property, receiver) {\n          const value = Reflect.get(target, property, receiver);\n          if (typeof value === 'object' && value !== null) {\n            return createReactive(value, handler);\n          }\n          return value;\n        }\n      });\n    }\n\n    return createReactive(obj, handler);\n  }\n\n  // ===========================================================================\n  // DOM HELPERS\n  // ===========================================================================\n\n  /**\n   * Find element by selector\n   */\n  find(selector) {\n    return typeof selector == 'string' ? this.root.querySelector(selector) : selector\n  }\n\n  /**\n   * Get or set node value (input/textarea/select or innerHTML)\n   */\n  val(selector, data) {\n    const node = this.find(selector)\n\n    if (node) {\n      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(node.nodeName)) {\n        if (typeof data != 'undefined') {\n          if (node.type == 'checkbox') {\n            node.checked = !!data\n          } else {\n            node.value = data\n          }\n        } else {\n          return node.value\n        }\n      } else {\n        if (typeof data != 'undefined') {\n          node.innerHTML = data\n        } else {\n          return node.innerHTML\n        }\n      }\n    }\n  }\n\n  /**\n   * Instance form data helper\n   */\n  formData(node) {\n    return this.class.formData(node || this.root)\n  }\n\n  /**\n   * Get or set root attribute\n   */\n  attr(name, value) {\n    if (typeof value === 'undefined') {\n      return this.root.getAttribute(name)\n    } else {\n      this.root.setAttribute(name, value)\n      return value\n    }\n  }\n\n  /**\n   * Get root children as array, optionally transform\n   */\n  childNodes(func) {\n    let children = Array.from(this.root.children)\n\n    if (func) {\n      const tmpContainer = document.createElement('div')\n      tmpContainer.style.display = 'none'\n      document.body.appendChild(tmpContainer)\n      children.forEach(child => tmpContainer.appendChild(child))\n\n      children = Array.from(tmpContainer.children).map(func)\n      document.body.removeChild(tmpContainer)\n    }\n\n    return children\n  }\n\n  /**\n   * Set CSS properties on root\n   */\n  setStyle(key, value) {\n    if (key && typeof key == 'object') {\n      Object.entries(key).forEach(([prop, val]) => {\n        this.root.style.setProperty(prop, val);\n      });\n    } else {\n      this.root.style.setProperty(key, value);\n    }\n  }\n\n  /**\n   * Copy props as attributes to root\n   */\n  copy() {\n    for (const name of Array.from(arguments)) {\n      let value = this.props[name]\n\n      if (value !== undefined) {\n        if (name == 'class') {\n          const klass = this.root.getAttribute(name, value)\n          if (klass) {\n            value = [klass, value].join(' ')\n          }\n        }\n\n        if (typeof value == 'string') {\n          this.root.setAttribute(name, value)\n        }\n        else {\n          this.root[name] = value\n        }\n      }\n    }\n  }\n\n  /**\n   * Get or set root ID\n   */\n  rootId() {\n    this.root.id ||= `fez_${this.UID}`\n    return this.root.id\n  }\n\n  /**\n   * Dissolve component into parent\n   */\n  dissolve(inNode) {\n    if (inNode) {\n      inNode.classList.add('fez')\n      inNode.classList.add(`fez-${this.fezName}`)\n      inNode.fez = this\n      if (this.attr('id')) inNode.setAttribute('id', this.attr('id'))\n\n      this.root.innerHTML = ''\n      this.root.appendChild(inNode)\n    }\n\n    const node = this.root\n    const nodes = this.childNodes()\n    const parent = this.root.parentNode\n\n    nodes.reverse().forEach(el => parent.insertBefore(el, node.nextSibling))\n\n    this.root.remove()\n    this.root = undefined\n\n    if (inNode) {\n      this.root = inNode\n    }\n\n    return nodes\n  }\n\n  // ===========================================================================\n  // EVENTS\n  // ===========================================================================\n\n  /**\n   * Add window event listener with auto-cleanup\n   */\n  on(eventName, func, delay = 200) {\n    this._eventHandlers = this._eventHandlers || {};\n\n    if (this._eventHandlers[eventName]) {\n      window.removeEventListener(eventName, this._eventHandlers[eventName]);\n    }\n\n    const throttledFunc = Fez.throttle(() => {\n      if (this.isConnected) func.call(this);\n    }, delay);\n\n    this._eventHandlers[eventName] = throttledFunc;\n    window.addEventListener(eventName, throttledFunc);\n\n    this.addOnDestroy(() => {\n      window.removeEventListener(eventName, throttledFunc);\n      delete this._eventHandlers[eventName];\n    });\n  }\n\n  /**\n   * Window resize handler\n   */\n  onWindowResize(func, delay) {\n    this.on('resize', func, delay);\n    func();\n  }\n\n  /**\n   * Window scroll handler\n   */\n  onWindowScroll(func, delay) {\n    this.on('scroll', func, delay);\n    func();\n  }\n\n  /**\n   * Element resize handler using ResizeObserver\n   */\n  onElementResize(el, func, delay = 200) {\n    const throttledFunc = Fez.throttle(() => {\n      if (this.isConnected) func.call(this, el.getBoundingClientRect(), el);\n    }, delay);\n\n    const observer = new ResizeObserver(throttledFunc);\n    observer.observe(el);\n\n    func.call(this, el.getBoundingClientRect(), el);\n\n    this.addOnDestroy(() => {\n      observer.disconnect();\n    });\n  }\n\n  /**\n   * Interval with auto-cleanup\n   */\n  setInterval(func, tick, name) {\n    if (typeof func == 'number') {\n      [tick, func] = [func, tick]\n    }\n\n    name ||= Fez.fnv1(String(func))\n\n    this._setIntervalCache ||= {}\n    clearInterval(this._setIntervalCache[name])\n\n    const intervalID = setInterval(() => {\n      if (this.isConnected) func()\n    }, tick)\n\n    this._setIntervalCache[name] = intervalID\n\n    this.addOnDestroy(() => {\n      clearInterval(intervalID);\n      delete this._setIntervalCache[name];\n    });\n\n    return intervalID\n  }\n\n  // ===========================================================================\n  // PUB/SUB\n  // ===========================================================================\n\n  /**\n   * Publish to parent component that subscribes\n   */\n  publish(channel, ...args) {\n    const handle_publish = (component) => {\n      if (Fez._subs && Fez._subs[channel]) {\n        const sub = Fez._subs[channel].find(([comp]) => comp === component)\n        if (sub) {\n          sub[1].bind(component)(...args)\n          return true\n        }\n      }\n      return false\n    }\n\n    // Check current component\n    if (handle_publish(this)) {\n      return true\n    }\n\n    // Bubble up to parents\n    let parent = this.root.parentElement\n    while (parent) {\n      if (parent.fez) {\n        if (handle_publish(parent.fez)) {\n          return true\n        }\n      }\n      parent = parent.parentElement\n    }\n\n    return false\n  }\n\n  /**\n   * Subscribe to a channel\n   */\n  subscribe(channel, func) {\n    Fez._subs ||= {}\n    Fez._subs[channel] ||= []\n    Fez._subs[channel] = Fez._subs[channel].filter((el) => el[0].isConnected)\n    Fez._subs[channel].push([this, func])\n  }\n\n  // ===========================================================================\n  // SLOTS\n  // ===========================================================================\n\n  /**\n   * Copy child nodes natively to preserve bound events\n   */\n  fezSlot(source, target) {\n    target ||= document.createElement('template')\n    const isSlot = target.nodeName == 'SLOT'\n\n    while (source.firstChild) {\n      if (isSlot) {\n        target.parentNode.insertBefore(source.lastChild, target.nextSibling);\n      } else {\n        target.appendChild(source.firstChild)\n      }\n    }\n\n    if (isSlot) {\n      target.parentNode.removeChild(target)\n    } else {\n      source.innerHTML = ''\n    }\n\n    return target\n  }\n}\n", "/**\n * Skipped minification because the original files appears to be already minified.\n * Original file: /npm/goober@2.1.14/dist/goober.modern.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\nlet e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,a=e=>{let a=t(e),r=a.data;return a.data=\"\",r},r=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,l=/\\/\\*[^]*?\\*\\/|  +/g,s=/\\n+/g,n=(e,t)=>{let a=\"\",r=\"\",l=\"\";for(let s in e){let o=e[s];\"@\"==s[0]?\"i\"==s[1]?a=s+\" \"+o+\";\":r+=\"f\"==s[1]?n(o,s):s+\"{\"+n(o,\"k\"==s[1]?\"\":t)+\"}\":\"object\"==typeof o?r+=n(o,t?t.replace(/([^,])+/g,(e=>s.replace(/(^:.*)|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)))):s):null!=o&&(s=/^--/.test(s)?s:s.replace(/[A-Z]/g,\"-$&\").toLowerCase(),l+=n.p?n.p(s,o):s+\":\"+o+\";\")}return a+(t&&l?t+\"{\"+l+\"}\":l)+r},o={},c=e=>{if(\"object\"==typeof e){let t=\"\";for(let a in e)t+=a+c(e[a]);return t}return e},i=(e,t,a,i,p)=>{let u=c(e),d=o[u]||(o[u]=(e=>{let t=0,a=11;for(;t<e.length;)a=101*a+e.charCodeAt(t++)>>>0;return\"go\"+a})(u));if(!o[d]){let t=u!==e?e:(e=>{let t,a,n=[{}];for(;t=r.exec(e.replace(l,\"\"));)t[4]?n.shift():t[3]?(a=t[3].replace(s,\" \").trim(),n.unshift(n[0][a]=n[0][a]||{})):n[0][t[1]]=t[2].replace(s,\" \").trim();return n[0]})(e);o[d]=n(p?{[\"@keyframes \"+d]:t}:t,a?\"\":\".\"+d)}let f=a&&o.g?o.g:null;return a&&(o.g=o[d]),((e,t,a,r)=>{r?t.data=t.data.replace(r,e):-1===t.data.indexOf(e)&&(t.data=a?e+t.data:t.data+e)})(o[d],t,i,f),d},p=(e,t,a)=>e.reduce(((e,r,l)=>{let s=t[l];if(s&&s.call){let e=s(a),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;s=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":n(e,\"\"):!1===e?\"\":e}return e+r+(null==s?\"\":s)}),\"\");function u(e){let a=this||{},r=e.call?e(a.p):e;return i(r.unshift?r.raw?p(r,[].slice.call(arguments,1),a.p):r.reduce(((e,t)=>Object.assign(e,t&&t.call?t(a.p):t)),{}):r,t(a.target),a.g,a.o,a.k)}let d,f,g,b=u.bind({g:1}),m=u.bind({k:1});function h(e,t,a,r){n.p=t,d=e,f=a,g=r}function y(e,t){let a=this||{};return function(){let r=arguments;function l(s,n){let o=Object.assign({},s),c=o.className||l.className;a.p=Object.assign({theme:f&&f()},o),a.o=/ *go\\d+/.test(c),o.className=u.apply(a,r)+(c?\" \"+c:\"\"),t&&(o.ref=n);let i=e;return e[0]&&(i=o.as||e,delete o.as),g&&i[0]&&g(o),d(i,o)}return t?t(l):l}}\nexport default { css:u, extractCss: a, glob: b, keyframes: m, setup: h, styled: y }\n", "// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n\n                    try {\n                        if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                            // Use classList for class attribute to preserve animations\n                            if (fromAttribute.name === 'class') {\n                                syncClassList(from, to);\n                            } else {\n                                to.setAttribute(fromAttribute.name, fromAttribute.value);\n                            }\n                        }\n                    } catch (error) {\n                        // dux fix\n                        console.error('Error setting attribute:', {\n                            badNode: to,\n                            badAttribute: fromAttribute,\n                            error: error.message,\n                        });\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * Sync class attribute using classList.add/remove to preserve CSS animations\n         * @param from {Element} element to sync classes from\n         * @param to {Element} element to sync classes to\n         */\n        function syncClassList(from, to) {\n            const fromClasses = new Set(from.className.split(/\\s+/).filter(Boolean));\n            const toClasses = new Set(to.className.split(/\\s+/).filter(Boolean));\n\n            // Remove classes that are no longer present\n            for (const cls of toClasses) {\n                if (!fromClasses.has(cls)) {\n                    to.classList.remove(cls);\n                }\n            }\n\n            // Add new classes\n            for (const cls of fromClasses) {\n                if (!toClasses.has(cls)) {\n                    to.classList.add(cls);\n                }\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n", "// pretty print HTML\nconst log_pretty_print = (html) => {\n  const parts = html\n    .split(/(<\\/?[^>]+>)/g)\n    .map(p => p.trim())\n    .filter(p => p);\n\n  let indent = 0;\n  const lines = [];\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i];\n    const nextPart = parts[i + 1];\n    const nextNextPart = parts[i + 2];\n\n    // Check if it's a tag\n    if (part.startsWith('<')) {\n      // Check if this is an opening tag followed by text and then its closing tag\n      if (!part.startsWith('</') && !part.endsWith('/>') && nextPart && !nextPart.startsWith('<') && nextNextPart && nextNextPart.startsWith('</')) {\n        // Combine them on one line\n        const actualIndent = Math.max(0, indent);\n        lines.push('  '.repeat(actualIndent) + part + nextPart + nextNextPart);\n        i += 2; // Skip the next two parts\n      }\n      // Closing tag\n      else if (part.startsWith('</')) {\n        indent--;\n        const actualIndent = Math.max(0, indent);\n        lines.push('  '.repeat(actualIndent) + part);\n      }\n      // Self-closing tag\n      else if (part.endsWith('/>') || part.includes(' />')) {\n        const actualIndent = Math.max(0, indent);\n        lines.push('  '.repeat(actualIndent) + part);\n      }\n      // Opening tag\n      else {\n        const actualIndent = Math.max(0, indent);\n        lines.push('  '.repeat(actualIndent) + part);\n        indent++;\n      }\n    }\n    // Text node\n    else if (part) {\n      const actualIndent = Math.max(0, indent);\n      lines.push('  '.repeat(actualIndent) + part);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\nconst LOG = (() => {\n  const logs = [];\n  const logTypes = []; // Track the original type of each log\n  let currentIndex = 0;\n  let renderContent = null; // Will hold the render function\n\n  // Add ESC key handler and arrow key navigation\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      const dialog = document.getElementById('dump-dialog');\n      const button = document.getElementById('log-reopen-button');\n\n      if (dialog) {\n        // Close dialog\n        dialog.remove();\n        createLogButton();\n      } else if (button) {\n        // Open dialog\n        button.remove();\n        showLogDialog();\n      }\n    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n      const dialog = document.getElementById('dump-dialog');\n      if (dialog && logs.length > 0) {\n        e.preventDefault();\n        if (e.key === 'ArrowLeft' && currentIndex > 0) {\n          currentIndex--;\n          localStorage.setItem('_LOG_INDEX', currentIndex);\n          renderContent();\n        } else if (e.key === 'ArrowRight' && currentIndex < logs.length - 1) {\n          currentIndex++;\n          localStorage.setItem('_LOG_INDEX', currentIndex);\n          renderContent();\n        } else if (e.key === 'ArrowUp' && currentIndex > 0) {\n          currentIndex = Math.max(0, currentIndex - 5);\n          localStorage.setItem('_LOG_INDEX', currentIndex);\n          renderContent();\n        } else if (e.key === 'ArrowDown' && currentIndex < logs.length - 1) {\n          currentIndex = Math.min(logs.length - 1, currentIndex + 5);\n          localStorage.setItem('_LOG_INDEX', currentIndex);\n          renderContent();\n        }\n      }\n    }\n  });\n\n  const createLogButton = () => {\n    let btn = document.getElementById('log-reopen-button');\n    if (!btn) {\n      btn = document.body.appendChild(document.createElement('button'));\n      btn.id = 'log-reopen-button';\n      btn.innerHTML = '<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" style=\"vertical-align:middle;margin-right:4px\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><polyline points=\"10 9 9 9 8 9\"></polyline></svg>LOG';\n      btn.style.cssText =\n        'position:fixed; top: 10px; right: 10px;' +\n        'padding:10px 20px;background:#ff3333;color:#fff;border:none;' +\n        'cursor:pointer;font:14px/1.4 monospace;z-index:2147483647;' +\n        'border-radius:8px;display:flex;align-items:center;' +\n        'opacity:1;visibility:visible;box-shadow:0 4px 12px rgba(255,51,51,0.3)';\n      btn.onclick = () => {\n        btn.remove();\n        showLogDialog();\n      };\n    }\n  };\n\n  const showLogDialog = () => {\n    let d = document.getElementById('dump-dialog');\n    if (!d) {\n      d = document.body.appendChild(document.createElement('div'));\n      d.id = 'dump-dialog';\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      d.style.cssText =\n        'position:absolute; top:' + (scrollTop + 20) + 'px; left: 20px; right:20px;' +\n        'background:#fff; border:1px solid #333; box-shadow:0 0 10px rgba(0,0,0,0.5);' +\n        'padding:20px; overflow:auto; z-index:2147483646; font:13px/1.4 monospace;' +\n        'white-space:pre; display:block; opacity:1; visibility:visible';\n    }\n\n    // Check if we have a saved index and it's still valid\n    const savedIndex = parseInt(localStorage.getItem('_LOG_INDEX'));\n    if (!isNaN(savedIndex) && savedIndex >= 0 && savedIndex < logs.length) {\n      currentIndex = savedIndex;\n    } else {\n      currentIndex = logs.length - 1;\n    }\n\n    renderContent = () => {\n      const buttons = logs.map((_, i) => {\n        let bgColor = '#f0f0f0'; // default\n        if (i !== currentIndex) {\n          if (logTypes[i] === 'object') {\n            bgColor = '#d6e3ef'; // super light blue\n          } else if (logTypes[i] === 'array') {\n            bgColor = '#d8d5ef'; // super light indigo\n          }\n        }\n        return `<button style=\"font-size: 14px; font-weight: 400; padding:2px 6px; margin: 0 2px 2px 0;cursor:pointer;background:${i === currentIndex ? '#333' : bgColor};color:${i === currentIndex ? '#fff' : '#000'}\" data-index=\"${i}\">${i + 1}</button>`\n      }).join('');\n\n      d.innerHTML =\n        '<div style=\"display:flex;flex-direction:column;height:100%\">' +\n        '<div style=\"display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px\">' +\n        '<div style=\"display:flex;flex-wrap:wrap;gap:4px;flex:1;margin-right:10px\">' + buttons + '</div>' +\n        '<button style=\"padding:4px 8px;cursor:pointer;flex-shrink:0\">&times;</button>' +\n        '</div>' +\n        '<xmp style=\"font-family:monospace;flex:1;overflow:auto;margin:0;padding:0;color:#000;background:#fff;font-size:14px;line-height:22px\">' + logs[currentIndex] + '</xmp>' +\n        '</div>';\n\n      d.querySelector('button[style*=\"flex-shrink:0\"]').onclick = () => {\n        d.remove();\n        createLogButton();\n      };\n\n      d.querySelectorAll('button[data-index]').forEach(btn => {\n        btn.onclick = () => {\n          currentIndex = parseInt(btn.dataset.index);\n          localStorage.setItem('_LOG_INDEX', currentIndex);\n          renderContent();\n        };\n      });\n    };\n\n    renderContent();\n  };\n\n  return o => {\n    if (!document.body) {\n      window.requestAnimationFrame( () => LOG(o) )\n      return\n    }\n\n    // Store the original type\n    let originalType = typeof o;\n\n    if (o instanceof Node) {\n      if (o.nodeType === Node.TEXT_NODE) {\n        o = o.textContent || String(o)\n      } else {\n        o = log_pretty_print(o.outerHTML)\n      }\n    }\n\n    if (o === undefined) { o = 'undefined' }\n    if (o === null) { o = 'null' }\n\n    if (Array.isArray(o)) {\n      originalType = 'array';\n    } else if (typeof o === 'object' && o !== null) {\n      originalType = 'object';\n    }\n\n    if (typeof o != 'string') {\n      o = JSON.stringify(o, (key, value) => {\n        if (typeof value === 'function') {\n          return String(value);\n        }\n        return value;\n      }, 2).replaceAll('<', '&lt;')\n    }\n\n    o = o.trim()\n\n    logs.push(o + `\\n\\ntype: ${originalType}`);\n    logTypes.push(originalType);\n\n    // Check if log dialog is open by checking for element\n    const isOpen = !!document.getElementById('dump-dialog');\n\n    if (!isOpen) {\n      // Show log dialog by default\n      showLogDialog();\n    } else {\n      // Update current index to the new log and refresh\n      currentIndex = logs.length - 1;\n      localStorage.setItem('_LOG_INDEX', currentIndex);\n      if (renderContent) {\n        renderContent();\n      }\n    }\n  };\n})();\n\nif (typeof window !== 'undefined' && !window.LOG) {\n  window.LOG = LOG\n}\n\nexport default LOG\n", "// Highlight all Fez elements with their names\nconst highlightAll = () => {\n  // Only work if Fez.DEV is true OR (port is above 2999 and Fez.DEV is not false)\n  const port = parseInt(window.location.port) || 80;\n  if (!(Fez.DEV === true || (port > 2999 && Fez.DEV !== false))) return;\n\n  // Check if highlights already exist\n  const existingHighlights = document.querySelectorAll('.fez-highlight-overlay');\n\n  if (existingHighlights.length > 0) {\n    // Remove existing highlights\n    existingHighlights.forEach(el => el.remove());\n    return;\n  }\n\n  // Find all Fez and Svelte elements\n  const allElements = document.querySelectorAll('.fez, .svelte');\n\n  allElements.forEach(el => {\n    let componentName = null;\n    let componentType = null;\n\n    // Check for Fez component\n    if (el.classList.contains('fez') && el.fez && el.fez.fezName) {\n      componentName = el.fez.fezName;\n      componentType = 'fez';\n    }\n    // Check for Svelte component\n    else if (el.classList.contains('svelte') && el.svelte && el.svelte.svelteName) {\n      componentName = el.svelte.svelteName;\n      componentType = 'svelte';\n    }\n\n    if (componentName) {\n      // Create overlay div\n      const overlay = document.createElement('div');\n      overlay.className = 'fez-highlight-overlay';\n\n      // Get element position\n      const rect = el.getBoundingClientRect();\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\n\n      // Style the overlay\n      overlay.style.cssText = `\n        position: absolute;\n        top: ${rect.top + scrollTop}px;\n        left: ${rect.left + scrollLeft}px;\n        width: ${rect.width}px;\n        height: ${rect.height}px;\n        border: 1px solid ${componentType === 'svelte' ? 'blue' : 'red'};\n        pointer-events: none;\n        z-index: 9999;\n      `;\n\n      // Create label for component name\n      const label = document.createElement('div');\n      label.textContent = componentName;\n      label.style.cssText = `\n        position: absolute;\n        top: -20px;\n        left: 0;\n        background: ${componentType === 'svelte' ? 'blue' : 'red'};\n        color: white;\n        padding: 4px 6px 2px 6px;\n        font-size: 14px;\n        font-family: monospace;\n        line-height: 1;\n        white-space: nowrap;\n        cursor: pointer;\n        pointer-events: auto;\n        text-transform: uppercase;\n      `;\n\n      // Add click handler to dump the node\n      label.addEventListener('click', (e) => {\n        e.stopPropagation();\n        Fez.log(el);\n      });\n\n      overlay.appendChild(label);\n      document.body.appendChild(overlay);\n    }\n  });\n}\n\n// Bind Ctrl+E to highlightAll\ndocument.addEventListener('keydown', (event) => {\n  if ((event.ctrlKey || event.metaKey) && event.key === 'e') {\n    // Check if target is not inside a form\n    if (!event.target.closest('form')) {\n      event.preventDefault();\n      highlightAll();\n    }\n  }\n});\n\nexport default highlightAll\n", "/**\n * Fez Component Registration & Connection\n *\n * This file handles:\n * - Registering components with customElements\n * - Transforming plain classes to FezBase subclasses\n * - Instantiating components when they appear in DOM\n *\n * Flow:\n * 1. connect(name, class) - registers custom element\n * 2. connectedCallback() - when element appears in DOM\n * 3. connectNode() - creates instance, renders, calls lifecycle\n */\n\nimport createTemplate from './lib/template.js'\nimport FezBase from './instance.js'\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst SELF_CLOSING_TAGS = new Set([\n  'area', 'base', 'br', 'col', 'embed', 'hr', 'img',\n  'input', 'link', 'meta', 'source', 'track', 'wbr'\n])\n\n// Attribute observer for reactive props\nconst attrObserver = new MutationObserver(mutations => {\n  for (const mutation of mutations) {\n    if (mutation.type === 'attributes') {\n      const fez = mutation.target.fez\n      if (fez) {\n        const name = mutation.attributeName\n        const value = mutation.target.getAttribute(name)\n        fez.props[name] = value\n        fez.onPropsChange(name, value)\n      }\n    }\n  }\n})\n\n// =============================================================================\n// MAIN CONNECT FUNCTION\n// =============================================================================\n\n/**\n * Register a Fez component\n *\n * @param {string} name - Custom element name (must contain dash)\n * @param {Class} klass - Component class\n *\n * @example\n * Fez('ui-button', class {\n *   HTML = '<button><slot /></button>'\n *   CSS = 'button { color: blue; }'\n *   init() { console.log('created') }\n * })\n */\nexport default function connect(name, klass) {\n  const Fez = globalThis.window?.Fez || globalThis.Fez\n\n  // Validate name\n  if (!name.includes('-')) {\n    console.error(`Fez: Invalid name \"${name}\". Must contain a dash.`)\n    return\n  }\n\n  // Transform to FezBase subclass\n  klass = ensureFezBase(Fez, name, klass)\n\n  // Process HTML template\n  if (klass.html) {\n    const slotTag = klass.SLOT || 'div'\n    klass.html = klass.html\n      .replace(/<slot(\\s[^>]*)?>/, `<${slotTag} class=\"fez-slot fez-slot-${name}\" fez-keep=\"slot-${name}\"$1>`)\n      .replace('</slot>', `</${slotTag}>`)\n\n    klass.fezHtmlFunc = createTemplate(klass.html, { name })\n  }\n\n  // Register CSS\n  if (klass.css) {\n    klass.css = Fez.globalCss(klass.css, { name })\n  }\n\n  // Store class\n  Fez.classes[name] = klass\n\n  // Register custom element\n  if (!customElements.get(name)) {\n    customElements.define(name, class extends HTMLElement {\n      connectedCallback() {\n        if (shouldRenderFast(this, klass)) {\n          connectNode(name, this)\n        } else {\n          requestAnimationFrame(() => connectNode(name, this))\n        }\n      }\n    })\n  }\n}\n\n// =============================================================================\n// CLASS TRANSFORMATION\n// =============================================================================\n\n/**\n * Transform plain class to FezBase subclass\n * Maps uppercase config props (HTML, CSS, etc.)\n */\nfunction ensureFezBase(Fez, name, klass) {\n  // Already a FezBase subclass\n  if (klass.prototype instanceof FezBase) {\n    if (klass.html) klass.html = closeCustomTags(klass.html)\n    return klass\n  }\n\n  // Create FezBase subclass\n  const instance = new klass()\n  const newKlass = class extends FezBase {}\n\n  // Copy properties and methods\n  const props = [\n    ...Object.getOwnPropertyNames(instance),\n    ...Object.getOwnPropertyNames(klass.prototype)\n  ].filter(p => p !== 'constructor' && p !== 'prototype')\n\n  for (const prop of props) {\n    newKlass.prototype[prop] = instance[prop]\n  }\n\n  // Map config properties\n  const configMap = { FAST: 'FAST', GLOBAL: 'GLOBAL', CSS: 'css', NAME: 'nodeName' }\n  for (const [from, to] of Object.entries(configMap)) {\n    if (instance[from]) newKlass[to] = instance[from]\n  }\n\n  // Handle HTML\n  if (instance.HTML) {\n    newKlass.html = closeCustomTags(instance.HTML)\n  }\n\n  // Auto-mount global components\n  if (instance.GLOBAL) {\n    Fez.onReady(() => document.body.appendChild(document.createElement(name)))\n  }\n\n  Fez.consoleLog(`${name} compiled`)\n  return newKlass\n}\n\n/**\n * Convert self-closing custom tags to full format\n * <my-comp /> -> <my-comp></my-comp>\n */\nfunction closeCustomTags(html) {\n  return html.replace(/<([a-z-]+)\\b([^>]*)\\/>/g, (match, tag, attrs) => {\n    return SELF_CLOSING_TAGS.has(tag) ? match : `<${tag}${attrs}></${tag}>`\n  })\n}\n\n/**\n * Determine if component should render synchronously\n */\nfunction shouldRenderFast(node, klass) {\n  const attr = node.getAttribute('fez-fast')\n  if (attr === 'false') return false\n\n  const klassFast = typeof klass.FAST === 'function' ? klass.FAST(node) : klass.FAST\n  return !!(attr || klassFast || node.childNodes[0] || node.nextSibling)\n}\n\n// =============================================================================\n// NODE CONNECTION (Instantiation)\n// =============================================================================\n\n/**\n * Initialize component instance from DOM node\n */\nfunction connectNode(name, node) {\n  if (!node.isConnected) return\n  if (node.classList?.contains('fez')) return\n\n  const klass = Fez.classes[name]\n  const nodeName = typeof klass.nodeName === 'function' ? klass.nodeName(node) : klass.nodeName\n  const newNode = document.createElement(nodeName || 'div')\n\n  newNode.classList.add('fez', `fez-${name}`)\n\n  if (!node.parentNode) {\n    console.warn(`Fez: ${name} has no parent, skipping`)\n    return\n  }\n\n  // Replace custom element with component node\n  node.parentNode.replaceChild(newNode, node)\n\n  // Create instance\n  const fez = new klass()\n  fez.UID = ++Fez.instanceCount\n  Fez.instances.set(fez.UID, fez)\n\n  fez.oldRoot = node\n  fez.fezName = name\n  fez.root = newNode\n  fez.props = klass.getProps(node, newNode)\n  fez.class = klass\n\n  // Move children (slot content)\n  fez.fezSlot(node, newNode)\n\n  newNode.fez = fez\n\n  // Global component reference\n  if (klass.GLOBAL && klass.GLOBAL !== true) {\n    window[klass.GLOBAL] ||= fez\n  }\n\n  // jQuery compatibility\n  if (window.$) fez.$root = $(newNode)\n\n  // Copy ID\n  if (fez.props.id) newNode.setAttribute('id', fez.props.id)\n\n  // === LIFECYCLE ===\n\n  // Setup reactive state\n  fez.fezRegister()\n\n  // Init (supports multiple naming conventions)\n  const initMethod = fez.onInit || fez.init || fez.created || fez.connect\n  initMethod.call(fez, fez.props)\n\n  // Render\n  fez.fezRender()\n\n  // Mount\n  fez.onMount(fez.props)\n\n  // Form submit handling\n  if (fez.onSubmit) {\n    const form = fez.root.nodeName === 'FORM' ? fez.root : fez.find('form')\n    if (form) {\n      form.onsubmit = (e) => {\n        e.preventDefault()\n        fez.onSubmit(fez.formData())\n      }\n    }\n  }\n\n  // Watch for attribute changes\n  if (fez.onPropsChange) {\n    attrObserver.observe(newNode, { attributes: true })\n    for (const [key, value] of Object.entries(fez.props)) {\n      fez.onPropsChange(key, value)\n    }\n  }\n}\n", "/**\n * Fez Component Compiler\n *\n * Compiles component definitions from various sources:\n * - <template fez=\"name\">...</template>\n * - <xmp fez=\"name\">...</xmp>\n * - <script fez=\"name\">...</script>\n * - Remote URLs\n *\n * Flow:\n * 1. Source (template/xmp/url) -> compile()\n * 2. Extract parts (script/style/html) -> compileToClass()\n * 3. Generate class string -> Fez('name', class { ... })\n */\n\n// =============================================================================\n// MAIN COMPILE FUNCTION\n// =============================================================================\n\n/**\n * Compile a Fez component\n *\n * @example\n * Fez.compile()                        // Compile all templates in document\n * Fez.compile(templateNode)            // Compile a template node\n * Fez.compile('ui-foo', htmlString)    // Compile from string\n *\n * @param {string|Node} tagName - Component name or template node\n * @param {string} [html] - Component HTML source\n */\nexport default function compile(tagName, html) {\n  // Single argument: compile node or all templates\n  if (arguments.length === 1) {\n    return compileBulk(tagName)\n  }\n\n  // Multiple xmp tags in html? Process them\n  if (html?.includes('</xmp>')) {\n    return compileBulk(html)\n  }\n\n  // Validate component name\n  if (tagName && !tagName.includes('-') && !tagName.includes('.') && !tagName.includes('/')) {\n    console.error(`Fez: Invalid name \"${tagName}\". Must contain a dash (e.g., 'my-element').`)\n    return\n  }\n\n  // Extract and compile\n  const classCode = generateClassCode(tagName, compileToClass(html))\n\n  // Hide custom element until compiled\n  hideCustomElement(tagName)\n\n  // Execute the class code\n  executeClassCode(tagName, classCode)\n}\n\n// =============================================================================\n// COMPILE FROM VARIOUS SOURCES\n// =============================================================================\n\n/**\n * Compile from node or HTML string containing templates\n */\nfunction compileBulk(data) {\n  // Single template node\n  if (data instanceof Node) {\n    const node = data\n    node.remove()\n\n    const fezName = node.getAttribute('fez')\n\n    // URL reference\n    if (fezName?.includes('.') || fezName?.includes('/')) {\n      return compileFromUrl(fezName)\n    }\n\n    // Validate name\n    if (fezName && !fezName.includes('-')) {\n      console.error(`Fez: Invalid name \"${fezName}\". Must contain a dash.`)\n      return\n    }\n\n    return compile(fezName, node.innerHTML)\n  }\n\n  // HTML string or document\n  const root = data ? Fez.domRoot(data) : document.body\n  root.querySelectorAll('template[fez], xmp[fez]').forEach(n => compileBulk(n))\n}\n\n/**\n * Compile component(s) from remote URL\n */\nfunction compileFromUrl(url) {\n  Fez.consoleLog(`Loading from ${url}`)\n\n  Fez.fetch(url)\n    .then(content => {\n      const doc = new DOMParser().parseFromString(content, 'text/html')\n      const fezElements = doc.querySelectorAll('template[fez], xmp[fez]')\n\n      if (fezElements.length > 0) {\n        // Multiple components in file\n        fezElements.forEach(el => {\n          const name = el.getAttribute('fez')\n          if (name && !name.includes('-') && !name.includes('.') && !name.includes('/')) {\n            console.error(`Fez: Invalid name \"${name}\". Must contain a dash.`)\n            return\n          }\n          compile(name, el.innerHTML)\n        })\n      } else {\n        // Single component, derive name from URL\n        const name = url.split('/').pop().split('.')[0]\n        compile(name, content)\n      }\n    })\n    .catch(error => {\n      Fez.onError('compile', `Load error for \"${url}\": ${error.message}`)\n    })\n}\n\nexport { compileFromUrl as compile_from_url }\n\n// =============================================================================\n// PARSE COMPONENT SOURCE\n// =============================================================================\n\n/**\n * Parse component HTML into { script, style, html, head }\n */\nfunction compileToClass(html) {\n  const result = { script: '', style: '', html: '', head: '' }\n  const lines = html.split('\\n')\n\n  let block = []\n  let type = ''\n\n  for (let line of lines) {\n    line = line.trim()\n\n    // Start blocks\n    if (line.startsWith('<script') && !result.script && type !== 'head') {\n      type = 'script'\n    } else if (line.startsWith('<head') && !result.script) {\n      type = 'head'\n    } else if (line.startsWith('<style')) {\n      type = 'style'\n\n    // End blocks\n    } else if (line.endsWith('</script>') && type === 'script' && !result.script) {\n      result.script = block.join('\\n')\n      block = []\n      type = ''\n    } else if (line.endsWith('</style>') && type === 'style') {\n      result.style = block.join('\\n')\n      block = []\n      type = ''\n    } else if ((line.endsWith('</head>') || line.endsWith('</header>')) && type === 'head') {\n      result.head = block.join('\\n')\n      block = []\n      type = ''\n\n    // Collect content\n    } else if (type) {\n      block.push(line)\n    } else {\n      result.html += line + '\\n'\n    }\n  }\n\n  // Process head elements (scripts, links, etc.)\n  if (result.head) {\n    processHeadElements(result.head)\n  }\n\n  return result\n}\n\n/**\n * Process <head> elements from component\n */\nfunction processHeadElements(headHtml) {\n  const container = Fez.domRoot(headHtml)\n\n  Array.from(container.children).forEach(node => {\n    if (node.tagName === 'SCRIPT') {\n      const script = document.createElement('script')\n      Array.from(node.attributes).forEach(attr => {\n        script.setAttribute(attr.name, attr.value)\n      })\n      script.type ||= 'text/javascript'\n\n      if (node.src) {\n        document.head.appendChild(script)\n      } else if (script.type.includes('javascript') || script.type === 'module') {\n        script.textContent = node.textContent\n        document.head.appendChild(script)\n      }\n    } else {\n      document.head.appendChild(node.cloneNode(true))\n    }\n  })\n}\n\n// =============================================================================\n// GENERATE CLASS CODE\n// =============================================================================\n\n/**\n * Generate executable class code from parsed parts\n */\nfunction generateClassCode(tagName, parts) {\n  let klass = parts.script\n\n  // Wrap in class if needed\n  if (!/class\\s+\\{/.test(klass)) {\n    klass = `class {\\n${klass}\\n}`\n  }\n\n  // Add CSS\n  if (String(parts.style).includes(':')) {\n    let css = Fez.cssMixin(parts.style)\n    css = css.includes(':fez') || /(?:^|\\s)body\\s*\\{/.test(css)\n      ? css\n      : `:fez {\\n${css}\\n}`\n    klass = klass.replace(/\\}\\s*$/, `\\n  CSS = \\`${css}\\`\\n}`)\n  }\n\n  // Add HTML\n  if (/\\w/.test(String(parts.html))) {\n    const html = parts.html\n      .replaceAll('`', '&#x60;')\n      .replaceAll('$', '\\\\$')\n    klass = klass.replace(/\\}\\s*$/, `\\n  HTML = \\`${html}\\`\\n}`)\n  }\n\n  // Wrap in Fez call\n  const [before, after] = klass.split(/class\\s+\\{/, 2)\n  return `${before};\\n\\nwindow.Fez('${tagName}', class {\\n${after})`\n}\n\n/**\n * Execute generated class code\n */\nfunction executeClassCode(tagName, code) {\n  // Module imports require script tag\n  if (code.includes('import ')) {\n    Fez.head({ script: code })\n\n    // Check for compile errors after delay\n    setTimeout(() => {\n      if (!Fez.classes[tagName]) {\n        Fez.consoleError(`Template \"${tagName}\" possible compile error.`)\n      }\n    }, 2000)\n  } else {\n    try {\n      new Function(code)()\n    } catch (e) {\n      Fez.consoleError(`Template \"${tagName}\" compile error: ${e.message}`)\n      console.log(code)\n    }\n  }\n}\n\n/**\n * Add CSS to hide custom element until compiled\n */\nfunction hideCustomElement(tagName) {\n  if (!tagName) return\n\n  let styleEl = document.getElementById('fez-hidden-styles')\n  if (!styleEl) {\n    styleEl = document.createElement('style')\n    styleEl.id = 'fez-hidden-styles'\n    document.head.appendChild(styleEl)\n  }\n\n  const allTags = [...Object.keys(Fez.classes), tagName].sort().join(', ')\n  styleEl.textContent = `${allTags} { display: none; }\\n`\n}\n", "// Global state manager with automatic component subscription\n//\n// Components access state via this.globalState proxy which automatically:\n// - Registers component as listener when reading a value\n// - Notifies component when that value changes\n// - Calls onGlobalStateChange(key, value) if defined, then fezRender()\n//\n// Example usage:\n//\n//   class Counter extends FezBase {\n//     increment() {\n//       this.globalState.count = (this.globalState.count || 0) + 1\n//     }\n//\n//     onGlobalStateChange(key, value) {\n//       console.log(`State ${key} changed to ${value}`)\n//     }\n//\n//     render() {\n//       return `<button onclick=\"fez.increment()\">\n//         Count: ${this.globalState.count || 0}\n//       </button>`\n//     }\n//   }\n//\n// External access:\n//   Fez.state.set('count', 10)\n//   Fez.state.get('count') // 10\n\nconst GlobalState = {\n  data: {},\n  listeners: new Map(), // key -> Set of components\n  subscribers: new Map(), // key -> Set of functions (for subscribe method)\n  globalSubscribers: new Set(), // Set of functions that listen to all changes\n\n  notify(key, value, oldValue) {\n    Fez.consoleLog(`Global state change for ${key}: ${value} (from ${oldValue})`)\n\n    // Notify component listeners\n    const listeners = this.listeners.get(key)\n    if (listeners) {\n      listeners.forEach(comp => {\n        if (comp.isConnected) {\n          comp.onGlobalStateChange(key, value, oldValue)\n          comp.fezRender()\n        } else {\n          listeners.delete(comp)\n        }\n      })\n    }\n\n    // Notify key-specific subscribers\n    const subscribers = this.subscribers.get(key)\n    if (subscribers) {\n      subscribers.forEach(func => {\n        try {\n          func(value, oldValue, key)\n        } catch (error) {\n          console.error(`Error in subscriber for key ${key}:`, error)\n        }\n      })\n    }\n\n    // Notify global subscribers\n    this.globalSubscribers.forEach(func => {\n      try {\n        func(key, value, oldValue)\n      } catch (error) {\n        console.error(`Error in global subscriber:`, error)\n      }\n    })\n  },\n\n  createProxy(component) {\n    return new Proxy({}, {\n      get: (target, key) => {\n        // Skip if already listening to this key\n        component._globalStateKeys ||= new Set()\n        if (!component._globalStateKeys.has(key)) {\n          component._globalStateKeys.add(key)\n\n          if (!this.listeners.has(key)) {\n            this.listeners.set(key, new Set())\n          }\n          this.listeners.get(key).add(component)\n        }\n\n        return this.data[key]\n      },\n\n      set: (target, key, value) => {\n        const oldValue = this.data[key]\n        if (oldValue !== value) {\n          this.data[key] = value\n          this.notify(key, value, oldValue)\n        }\n        return true\n      }\n    })\n  },\n\n  // Direct methods for use outside components\n  set(key, value) {\n    const oldValue = this.data[key]\n    if (oldValue !== value) {\n      this.data[key] = value\n      this.notify(key, value, oldValue)\n    }\n  },\n\n  get(key) {\n    return this.data[key]\n  },\n\n  // Execute function for each component listening to a key\n  forEach(key, func) {\n    const listeners = this.listeners.get(key)\n    if (listeners) {\n      listeners.forEach(comp => {\n        if (comp.isConnected) {\n          func(comp)\n        } else {\n          listeners.delete(comp)\n        }\n      })\n    }\n  },\n\n  // Subscribe to state changes\n  // Usage: Fez.state.subscribe(func) - listen to all changes\n  //        Fez.state.subscribe(key, func) - listen to specific key changes\n  subscribe(keyOrFunc, func) {\n    if (typeof keyOrFunc === 'function') {\n      // subscribe(func) - global subscription\n      this.globalSubscribers.add(keyOrFunc)\n      return () => this.globalSubscribers.delete(keyOrFunc)\n    } else {\n      // subscribe(key, func) - key-specific subscription\n      const key = keyOrFunc\n      if (!this.subscribers.has(key)) {\n        this.subscribers.set(key, new Set())\n      }\n      this.subscribers.get(key).add(func)\n      return () => {\n        const keySubscribers = this.subscribers.get(key)\n        if (keySubscribers) {\n          keySubscribers.delete(func)\n          if (keySubscribers.size === 0) {\n            this.subscribers.delete(key)\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default GlobalState\n", "// Utility functions that extend Fez\nexport default (Fez) => {\n  // Script from URL\n  //   Fez.head({ js: 'https://example.com/script.js' });\n  // Script with attributes\n  //   Fez.head({ js: 'https://example.com/script.js', type: 'module', async: true });\n  // Script with callback\n  //   Fez.head({ js: 'https://example.com/script.js' }, () => { console.log('loaded') });\n  // Module loading with auto-import to window\n  //   Fez.head({ js: 'https://example.com/module.js', module: 'MyModule' }); // imports and sets window.MyModule\n  // CSS inclusion\n  //   Fez.head({ css: 'https://example.com/styles.css' });\n  // CSS with additional attributes and callback\n  //   Fez.head({ css: 'https://example.com/styles.css', media: 'print' }, () => { console.log('CSS loaded') })\n  // Inline script evaluation\n  //   Fez.head({ script: 'console.log(\"Hello world\")' })\n  // Extract from nodes\n  //   Fez.head(domNode)\n  Fez.head = (config, callback) => {\n    if (config.nodeName) {\n      if (config.nodeName == 'SCRIPT') {\n        Fez.head({script: config.innerText})\n        config.remove()\n      } else {\n        config.querySelectorAll('script').forEach((n) => Fez.head(n) )\n        config.querySelectorAll('template[fez], xmp[fez], script[fez]').forEach((n) => Fez.compile(n) )\n      }\n\n      return\n    }\n\n    if (typeof config !== 'object' || config === null) {\n      throw new Error('head requires an object parameter');\n    }\n\n    let src, attributes = {}, elementType;\n\n    if (config.script) {\n      if (config.script.includes('import ')) {\n        if (callback) {\n          Fez.consoleError('Fez.head callback is not supported when script with import is passed (module context).')\n        }\n\n        // Evaluate inline script in context in the module\n        const script = document.createElement('script');\n        script.type = 'module';\n        script.textContent = config.script;\n        document.head.appendChild(script);\n        requestAnimationFrame(()=>script.remove())\n      } else {\n        try {\n          new Function(config.script)();\n          if (callback) callback();\n        } catch (error) {\n          Fez.consoleError('Error executing script:', error);\n          console.log(config.script);\n        }\n      }\n      return;\n    } else if (config.js) {\n      src = config.js;\n      elementType = 'script';\n      // Copy all properties except 'js' as attributes\n      for (const [key, value] of Object.entries(config)) {\n        if (key !== 'js' && key !== 'module') {\n          attributes[key] = value;\n        }\n      }\n      // Handle module loading\n      if (config.module) {\n        attributes.type = 'module';\n      }\n    } else if (config.css) {\n      src = config.css;\n      elementType = 'link';\n      attributes.rel = 'stylesheet';\n      // Copy all properties except 'css' as attributes\n      for (const [key, value] of Object.entries(config)) {\n        if (key !== 'css') {\n          attributes[key] = value;\n        }\n      }\n    } else {\n      throw new Error('head requires either \"script\", \"js\" or \"css\" property');\n    }\n\n    const existingNode = document.querySelector(`${elementType}[src=\"${src}\"], ${elementType}[href=\"${src}\"]`);\n    if (existingNode) {\n      if (callback) callback();\n      return existingNode;\n    }\n\n    const element = document.createElement(elementType);\n\n    if (elementType === 'link') {\n      element.href = src;\n    } else {\n      element.src = src;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      element.setAttribute(key, value);\n    }\n\n    if (callback || config.module) {\n      element.onload = () => {\n        // If module name is provided, import it and assign to window\n        if (config.module && elementType === 'script') {\n          import(src).then(module => {\n            window[config.module] = module.default || module[config.module] || module;\n          }).catch(error => {\n            console.error(`Error importing module ${config.module}:`, error);\n          });\n        }\n        if (callback) callback();\n      };\n    }\n\n    document.head.appendChild(element);\n\n    return element;\n  }\n\n  // Cache configuration\n  const FETCH_CACHE_TTL = 5 * 60 * 1000 // 5 minutes\n  const FETCH_CACHE_MAX_SIZE = 100\n\n  // Fetch wrapper with automatic caching and data handling\n  // Usage:\n  //   Fez.fetch(url) - GET request (default)\n  //   Fez.fetch(url, callback) - GET with callback\n  //   Fez.fetch(url, data) - GET with query params (?foo=bar&baz=qux)\n  //   Fez.fetch(url, data, callback) - GET with query params and callback\n  //   Fez.fetch('POST', url, data) - POST with FormData body (multipart/form-data)\n  //   Fez.fetch('POST', url, data, callback) - POST with FormData and callback\n  // Data object is automatically converted:\n  //   - GET: appended as URL query parameters\n  //   - POST: sent as FormData (multipart/form-data) without custom headers\n  Fez.fetch = function(...args) {\n    // Initialize cache if not exists\n    Fez._fetchCache ||= new Map()\n\n    let method = 'GET';\n    let url;\n    let callback;\n\n    // Check if first arg is HTTP method (uppercase letters)\n    if (typeof args[0] === 'string' && /^[A-Z]+$/.test(args[0])) {\n      method = args.shift();\n    }\n\n    // URL is required\n    url = args.shift();\n\n    // Check for data/options object\n    let opts = {};\n    let data = null;\n    if (typeof args[0] === 'object') {\n      data = args.shift();\n    }\n\n    // Check for callback function\n    if (typeof args[0] === 'function') {\n      callback = args.shift();\n    }\n\n    // Handle data based on method\n    if (data) {\n      if (method === 'GET') {\n        // For GET, append data as query parameters\n        const params = new URLSearchParams(data);\n        url += (url.includes('?') ? '&' : '?') + params.toString();\n      } else if (method === 'POST') {\n        // For POST, convert to FormData\n        const formData = new FormData();\n        for (const [key, value] of Object.entries(data)) {\n          formData.append(key, value);\n        }\n        opts.body = formData;\n      }\n    }\n\n    // Set method\n    opts.method = method;\n\n    // Create cache key from method, url, and stringified opts\n    const cacheKey = `${method}:${url}:${JSON.stringify(opts)}`\n\n    // Check cache first (with TTL validation)\n    const cached = Fez._fetchCache.get(cacheKey)\n    if (cached && (Date.now() - cached.timestamp < FETCH_CACHE_TTL)) {\n      Fez.consoleLog(`fetch cache hit: ${method} ${url}`)\n      if (callback) {\n        callback(cached.data)\n        return\n      }\n      return Promise.resolve(cached.data)\n    }\n\n    // Log live fetch\n    Fez.consoleLog(`fetch live: ${method} ${url}`);\n\n    // Helper to process and cache response\n    const processResponse = (response) => {\n      if (response.headers.get('content-type')?.includes('application/json')) {\n        return response.json()\n      }\n      return response.text()\n    }\n\n    // Helper to store in cache with size limit\n    const storeInCache = (key, data) => {\n      // Enforce max cache size by removing oldest entries\n      if (Fez._fetchCache.size >= FETCH_CACHE_MAX_SIZE) {\n        const oldestKey = Fez._fetchCache.keys().next().value\n        Fez._fetchCache.delete(oldestKey)\n      }\n      Fez._fetchCache.set(key, { data, timestamp: Date.now() })\n    }\n\n    // If callback provided, execute and handle\n    if (callback) {\n      fetch(url, opts)\n        .then(processResponse)\n        .then(data => {\n          storeInCache(cacheKey, data)\n          callback(data)\n        })\n        .catch(error => Fez.onError('fetch', error))\n      return\n    }\n\n    // Return promise with automatic JSON parsing\n    return fetch(url, opts)\n      .then(processResponse)\n      .then(data => {\n        storeInCache(cacheKey, data)\n        return data\n      })\n  }\n\n  // Clear fetch cache (useful for testing or manual cache invalidation)\n  Fez.clearFetchCache = () => {\n    Fez._fetchCache?.clear()\n  }\n\n  Fez.darkenColor = (color, percent = 20) => {\n    // Convert hex to RGB\n    const num = parseInt(color.replace(\"#\", \"\"), 16)\n    const amt = Math.round(2.55 * percent)\n    const R = (num >> 16) - amt\n    const G = (num >> 8 & 0x00FF) - amt\n    const B = (num & 0x0000FF) - amt\n    return \"#\" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1)\n  }\n\n  Fez.lightenColor = (color, percent = 20) => {\n    // Convert hex to RGB\n    const num = parseInt(color.replace(\"#\", \"\"), 16)\n    const amt = Math.round(2.55 * percent)\n    const R = (num >> 16) + amt\n    const G = (num >> 8 & 0x00FF) + amt\n    const B = (num & 0x0000FF) + amt\n    return \"#\" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1)\n  }\n\n  /**\n   * Escapes HTML special characters in a string\n   * Also strips font-family styles (common source of XSS via CSS)\n   */\n  Fez.htmlEscape = (text) => {\n    if (typeof text === 'string') {\n      return text\n        .replace(/font-family\\s*:\\s*(?:&[^;]+;|[^;])*?;/gi, '') // Strip font-family (CSS safety)\n        .replaceAll('&', '&amp;')\n        .replaceAll(\"'\", '&apos;')\n        .replaceAll('\"', '&quot;')\n        .replaceAll('<', '&lt;')\n        .replaceAll('>', '&gt;')\n    }\n    return text === undefined ? '' : text\n  }\n\n  // create dom root and return it\n  Fez.domRoot = (data, name = 'div') => {\n    if (data instanceof Node) {\n      return data\n    } else {\n      const root = document.createElement(name)\n      root.innerHTML = data\n      return root\n    }\n  }\n\n  // add class by name to node and remove it from siblings\n  Fez.activateNode = (node, klass = 'active') => {\n    if (!node || !node.parentElement) return\n    Array.from(node.parentElement.children).forEach(child => {\n      child.classList.remove(klass)\n    })\n    node.classList.add(klass)\n  }\n\n  Fez.isTrue = (val) => {\n    return ['1', 'true', 'on'].includes(String(val).toLowerCase())\n  }\n\n  // get document unique ID\n  Fez.UID = 111\n  Fez.uid = () => {\n    return 'fez_uid_' + (++Fez.UID).toString(32)\n  }\n\n  // get global function pointer, used to pass functions to nested or inline elements\n  // <some-node :callback=\"${Fez.pointer(opts.callback)}\" ...>\n  // Pointers are automatically cleaned up after first use (one-time use by default)\n  // Use Fez.pointer(func, { persist: true }) to keep the pointer\n  Fez.POINTER_SEQ = 0\n  Fez.POINTER = {}\n  Fez.pointer = (func, opts = {}) => {\n    if (typeof func == 'function') {\n      const uid = ++Fez.POINTER_SEQ\n\n      if (opts.persist) {\n        // Persistent pointer - stays until manually removed\n        Fez.POINTER[uid] = func\n      } else {\n        // One-time use pointer - auto-cleanup after first call\n        Fez.POINTER[uid] = (...args) => {\n          const result = func(...args)\n          delete Fez.POINTER[uid]\n          return result\n        }\n      }\n\n      return `Fez.POINTER[${uid}]`\n    }\n  }\n\n  // Manually clear all pointers (useful for testing or cleanup)\n  Fez.clearPointers = () => {\n    Fez.POINTER = {}\n  }\n\n  // Resolve a function from a string or function reference\n  Fez.getFunction = (pointer) => {\n    if (!pointer) {\n      return ()=>{}\n    }\n    else if (typeof pointer === 'function') {\n      return pointer;\n    }\n    else if (typeof pointer === 'string') {\n      // Check if it's a function expression (arrow function or function keyword)\n      // Arrow function: (args) => or args =>\n      const arrowFuncPattern = /^\\s*\\(?\\s*\\w+(\\s*,\\s*\\w+)*\\s*\\)?\\s*=>/;\n      const functionPattern = /^\\s*function\\s*\\(/;\n\n      if (arrowFuncPattern.test(pointer) || functionPattern.test(pointer)) {\n        return new Function('return ' + pointer)();\n      } else if (pointer.includes('.') && !pointer.includes('(')) {\n        // It's a property access like \"this.focus\" - return a function that calls it\n        return new Function(`return function() { return ${pointer}(); }`);\n      } else {\n        // It's a function body\n        return new Function(pointer);\n      }\n    }\n  }\n\n  // Execute a function when DOM is ready or immediately if already loaded\n  Fez.onReady = (callback) => {\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', ()=>{\n        callback()\n      }, { once: true })\n    } else {\n      callback()\n    }\n  }\n\n  // get unique id from string\n  Fez.fnv1 = (str) => {\n    var FNV_OFFSET_BASIS, FNV_PRIME, hash, i, j, ref;\n    FNV_OFFSET_BASIS = 2166136261;\n    FNV_PRIME = 16777619;\n    hash = FNV_OFFSET_BASIS;\n    for (i = j = 0, ref = str.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n      hash ^= str.charCodeAt(i);\n      hash *= FNV_PRIME;\n    }\n    return hash.toString(36).replaceAll('-', '');\n  }\n\n  Fez.tag = (tag, opts = {}, html = '') => {\n    const json = encodeURIComponent(JSON.stringify(opts))\n    return `<${tag} data-props=\"${json}\">${html}</${tag}>`\n    // const json = JSON.stringify(opts, null, 2)\n    // const data = `<script type=\"text/template\">${json}</script><${tag} data-json-template=\"true\">${html}</${tag}>`\n    // return data\n  }\n\n  // execute function until it returns true\n  Fez.untilTrue = (func, pingRate) => {\n    pingRate ||= 200\n\n    if (!func()) {\n      setTimeout(()=>{\n        Fez.untilTrue(func, pingRate)\n      } ,pingRate)\n    }\n  }\n\n  // Default throttle delay in ms\n  const DEFAULT_THROTTLE_DELAY = 200\n\n  // throttle function calls\n  Fez.throttle = (func, delay = DEFAULT_THROTTLE_DELAY) => {\n    let lastRun = 0;\n    let timeout;\n\n    return function(...args) {\n      const now = Date.now();\n\n      if (now - lastRun >= delay) {\n        func.apply(this, args);\n        lastRun = now;\n      } else {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n          func.apply(this, args);\n          lastRun = Date.now();\n        }, delay - (now - lastRun));\n      }\n    };\n  }\n\n}\n", "// define custom style macro - simple scss mixin\n// :mobile { ... } -> @media (max-width:  768px) { ... }\n// @include mobile { ... } -> @media (max-width:  768px) { ... }\n// demo/fez/ui-style.fez\n\nconst CssMixins = {}\n\nexport default (Fez) => {\n  Fez.cssMixin = (name, content) => {\n    if (content) {\n      CssMixins[name] = content\n    } else {\n      Object.entries(CssMixins).forEach(([key, val])=>{\n        name = name.replaceAll(`:${key} `, `${val} `)\n        name = name.replaceAll(`@include ${key} `, `${val} `)\n      })\n\n      return name\n    }\n  }\n\n  Fez.cssMixin('mobile', '@media (max-width: 767px)')\n  Fez.cssMixin('tablet', '@media (min-width: 768px) and (max-width: 1023px)')\n  Fez.cssMixin('desktop', '@media (min-width:  1200px)')\n}\n", "/**\n * Fez - Main Framework Object\n *\n * This file contains:\n * - Main Fez function (component registration and lookup)\n * - Component registry\n * - CSS utilities\n * - Pub/Sub system\n * - DOM morphing\n * - Error handling\n * - Temporary store\n *\n * For component instance methods, see instance.js\n */\n\n// =============================================================================\n// IMPORTS\n// =============================================================================\n\nimport Gobber from './vendor/gobber.js'\nimport { Idiomorph } from './vendor/idiomorph.js'\nimport objectDump from './utils/dump.js'\nimport highlightAll from './utils/highlight_all.js'\nimport connect from './connect.js'\nimport compile from './compile.js'\nimport state from './lib/global-state.js'\n\n// =============================================================================\n// MAIN FEZ FUNCTION\n// =============================================================================\n\n/**\n * Main Fez function - register or find components\n *\n * @example\n * Fez('ui-foo', class { ... })  // Register component\n * Fez('ui-foo')                  // Find first instance\n * Fez(123)                       // Find by UID\n * Fez(domNode)                   // Find from DOM node\n * Fez('ui-foo', fn)              // Find all & execute callback\n *\n * @param {string|number|Node} name - Component name, UID, or DOM node\n * @param {Class|Function} [klass] - Component class or callback\n * @returns {FezBase|Array|void}\n */\nconst Fez = (name, klass) => {\n  // Find by UID\n  if (typeof name === 'number') {\n    const fez = Fez.instances.get(name)\n    if (fez) return fez\n    Fez.consoleError(`Instance with UID \"${name}\" not found.`)\n    return\n  }\n\n  if (!name) {\n    Fez.consoleError('Fez() ?')\n    return\n  }\n\n  // With second argument\n  if (klass) {\n    const isPureFn = typeof klass === 'function' &&\n      !/^\\s*class/.test(klass.toString()) &&\n      !/\\b(this|new)\\b/.test(klass.toString())\n\n    // Fez('name', callback) - find all & execute\n    if (isPureFn) {\n      const list = Array\n        .from(document.querySelectorAll(`.fez.fez-${name}`))\n        .filter(n => n.fez)\n      list.forEach(el => klass(el.fez))\n      return list\n    }\n\n    // Fez('name', selector) - find with context\n    if (typeof klass !== 'function') {\n      return Fez.find(name, klass)\n    }\n\n    // Fez('name', class) - register component\n    return connect(name, klass)\n  }\n\n  // Find instance by name or node\n  const node = name.nodeName\n    ? name.closest('.fez')\n    : document.querySelector(name.includes('#') ? name : `.fez.fez-${name}`)\n\n  if (!node) {\n    Fez.consoleError(`node \"${name}\" not found.`)\n    return\n  }\n\n  if (!node.fez) {\n    Fez.consoleError(`node \"${name}\" has no Fez attached.`)\n    return\n  }\n\n  return node.fez\n}\n\n// =============================================================================\n// COMPONENT REGISTRY\n// =============================================================================\n\n/** Registered component classes by name */\nFez.classes = {}\n\n/** Counter for unique instance IDs */\nFez.instanceCount = 0\n\n/** Active component instances by UID */\nFez.instances = new Map()\n\n/**\n * Find a component instance from a DOM node\n * @param {Node|string} onode - DOM node or selector\n * @param {string} [name] - Optional component name filter\n * @returns {FezBase|undefined}\n */\nFez.find = (onode, name) => {\n  let node = typeof onode === 'string' ? document.body.querySelector(onode) : onode\n\n  // jQuery compatibility\n  if (typeof node.val === 'function') node = node[0]\n\n  const selector = name ? `.fez.fez-${name}` : '.fez'\n  const closestNode = node.closest(selector)\n\n  if (closestNode?.fez) return closestNode.fez\n\n  Fez.onError('find', 'Node connector not found', { original: onode, resolved: node })\n}\n\n/** Print registered components */\nFez.info = () => console.log('Fez components:', Object.keys(Fez.classes || {}))\n\n// =============================================================================\n// CSS UTILITIES\n// =============================================================================\n\n/**\n * Generate unique CSS class from CSS text (via Goober)\n * @param {string} text - CSS rules\n * @returns {string} Generated class name\n */\nFez.cssClass = (text) => Gobber.css(text)\n\n/**\n * Register global CSS styles\n * @param {string|Function} cssClass - CSS text or function\n * @param {Object} opts - { name, wrap }\n * @returns {string} Generated class name\n */\nFez.globalCss = (cssClass, opts = {}) => {\n  if (typeof cssClass === 'function') cssClass = cssClass()\n\n  if (cssClass.includes(':')) {\n    let text = cssClass\n      .split(\"\\n\")\n      .filter(line => !(/^\\s*\\/\\//.test(line)))\n      .join(\"\\n\")\n\n    if (opts.wrap) text = `:fez { ${text} }`\n    text = text.replace(/\\:fez|\\:host/, `.fez.fez-${opts.name}`)\n    cssClass = Fez.cssClass(text)\n  }\n\n  Fez.onReady(() => document.body.parentElement.classList.add(cssClass))\n  return cssClass\n}\n\n// =============================================================================\n// DOM MORPHING\n// =============================================================================\n\n/**\n * Morph DOM node to new state (via Idiomorph)\n * @param {Element} target - Element to morph\n * @param {Element} newNode - New state\n */\nFez.morphdom = (target, newNode) => {\n  // Preserve attributes\n  Array.from(target.attributes).forEach(attr => {\n    newNode.setAttribute(attr.name, attr.value)\n  })\n\n  Idiomorph.morph(target, newNode, { morphStyle: 'outerHTML' })\n\n  // Clean up whitespace\n  const next = target.nextSibling\n  if (next?.nodeType === Node.TEXT_NODE && !next.textContent.trim()) {\n    next.remove()\n  }\n}\n\n// =============================================================================\n// PUB/SUB SYSTEM\n// =============================================================================\n\nFez._globalSubs = new Map()\nFez._subs = {}\n\n/**\n * Publish event to all subscribers\n * @param {string} channel - Event name\n * @param {...any} args - Event arguments\n */\nFez.publish = (channel, ...args) => {\n  // Legacy subscriptions\n  Fez._subs[channel]?.forEach(el => el[1].bind(el[0])(...args))\n\n  // Global subscriptions\n  const subs = Fez._globalSubs.get(channel)\n  if (subs) {\n    subs.forEach(sub => {\n      if (sub.node?.isConnected) {\n        sub.callback.call(sub.node, ...args)\n      } else {\n        subs.delete(sub)\n      }\n    })\n  }\n}\n\n/**\n * Subscribe to events\n * @param {Node|string} node - DOM node or event name\n * @param {string|Function} eventName - Event name or callback\n * @param {Function} [callback] - Handler\n * @returns {Function} Unsubscribe function\n */\nFez.subscribe = (node, eventName, callback) => {\n  // Normalize arguments\n  if (typeof eventName === 'function') {\n    callback = eventName\n    eventName = node\n    node = document.body\n  }\n  if (typeof node === 'string') {\n    node = document.querySelector(node)\n  }\n\n  if (!Fez._globalSubs.has(eventName)) {\n    Fez._globalSubs.set(eventName, new Set())\n  }\n\n  const subs = Fez._globalSubs.get(eventName)\n\n  // Remove duplicate\n  subs.forEach(sub => {\n    if (sub.node === node && sub.callback === callback) subs.delete(sub)\n  })\n\n  const subscription = { node, callback }\n  subs.add(subscription)\n\n  return () => subs.delete(subscription)\n}\n\n// =============================================================================\n// TEMPORARY STORE\n// =============================================================================\n\n/** Store for passing values through DOM (e.g., loop vars to child components) */\nFez.store = {\n  _data: new Map(),\n  _counter: 0,\n\n  set(value) {\n    const key = this._counter++\n    this._data.set(key, value)\n    return key\n  },\n\n  get(key) {\n    return this._data.get(key)\n  },\n\n  delete(key) {\n    const value = this._data.get(key)\n    this._data.delete(key)\n    return value\n  }\n}\n\n// =============================================================================\n// ERROR HANDLING & LOGGING\n// =============================================================================\n\nFez.consoleError = (text, show) => {\n  text = `Fez: ${text}`\n  console.error(text)\n  if (show) {\n    return `<span style=\"border: 1px solid red; font-size: 14px; padding: 3px 7px; background: #fee; border-radius: 4px;\">${text}</span>`\n  }\n}\n\nFez.consoleLog = (text) => {\n  if (Fez.LOG) {\n    console.log(`Fez: ${String(text).substring(0, 180)}`)\n  }\n}\n\n/** Error handler - can be overridden */\nFez.onError = (kind, message, context) => {\n  const errorMsg = `Fez ${kind}: ${message?.toString?.() || message}`\n  console.error(errorMsg, context || '')\n  return errorMsg\n}\n\n// =============================================================================\n// LOAD UTILITIES & EXPORTS\n// =============================================================================\n\nimport addUtilities from './utility.js'\nimport cssMixin from './utils/css_mixin.js'\n\naddUtilities(Fez)\ncssMixin(Fez)\n\nFez.compile = compile\nFez.state = state\nFez.log = objectDump\nFez.highlightAll = highlightAll\n\nFez.onReady(() => Fez.consoleLog('Fez.LOG === true, logging enabled.'))\n\nexport default Fez\n", "/**\n * Fez - Runtime Custom DOM Elements Library\n *\n * Entry point that:\n * - Exports FezBase and Fez\n * - Sets up auto-compilation observer\n * - Handles garbage collection\n */\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nimport FezBase from './fez/instance.js'\nimport Fez from './fez/root.js'\n\n// Expose to window\nif (typeof window !== 'undefined') {\n  window.FezBase = FezBase\n  window.Fez = Fez\n}\n\n// Load default components\nimport('./fez/defaults.js')\n\n// =============================================================================\n// AUTO-COMPILATION OBSERVER\n// =============================================================================\n\n// Watch for template/xmp/script[fez] elements and compile them\nconst observer = new MutationObserver(mutations => {\n  for (const { addedNodes, removedNodes } of mutations) {\n    // Compile new fez templates\n    addedNodes.forEach(node => {\n      if (node.nodeType !== 1) return\n\n      if (node.matches?.('template[fez], xmp[fez], script[fez]')) {\n        Fez.compile(node)\n        node.remove()\n      }\n\n      node.querySelectorAll?.('template[fez], xmp[fez], script[fez]').forEach(tpl => {\n        Fez.compile(tpl)\n        tpl.remove()\n      })\n    })\n\n    // Cleanup removed components\n    removedNodes.forEach(node => {\n      if (node.nodeType !== 1) return\n\n      // Helper to cleanup a single element\n      const cleanup = (el) => {\n        if (el.fez) {\n          Fez.instances.delete(el.fez.UID)\n          el.fez.fezOnDestroy()\n        }\n      }\n\n      // Check if removed node itself is a fez component\n      cleanup(node)\n\n      // Check all children for fez components\n      node.querySelectorAll?.('.fez')?.forEach(cleanup)\n    })\n  }\n})\n\nobserver.observe(document.documentElement, {\n  childList: true,\n  subtree: true\n})\n\n// =============================================================================\n// MODULE EXPORTS\n// =============================================================================\n\nexport default Fez\nexport { Fez, FezBase }\n"],
  "mappings": "uIAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,kBAAAE,KAAA,IACMA,GADNC,GAAAC,GAAA,KACMF,GAAe,IAAM,CAGzB,IAAI,gBAAiB,KAAM,CACzB,KAAKG,EAAO,CACV,IAAMC,EAAM,SAAS,cAAcD,EAAM,IAAI,EAG7C,IAFAC,EAAI,MAAQD,EAAM,OAASA,EAAM,YAAY,GAAKA,EAE3C,KAAK,KAAK,YACf,KAAK,KAAK,WAAW,aAAa,KAAK,KAAK,UAAWC,EAAI,WAAW,EAGxE,KAAK,KAAK,UAAY,GACtB,KAAK,KAAK,YAAYA,CAAG,CAC3B,CACF,CAAC,EAID,IAAI,cAAe,KAAM,CACvB,KAAKD,EAAO,CACV,IAAI,MAAMA,EAAM,IAAME,GAAO,CAC3B,IAAMC,EAAM,IAAI,QAAQD,CAAI,EAC5B,IAAI,KAAKC,CAAG,EACZ,KAAK,KAAK,UAAYA,EAAI,SAC5B,CAAC,CACH,CACF,CAAC,EAOD,IAAI,aAAc,KAAM,CACtB,KAAKH,EAAO,CAEVA,EAAM,UAAU,IAAM,IAAI,GAC1B,IAAI,UAAU,IAAM,CAClB,GAAIA,EAAM,UAAU,EAAE,EACpB,YAAK,QAAQ,EACN,EAEX,EAAG,GAAG,CACR,CAEA,SAAU,CACR,IAAMI,EAAO,KAAK,KAAK,UAEvB,GAAIA,EAAM,CAER,IAAMC,EAAW,UADJ,IAAI,KAAK,KAAK,KAAK,SAAS,CACV,GAC/B,IAAIA,EAAU,KAAM,CAClB,KAAOD,EACP,MAAO,CACL,OAAO,OAAO,KAAK,MAAO,KAAK,MAAM,OAAS,CAAC,CAAC,CAClD,CACF,CAAC,EAED,IAAME,EAAK,SAAS,cAAcD,CAAQ,EAC1C,KAAK,KAAK,MAAM,KAAK,KAAK,UAAWC,CAAE,EACvC,KAAK,KAAK,OAAO,CACnB,CACF,CACF,CAAC,EAID,IAAI,SAAU,KAAM,CAClB,KAAKN,EAAO,CACG,IAAI,SAAS,WAAWA,EAAM,IAAMA,EAAM,IAAI,GAAG,EACpD,GACR,KAAK,KAAK,OAAO,CAErB,CACF,CAAC,EAGD,IAAMO,EAAY,IAAI,IAChBC,EAAsB,GAG5B,IAAI,eAAiB,IAAM,CACzBD,EAAU,MAAM,EAChB,IAAI,WAAW,uBAAuB,CACxC,EAIA,IAAI,cAAe,KAAM,CACvB,KAAKP,EAAO,CACV,GAAI,CAACA,EAAM,IAAK,CACd,IAAI,aAAa,mCAAmC,EACpD,MACF,CAEA,GAAIO,EAAU,IAAIP,EAAM,GAAG,EAAG,CAE5B,IAAMS,EAAaF,EAAU,IAAIP,EAAM,GAAG,EAC1C,IAAI,WAAW,mBAAmBA,EAAM,GAAG,aAAa,EACxD,KAAK,KAAK,UAAY,GACtB,KAAK,KAAK,YAAYS,EAAW,UAAU,EAAI,CAAC,CAClD,CACF,CAEA,QAAQT,EAAO,CAERO,EAAU,IAAIP,EAAM,GAAG,GAC1B,sBAAsB,IAAM,CAE1B,GAAIO,EAAU,MAAQC,EAAqB,CACzC,IAAME,EAAYH,EAAU,KAAK,EAAE,KAAK,EAAE,MAC1CA,EAAU,OAAOG,CAAS,EAC1B,IAAI,WAAW,kCAAkCA,CAAS,GAAG,CAC/D,CAGA,IAAMC,EAAc,SAAS,cAAc,KAAK,EAChDA,EAAY,UAAY,KAAK,KAAK,UAClC,IAAI,WAAW,mBAAmBX,EAAM,GAAG,SAAS,EACpDO,EAAU,IAAIP,EAAM,IAAKW,CAAW,CACtC,CAAC,CAEL,CACF,CAAC,CACH,EAGI,OAAO,IAAQ,KAAe,KAChCd,GAAa,IC1HA,SAARe,EAAmBC,EAAMC,EAAQ,CAAC,EAAGC,EAAM,CAqBhD,GApBI,OAAOD,GAAU,WACnB,CAACA,EAAOC,CAAI,EAAI,CAACA,EAAMD,CAAK,EAC5BA,IAAU,CAAC,GAGTA,aAAiB,OACnBC,EAAOD,EACPA,EAAQ,CAAC,GAGP,MAAM,QAAQD,CAAI,IACpBE,EAAOF,EACPA,EAAO,QAGL,OAAOC,GAAU,UAAY,MAAM,QAAQA,CAAK,KAClDC,EAAOD,EACPA,EAAQ,CAAC,GAGPD,EAAK,SAAS,GAAG,EAAG,CACtB,IAAMG,EAAQH,EAAK,MAAM,GAAG,EAC5BA,EAAOG,EAAM,MAAM,GAAK,MACxB,IAAMC,EAAID,EAAM,KAAK,GAAG,EACpBF,EAAM,MACRA,EAAM,OAAS,IAAIG,CAAC,GAEpBH,EAAM,MAAQG,CAElB,CAEA,IAAMC,EAAO,SAAS,cAAcL,CAAI,EAExC,OAAW,CAACM,EAAGC,CAAC,IAAK,OAAO,QAAQN,CAAK,EACvC,GAAI,OAAOM,GAAM,WACfF,EAAKC,CAAC,EAAIC,EAAE,KAAK,IAAI,MAChB,CACL,IAAMC,EAAQ,OAAOD,CAAC,EAAE,WAAW,OAAQ,KAAK,WAAW,EAC3DF,EAAK,aAAaC,EAAGE,CAAK,CAC5B,CAGF,GAAIN,EACF,GAAI,MAAM,QAAQA,CAAI,EACpB,QAAW,KAAKA,EACdG,EAAK,YAAY,CAAC,OAEXH,aAAgB,KACzBG,EAAK,YAAYH,CAAI,EAErBG,EAAK,UAAY,OAAOH,CAAI,EAIhC,OAAOG,CACT,CC9CA,SAASI,EAAiBC,EAAS,CAGjC,GAFuBA,EAAQ,WAAW,GAAG,EAEzB,CAClB,IAAMC,EAAQD,EAAQ,MAAM,iCAAiC,EAC7D,GAAIC,EACF,MAAO,CACL,OAAQA,EAAM,CAAC,EAAE,MAAM,GAAG,EAAE,IAAIC,GAAKA,EAAE,KAAK,CAAC,EAC7C,WAAYD,EAAM,CAAC,GAAK,KACxB,eAAgB,EAClB,CAEJ,CAGA,MAAO,CAAE,OADKD,EAAQ,MAAM,GAAG,EAAE,IAAI,GAAK,EAAE,KAAK,CAAC,EAC1B,WAAY,KAAM,eAAgB,EAAM,CAClE,CAKA,SAASG,GAAgBH,EAAS,CAChC,IAAMI,EAASL,EAAiBC,CAAO,EACjCK,EAAQ,CAAC,GAAGD,EAAO,MAAM,EAC/B,OAAIA,EAAO,YAAYC,EAAM,KAAKD,EAAO,UAAU,EAE/CA,EAAO,OAAO,SAAW,GAAK,CAACC,EAAM,SAAS,GAAG,GAAGA,EAAM,KAAK,GAAG,EAC/DA,CACT,CAKA,SAASC,GAAoBC,EAAYP,EAAS,CAChD,IAAMI,EAASL,EAAiBC,CAAO,EAGvC,OAF0BI,EAAO,gBAAkBA,EAAO,OAAO,QAAU,EAGlE,iFAAiFG,CAAU,IAE7F,IAAIA,CAAU,OACvB,CAKA,SAASC,GAAgBR,EAAS,CAChC,IAAMI,EAASL,EAAiBC,CAAO,EAEvC,GAAII,EAAO,eAAgB,CACzB,IAAMK,EAAc,IAAML,EAAO,OAAO,KAAK,IAAI,EAAI,IAC/CM,EAAYN,EAAO,aAAeA,EAAO,OAAO,SAAS,GAAG,EAAI,KAAO,KAC7E,OAAOK,EAAc,KAAOC,CAC9B,CAEA,GAAIN,EAAO,OAAO,QAAU,EAAG,CAC7B,IAAMO,EAAS,CAAC,GAAGP,EAAO,MAAM,EAC1BQ,EAAQD,EAAO,IAAI,EACzB,MAAO,IAAMA,EAAO,KAAK,IAAI,EAAI,MAAQC,CAC3C,CAEA,GAAIR,EAAO,OAAO,SAAW,EAC3B,OAAOA,EAAO,OAAO,KAAK,IAAI,EAIhC,IAAMM,EAAYN,EAAO,OAAO,CAAC,IAAM,IAAM,KAAO,IACpD,OAAOA,EAAO,OAAO,CAAC,EAAI,KAAOM,CACnC,CAKA,SAASG,GAAgBC,EAAM,CAE7B,MAAO,gDAAgD,KAAKA,CAAI,CAClE,CAOA,SAASC,GAAwBD,EAAME,EAAW,CAAC,EAAG,CAEpD,IAAMC,EAAaH,EAAK,MAAM,0DAA0D,EACxF,GAAI,CAACG,EAAY,OAAOH,EAExB,IAAII,EAAOD,EAAW,CAAC,EAAE,KAAK,EAIxBE,EADaL,EAAK,MAAM,gEAAgE,IAC9D,CAAC,EAIjC,GAHsBK,GAAc,CAAC,IAAK,QAAS,IAAI,EAAE,SAASA,CAAU,GAGvDA,IAAe,QAAS,CAE3C,IAAMC,EAAa,IAAI,OAAO,MAAMD,CAAU,MAAO,GAAG,EACxDD,EAAOA,EAAK,QAAQE,EAAY,OAAO,CACzC,CAIA,QAAWC,KAAWL,EAAU,CAG9B,IAAMM,EAAW,IAAI,OAAO,iBAAiBD,CAAO,kBAAmB,GAAG,EAC1EH,EAAOA,EAAK,QAAQI,EAAU,MAAMD,CAAO,GAAG,CAChD,CAMA,OAAAH,EAAOA,EAAK,QAAQ,6CAA8C,CAACjB,EAAOsB,IAExD,CAAC,UAAW,SAAU,WAAY,OAAQ,OAAQ,OAAQ,QAAS,SAAU,SAAU,SAAU,UAAW,WAAY,aAAc,aAAc,cAAe,eAAgB,gBAAiB,QAAS,UAAW,SAAU,QAAS,OAAO,EACtP,SAASA,CAAQ,EACpBtB,EAEF,OAAOsB,CAAQ,GACvB,EAEML,CACT,CAKA,SAASM,GAAwBC,EAAMC,EAAY,CACjD,IAAIC,EAAQ,EACRC,EAAIF,EAER,KAAOE,EAAIH,EAAK,QAAQ,CACtB,IAAMI,EAAOJ,EAAKG,CAAC,EACnB,GAAIC,IAAS,IACXF,YACSE,IAAS,KAElB,GADAF,IACIA,IAAU,EACZ,MAAO,CAAE,WAAYF,EAAK,MAAMC,EAAa,EAAGE,CAAC,EAAG,SAAUA,CAAE,UAEzDC,IAAS,KAAOA,IAAS,KAAOA,IAAS,IAAK,CAEvD,IAAMC,EAAQD,EAEd,IADAD,IACOA,EAAIH,EAAK,QAAUA,EAAKG,CAAC,IAAME,GAChCL,EAAKG,CAAC,IAAM,MAAMA,IACtBA,GAEJ,CACAA,GACF,CACA,MAAM,IAAI,MAAM,sBAAsBF,CAAU,EAAE,CACpD,CAMA,SAASK,GAAoBN,EAAMO,EAAK,CAGtC,IAAIC,EAAID,EAAM,EAEd,KAAOC,GAAK,IAAMR,EAAKQ,CAAC,IAAM,KAAOR,EAAKQ,CAAC,IAAM,KAAOR,EAAKQ,CAAC,IAAM,MAAOA,IAC3E,GAAIA,GAAK,GAAKR,EAAKQ,CAAC,IAAM,IAAK,CAG7B,IADAA,IACOA,GAAK,IAAMR,EAAKQ,CAAC,IAAM,KAAOR,EAAKQ,CAAC,IAAM,MAAOA,IAExD,IAAIC,EAAUD,EAAI,EAClB,KAAOA,GAAK,GAAK,iBAAiB,KAAKR,EAAKQ,CAAC,CAAC,GAAGA,IACjD,IAAME,EAAWV,EAAK,MAAMQ,EAAI,EAAGC,CAAO,EAC1C,GAAIC,GAAY,YAAY,KAAKA,CAAQ,EACvC,OAAOA,EAAS,YAAY,CAEhC,CACA,OAAO,IACT,CAMA,SAASC,GAAyBX,EAAMO,EAAK,CAC3C,IAAMK,EAAON,GAAoBN,EAAMO,CAAG,EAC1C,OAAIK,GAAQ,aAAa,KAAKA,CAAI,EACzBA,EAEF,IACT,CAKe,SAARC,EAAsCb,EAAMc,EAAO,CAAC,EAAG,CAC5D,IAAMC,EAAgBD,EAAK,MAAQ,UAEnC,GAAI,CAEFd,EAAOA,EACJ,WAAW,SAAU,GAAG,EACxB,WAAW,OAAQ,GAAG,EACtB,WAAW,OAAQ,GAAG,EACtB,WAAW,QAAS,GAAG,EAG1B,IAAMgB,EAAS,CAAC,EAChBhB,EAAOA,EAAK,QAAQ,2CAA4C,CAACiB,EAAGC,EAAMC,KACxEH,EAAOE,CAAI,EAAIC,EACR,GACR,EACDnB,EAAOA,EAAK,QAAQ,oBAAqB,CAACiB,EAAGC,IAASF,EAAOE,CAAI,GAAK,EAAE,EAKxElB,EAAOA,EAAK,QAAQ,sBAAuB,CAACxB,EAAOoC,EAAMvB,IAEnD,cAAc,KAAKA,EAAK,KAAK,CAAC,EACzB,IAAIuB,CAAI,yCAAyCvB,CAAI,SAEvDb,CACR,EAGDwB,EAAOA,EAAK,QAAQ,mBAAoB,EAAE,EAG1CA,EAAOA,EAAK,QAAQ,SAAU,IAAI,EAAE,KAAK,EAKzCA,EAAOA,EAAK,QAAQ,+CAAgD,aAAa,EAGjFA,EAAOA,EAAK,QAAQ,gBAAiB,eAAe,EAGpD,IAAIoB,EAAS,GACTjB,EAAI,EACFkB,EAAU,CAAC,EACXC,EAAe,CAAC,EAChBC,EAAY,CAAC,EAEnB,KAAOpB,EAAIH,EAAK,QAAQ,CAEtB,GAAIA,EAAKG,CAAC,IAAM,MAAQH,EAAKG,EAAI,CAAC,IAAM,IAAK,CAC3CiB,GAAU,IACVjB,GAAK,EACL,QACF,CAGA,GAAIH,EAAKG,CAAC,IAAM,IAAK,CACnB,GAAM,CAAE,WAAAqB,EAAY,SAAAC,CAAS,EAAI1B,GAAwBC,EAAMG,CAAC,EAC1Dd,EAAOmC,EAAW,KAAK,EAG7B,GAAInC,EAAK,WAAW,MAAM,EAAG,CAC3B,IAAMqC,EAAOrC,EAAK,MAAM,CAAC,EACzB+B,GAAU,MAAQM,EAAO,QACzBL,EAAQ,KAAK,EAAK,CACpB,SACShC,EAAK,WAAW,UAAU,EAAG,CACpC,IAAMqC,EAAOrC,EAAK,MAAM,CAAC,EACzB+B,GAAU,OAASM,EAAO,QAC1BL,EAAQ,KAAK,EAAK,CACpB,SACShC,IAAS,QAEhB,GAAIkC,EAAU,OAAS,GAAK,CAACF,EAAQ,OAAQ,CAE3C,IAAMM,EAAWJ,EAAUA,EAAU,OAAS,CAAC,EAC/CI,EAAS,QAAU,GACnBP,GAAU,iBACZ,MAEEA,GAAU,QACVC,EAAQA,EAAQ,OAAS,CAAC,EAAI,WAGzBhC,EAAK,WAAW,WAAW,EAAG,CACrC,IAAMqC,EAAOrC,EAAK,MAAM,CAAC,EACzB+B,GAAU,QAAUM,EAAO,OAE7B,SACSrC,IAAS,OAASA,IAAS,UAAW,CAC7C,IAAMuC,EAAUP,EAAQ,IAAI,EAC5BD,GAAUQ,EAAU,KAAO,SAC7B,SACSvC,EAAK,WAAW,QAAQ,GAAKA,EAAK,WAAW,OAAO,EAAG,CAC9D,IAAMwC,EAASxC,EAAK,WAAW,QAAQ,EACnCP,EAAYP,EAEhB,GAAIsD,EAAQ,CACV,IAAMC,EAAOzC,EAAK,MAAM,CAAC,EACnB0C,EAAQD,EAAK,QAAQ,MAAM,EACjChD,EAAagD,EAAK,MAAM,EAAGC,CAAK,EAAE,KAAK,EACvCxD,EAAUuD,EAAK,MAAMC,EAAQ,CAAC,EAAE,KAAK,CACvC,KAAO,CACL,IAAMD,EAAOzC,EAAK,MAAM,CAAC,EACnB2C,EAAQF,EAAK,QAAQ,MAAM,EACjCvD,EAAUuD,EAAK,MAAM,EAAGE,CAAK,EAAE,KAAK,EACpClD,EAAagD,EAAK,MAAME,EAAQ,CAAC,EAAE,KAAK,CAC1C,CAEA,IAAMC,EAAiBpD,GAAoBC,EAAYP,CAAO,EACxD2D,EAAanD,GAAgBR,CAAO,EAG1C+C,EAAa,KAAK5C,GAAgBH,CAAO,CAAC,EAK1CgD,EAAU,KAAK,CAAE,eAAAU,EAAgB,QAAS,EAAM,CAAC,EAEjDb,GAAU,wCAA0Cc,EAAa,QACnE,SACS7C,IAAS,SAAWA,IAAS,OAAQ,CAC5CiC,EAAa,IAAI,EACjB,IAAMK,EAAWJ,EAAU,IAAI,EAC3BI,EAAS,QAEXP,GAAU,MAAQO,EAAS,eAAiB,KAG5CP,GAAU,qBAAuBO,EAAS,eAAiB,IAE/D,SACStC,EAAK,WAAW,QAAQ,EAAG,CAClC,IAAM8B,EAAU9B,EAAK,MAAM,CAAC,EAC5B+B,GAAU,KAAOD,EAAU,GAC7B,SACS9B,EAAK,WAAW,QAAQ,EAAG,CAClC,IAAM8B,EAAU9B,EAAK,MAAM,CAAC,EAC5B+B,GAAU,wDAA0DD,EAAU,sBAChF,SACS/B,GAAgBC,CAAI,EAG3B,GADkBsB,GAAyBX,EAAMG,CAAC,EACnC,CAEb,IAAMgC,EAAcb,EAAa,KAAK,EAClCc,EAAU9C,GAAwBD,EAAM8C,CAAW,EAEvDC,EAAUA,EAAQ,QAAQ,KAAM,QAAQ,EAExChB,GAAU,IAAMgB,EAAU,GAC5B,MAEEhB,GAAU,KAAO/B,EAAO,SAKNiB,GAAoBN,EAAMG,CAAC,EAG7CiB,GAAU,qBAAuB/B,EAAO,MAGxC+B,GAAU,oBAAsB/B,EAAO,KAI3Cc,EAAIsB,EAAW,EACf,QACF,CAGIzB,EAAKG,CAAC,IAAM,IACdiB,GAAU,MACDpB,EAAKG,CAAC,IAAM,KAAOH,EAAKG,EAAI,CAAC,IAAM,IAC5CiB,GAAU,MACDpB,EAAKG,CAAC,IAAM,KACrBiB,GAAU,OAEVA,GAAUpB,EAAKG,CAAC,EAElBA,GACF,CAGA,IAAMkC,EAAW;AAAA;AAAA;AAAA,mBAGFjB,CAAM;AAAA;AAAA,MAIfkB,EAAU,IAAI,SAASD,CAAQ,EAErC,OAAQE,GAAQ,CACd,GAAI,CACF,OAAOD,EAAQ,KAAKC,CAAG,EAAE,CAC3B,OAASC,EAAG,CACV,eAAQ,MAAM,yCAAyCD,EAAI,SAAWxB,CAAa,KAAMyB,EAAE,OAAO,EAClG,QAAQ,MAAM,mBAAoBpB,EAAO,UAAU,EAAG,GAAG,CAAC,EACnD,EACT,CACF,CACF,OAASoB,EAAG,CACV,eAAQ,MAAM,yCAAyCzB,CAAa,KAAMyB,EAAE,OAAO,EACnF,QAAQ,MAAM,YAAaxC,EAAK,UAAU,EAAG,GAAG,CAAC,EAC1C,IAAM,EACf,CACF,CC3ZA,IAAMyC,EAAQ,IAAI,IAaH,SAARC,EAAgCC,EAAMC,EAAO,CAAC,EAAG,CAEtD,GAAIH,EAAM,IAAIE,CAAI,EAChB,OAAOF,EAAM,IAAIE,CAAI,EAInBE,GAAgBF,CAAI,IACtBA,EAAOG,GAAoBH,EAAMC,EAAK,IAAI,GAI5C,IAAMG,EAAKC,EAAqBL,EAAMC,CAAI,EAC1C,OAAAH,EAAM,IAAIE,EAAMI,CAAE,EAEXA,CACT,CAgBA,SAASE,GAAgBC,EAAM,CAC7B,OAAQA,EAAK,SAAS,IAAI,GAAKA,EAAK,SAAS,IAAI,GACzCA,EAAK,SAAS,IAAI,GAAKA,EAAK,SAAS,IAAI,CACnD,CAcA,SAASC,GAAoBD,EAAME,EAAe,CAEhD,OAAAF,EAAOA,EAAK,WAAW,KAAM,IAAI,EAAE,WAAW,KAAM,IAAI,EAGxDA,EAAOA,EAAK,QAAQ,4BAA6B,aAAa,EAC9DA,EAAOA,EAAK,QAAQ,mBAAoB,UAAU,EAClDA,EAAOA,EAAK,QAAQ,8BAA+B,aAAa,EAGhEA,EAAOA,EAAK,QAAQ,wBAAyB,UAAU,EACvDA,EAAOA,EAAK,QAAQ,gBAAiB,OAAO,EAC5CA,EAAOA,EAAK,QAAQ,4BAA6B,cAAc,EAC/DA,EAAOA,EAAK,QAAQ,oBAAqB,WAAW,EACpDA,EAAOA,EAAK,QAAQ,kBAAmB,SAAS,EAGhDA,EAAOA,EAAK,QAAQ,yBAA0B,WAAW,EACzDA,EAAOA,EAAK,QAAQ,iBAAkB,QAAQ,EAC9CA,EAAOA,EAAK,QAAQ,0BAA2B,YAAY,EAC3DA,EAAOA,EAAK,QAAQ,kBAAmB,SAAS,EAGhDA,EAAOA,EAAK,QAAQ,kCAAmC,YAAY,EACnEA,EAAOA,EAAK,QAAQ,wBAAyB,YAAY,EAGzDA,EAAOA,EAAK,QAAQ,uBAAwB,MAAM,EAG9CE,GACF,QAAQ,KAAK,kBAAkBA,CAAa,4CAA4C,EAGnFF,CACT,CC1GA,IAAqBG,EAArB,KAA6B,CAM3B,OAAO,SAAW,MAMlB,OAAO,SAASC,EAAMC,EAAS,CAC7B,IAAIC,EAAQ,CAAC,EAGb,GAAIF,EAAK,MACP,OAAOA,EAAK,MAId,QAAWG,KAAQH,EAAK,WACtBE,EAAMC,EAAK,IAAI,EAAIA,EAAK,MAI1B,OAAW,CAACC,EAAKC,CAAG,IAAK,OAAO,QAAQH,CAAK,EAC3C,GAAI,CAAC,GAAG,EAAE,SAASE,EAAI,CAAC,CAAC,EAAG,CAC1B,OAAOF,EAAME,CAAG,EAChB,GAAI,CACF,IAAME,EAAS,IAAI,SAAS,WAAWD,CAAG,GAAG,EAAE,KAAKJ,CAAO,EAAE,EAC7DC,EAAME,EAAI,QAAQ,QAAS,EAAE,CAAC,EAAIE,CACpC,OAASC,EAAG,CACV,IAAI,QAAQ,OAAQ,IAAIP,EAAK,QAAQ,YAAY,CAAC,sBAAsBI,CAAG,KAAKC,CAAG,MAAME,EAAE,OAAO,EAAE,CACtG,CACF,CAIF,GAAIL,EAAM,YAAY,EAAG,CACvB,IAAIM,EAAON,EAAM,YAAY,EAC7B,GAAI,OAAOM,GAAQ,SACjB,OAAOA,EAEHA,EAAK,CAAC,GAAK,MACbA,EAAO,mBAAmBA,CAAI,GAEhC,GAAI,CACFN,EAAQ,KAAK,MAAMM,CAAI,CACzB,OAASD,EAAG,CACV,IAAI,QAAQ,QAAS,IAAIP,EAAK,QAAQ,YAAY,CAAC,iCAAiCO,EAAE,OAAO,EAAE,CACjG,CAEJ,SAESL,EAAM,oBAAoB,EAAG,CACpC,IAAMM,EAAOP,EAAQ,iBAAiB,YACtC,GAAIO,EACF,GAAI,CACFN,EAAQ,KAAK,MAAMM,CAAI,EACvBP,EAAQ,gBAAgB,OAAO,CACjC,OAASM,EAAG,CACV,IAAI,QAAQ,QAAS,IAAIP,EAAK,QAAQ,YAAY,CAAC,+BAA+BO,EAAE,OAAO,EAAE,CAC/F,CAEJ,CAEA,OAAOL,CACT,CAKA,OAAO,SAASF,EAAM,CACpB,IAAMS,EAAWT,EAAK,QAAQ,MAAM,GAAKA,EAAK,cAAc,MAAM,EAClE,GAAI,CAACS,EACH,WAAI,WAAW,8BAA8B,EACtC,CAAC,EAEV,IAAMC,EAAW,IAAI,SAASD,CAAQ,EAChCE,EAAa,CAAC,EACpB,OAAAD,EAAS,QAAQ,CAACE,EAAOR,IAAQ,CAC/BO,EAAWP,CAAG,EAAIQ,CACpB,CAAC,EACMD,CACT,CAMA,aAAc,CAAC,CAEf,EAAIE,EACJ,UAAY,CAAC,EAKb,SAASC,EAAMC,EAASC,EAAS,CAC/B,IAAMC,EAAO,KAAK,SAAW,KAAK,MAAM,SAAS,YAAY,GAAK,UAClE,OAAO,IAAI,QAAQH,EAAM,IAAIG,CAAI,KAAKF,CAAO,GAAIC,CAAO,CAC1D,CAKA,IAAI,aAAc,CAChB,MAAO,OAAO,KAAK,GAAG,IACxB,CAKA,IAAI,aAAc,CAChB,MAAO,CAAC,CAAC,KAAK,MAAM,WACtB,CAKA,KAAKC,EAAM,CACT,IAAIC,EAAI,KAAK,QAAQD,CAAI,GAAK,KAAK,MAAMA,CAAI,EAC7C,OAAI,OAAOC,GAAK,aACdA,EAAIA,EAAE,KAAK,KAAK,IAAI,GAEfA,CACT,CAMA,SAAU,CAAC,CACX,SAAU,CAAC,CACX,cAAe,CAAC,CAChB,aAAc,CAAC,CACf,WAAY,CAAC,CACb,eAAgB,CAAC,CACjB,qBAAsB,CAAC,CAKvB,cAAe,CAET,KAAK,aACT,KAAK,WAAa,GAGd,KAAK,sBACP,KAAK,oBAAoB,QAAQC,GAAY,CAC3C,GAAI,CACFA,EAAS,CACX,OAAS,EAAG,CACV,KAAK,SAAS,UAAW,4BAA6B,CAAC,CACzD,CACF,CAAC,EACD,KAAK,oBAAsB,CAAC,GAI9B,KAAK,UAAU,EACf,KAAK,UAAY,IAAM,CAAC,EAGpB,KAAK,OACP,KAAK,KAAK,IAAM,QAElB,KAAK,KAAO,OACd,CAKA,aAAaA,EAAU,CACrB,KAAK,oBAAsB,KAAK,qBAAuB,CAAC,EACxD,KAAK,oBAAoB,KAAKA,CAAQ,CACxC,CASA,aAAaC,EAAM,CACjB,IAAMC,EAAO,KAAK,YAAY,WAAW,IAAK,QAAQ,EACtD,OAAAD,EAAOA,EACJ,QAAQ,uBAAwB,KAAKC,CAAI,IAAI,EAC7C,QAAQ,SAAU,IAAI,EAClBD,EAAK,KAAK,CACnB,CAKA,YAAYE,EAAML,EAAM,CAClBA,GACF,KAAK,aAAe,CAAC,EACrB,KAAK,WAAWA,CAAI,IAAM,OAAO,sBAAsB,IAAM,CAC3DK,EAAK,KAAK,IAAI,EAAE,EAChB,KAAK,WAAWL,CAAI,EAAI,IAC1B,EAAGA,CAAI,GAEP,OAAO,sBAAsBK,EAAK,KAAK,IAAI,CAAC,CAEhD,CAKA,YAAa,CACX,KAAK,YAAY,IAAM,KAAK,UAAU,EAAG,SAAS,CACpD,CAKA,SAAU,CACR,KAAK,WAAW,CAClB,CAMA,UAAUC,EAAU,CAGlB,GAFAA,IAAa,MAAM,OAAO,YAEtB,CAACA,GAAY,CAAC,KAAK,KAAM,OAE7B,KAAK,aAAa,EAElB,IAAMC,EAAW,OAAO,KAAK,MAAM,UAAY,WAAa,KAAK,MAAM,SAAS,KAAK,IAAI,EAAI,KAAK,MAAM,SAClGvB,EAAU,SAAS,cAAcuB,GAAY,KAAK,EAEpDC,EACJ,GAAI,MAAM,QAAQF,CAAQ,EACpBA,EAAS,CAAC,YAAa,KACzBA,EAAS,QAAQV,GAAKZ,EAAQ,YAAYY,CAAC,CAAC,EAE5CY,EAAcF,EAAS,KAAK,EAAE,UAGzB,OAAOA,GAAY,SAAU,CACpC,IAAMN,EAAO,KAAK,MAAM,SAAS,YAAY,EAC7CQ,EAAcC,EAAeH,EAAU,CAAE,KAAAN,CAAK,CAAC,EAAE,IAAI,CACvD,MACS,OAAOM,GAAY,aAC1BE,EAAcF,EAAS,IAAI,GAGzBE,IACEA,aAAuB,kBAAoBA,aAAuB,KACpExB,EAAQ,YAAYwB,CAAW,GAE/BA,EAAcA,EAAY,QAAQ,qBAAsB,EAAE,EAC1DxB,EAAQ,UAAY,KAAK,aAAawB,CAAW,IAIrD,KAAK,YAAYxB,CAAO,EACxB,KAAK,eAAeA,CAAO,EAE3B,IAAI,SAAS,KAAK,KAAMA,CAAO,EAE/B,KAAK,qBAAqB,EAC1B,KAAK,YAAY,CACnB,CAKA,sBAAuB,CACrB,IAAM0B,EAAY,CAACV,EAAMK,IAAS,CAChC,KAAK,KAAK,iBAAiB,KAAKL,CAAI,GAAG,EAAE,QAAS,GAAM,CACtD,IAAIL,EAAQ,EAAE,aAAaK,CAAI,EAC/B,EAAE,gBAAgBA,CAAI,EAClBL,GACFU,EAAK,KAAK,IAAI,EAAEV,EAAO,CAAC,CAE5B,CAAC,CACH,EAGAe,EAAU,WAAY,CAACf,EAAOC,IAAM,CACjC,IAAI,SAAS,IAAK,QAAQD,CAAK,MAAM,EAAG,KAAK,IAAI,EAAEC,CAAC,CACvD,CAAC,EAGDc,EAAU,UAAW,CAACf,EAAOC,IAAM,CACjC,GAAID,EAAM,SAAS,IAAI,EACrB,IAAI,YAAYA,CAAK,EAAEC,CAAC,UAGpBD,EAAM,SAAS,GAAG,EACpB,IAAI,YAAYA,CAAK,EAAE,KAAKC,CAAC,EAAE,MAE5B,CACH,IAAMe,EAAS,KAAKhB,CAAK,EACrB,OAAOgB,GAAU,WACnBA,EAAOf,CAAC,EAER,KAAK,SAAS,UAAW,IAAID,CAAK,qBAAqB,CAE3D,CAEJ,CAAC,EAGDe,EAAU,YAAa,CAACf,EAAOC,IAAM,CACnC,IAAIgB,EAAUjB,EAAM,MAAM,KAAK,EAC3BkB,EAAYD,EAAQ,IAAI,EAC5BA,EAAQ,QAASE,GAAMlB,EAAE,UAAU,IAAIkB,CAAC,CAAC,EACrCD,GACF,WAAW,IAAM,CACfjB,EAAE,UAAU,IAAIiB,CAAS,CAC3B,EAAG,CAAC,CAER,CAAC,EAGDH,EAAU,WAAY,CAACP,EAAMP,IAAM,CACjC,GAAI,CAAC,QAAS,SAAU,UAAU,EAAE,SAASA,EAAE,QAAQ,EAAG,CACxD,IAAMD,EAAS,IAAI,SAAS,eAAeQ,CAAI,EAAE,EAAG,KAAK,IAAI,EAAE,EACzDY,EAAOnB,EAAE,KAAK,YAAY,GAAK,WAC/BoB,EAAY,CAAC,QAAQ,EAAE,SAASpB,EAAE,QAAQ,GAAKmB,EAAO,WAAa,UACzEnB,EAAE,aAAaoB,EAAW,GAAG,KAAK,WAAW,GAAGb,CAAI,WAAWY,EAAO,UAAY,OAAO,EAAE,EAC3F,KAAK,IAAInB,EAAGD,CAAK,CACnB,MACE,KAAK,SAAS,WAAY,eAAeQ,CAAI,QAAQP,EAAE,QAAQ,oCAAoC,CAEvG,CAAC,EAGD,KAAK,KAAK,iBAAiB,aAAa,EAAE,QAASA,GAAM,CACvD,IAAID,EAAQC,EAAE,aAAa,UAAU,EACjC,CAAC,OAAO,EAAE,SAASD,CAAK,EAC1BC,EAAE,gBAAgB,UAAU,EAE5BA,EAAE,aAAa,WAAY,MAAM,CAErC,CAAC,CACH,CAKA,YAAYZ,EAAS,CACnBA,EAAQ,iBAAiB,YAAY,EAAE,QAAQiC,GAAS,CACtD,IAAM9B,EAAM8B,EAAM,aAAa,UAAU,EACnCC,EAAS/B,IAAQ,gBAAkBA,EAAI,WAAW,OAAO,EAE3DgC,EACJ,GAAID,EAAQ,CAEV,IAAME,EAAa,KAAK,KAAK,iBAAiB,cAAcjC,CAAG,IAAI,EACnE,QAAWkC,KAAMD,EAAY,CAC3B,IAAIE,EAASD,EAAG,cACZE,EAAW,GACf,KAAOD,GAAUA,IAAW,KAAK,MAAM,CACrC,GAAIA,EAAO,UAAU,SAAS,KAAK,EAAG,CACpCC,EAAW,GACX,KACF,CACAD,EAASA,EAAO,aAClB,CACA,GAAI,CAACC,EAAU,CACbJ,EAAQE,EACR,KACF,CACF,CACF,MACEF,EAAQ,KAAK,KAAK,cAAc,cAAchC,CAAG,IAAI,EAGvD,GAAIgC,EACFF,EAAM,WAAW,aAAaE,EAAOF,CAAK,UACjCC,EACT,GAAID,EAAM,aAAa,MAAM,EAAG,CAC9B,KAAK,MAAQ,KACb,IAAMK,EAASL,EAAM,WACrB,MAAM,KAAK,KAAK,KAAK,UAAU,EAAE,QAAQO,GAAS,CAChDF,EAAO,aAAaE,EAAOP,CAAK,CAClC,CAAC,EACDA,EAAM,OAAO,CACf,MACmB,MAAM,KAAK,KAAK,KAAK,UAAU,EACvC,QAAQO,GAAS,CACxBP,EAAM,YAAYO,CAAK,CACzB,CAAC,CAGP,CAAC,CACH,CAKA,eAAexC,EAAS,CACtB,IAAMyC,EAAYzC,EAAQ,cAAc,yBAAyB,EACjE,GAAI,CAACyC,EAAW,OAEhB,KAAK,eAAiB,IAAI,IAE1B,IAAMC,EAAeD,EAAU,aAAa,aAAa,EACnDE,EAAa,KAAK,aAAa,IAAID,CAAY,EAErD,GAAIC,EACF,IAAI,WAAW,mBAAmB,KAAK,OAAO,KAAKD,CAAY,EAAE,EACjED,EAAU,WAAW,aAAaE,EAAW,UAAU,EAAI,EAAGF,CAAS,MAClE,CACL,IAAMG,EAAY,KAAK,KAAK,cAAc,yBAAyB,EACnE,GAAIA,EAAW,CACb,IAAMC,EAAeD,EAAU,aAAa,aAAa,EACzD,KAAK,aAAa,IAAIC,EAAcD,EAAU,UAAU,EAAI,CAAC,CAC/D,CACF,CACF,CASA,aAAc,CACR,KAAK,MACP,KAAK,IAAM,IAAI,UAAU,KAAK,IAAK,CAAE,KAAM,KAAK,QAAS,KAAM,EAAK,CAAC,GAGnE,KAAK,MAAM,MACb,KAAK,MAAM,IAAM,IAAI,UAAU,KAAK,MAAM,IAAK,CAAE,KAAM,KAAK,OAAQ,CAAC,GAGvE,KAAK,QAAU,KAAK,iBAAiB,EACrC,KAAK,YAAc,IAAI,MAAM,YAAY,IAAI,EAC7C,KAAK,uBAAuB,CAC9B,CAKA,wBAAyB,CACP,OAAO,oBAAoB,OAAO,eAAe,IAAI,CAAC,EACnE,OAAOE,GAAUA,IAAW,eAAiB,OAAO,KAAKA,CAAM,GAAM,UAAU,EAC1E,QAAQA,GAAU,KAAKA,CAAM,EAAI,KAAKA,CAAM,EAAE,KAAK,IAAI,CAAC,CAClE,CAKA,iBAAiBC,EAAKC,EAAS,CAC7BD,IAAQ,CAAC,EAETC,IAAY,CAACC,EAAGC,EAAGjC,EAAGkC,IAAa,CAC7BlC,GAAKkC,IACP,KAAK,cAAcD,EAAGjC,EAAGkC,CAAQ,EACjC,KAAK,YAAY,KAAK,UAAW,WAAW,EAEhD,EAEAH,EAAQ,KAAK,IAAI,EAEjB,SAASI,EAAeL,EAAKC,EAAS,CACpC,OAAI,OAAOD,GAAQ,UAAYA,IAAQ,KAC9BA,EAGF,IAAI,MAAMA,EAAK,CACpB,IAAIpB,EAAQ0B,EAAU1C,EAAO2C,EAAU,CACrC,IAAMC,EAAe,QAAQ,IAAI5B,EAAQ0B,EAAUC,CAAQ,EAE3D,GAAIC,IAAiB5C,EAAO,CACtB,OAAOA,GAAU,UAAYA,IAAU,OACzCA,EAAQyC,EAAezC,EAAOqC,CAAO,GAGvC,IAAMQ,EAAS,QAAQ,IAAI7B,EAAQ0B,EAAU1C,EAAO2C,CAAQ,EAC5D,OAAAN,EAAQrB,EAAQ0B,EAAU1C,EAAO4C,CAAY,EACtCC,CACT,CAEA,MAAO,EACT,EACA,IAAI7B,EAAQ0B,EAAUC,EAAU,CAC9B,IAAM3C,EAAQ,QAAQ,IAAIgB,EAAQ0B,EAAUC,CAAQ,EACpD,OAAI,OAAO3C,GAAU,UAAYA,IAAU,KAClCyC,EAAezC,EAAOqC,CAAO,EAE/BrC,CACT,CACF,CAAC,CACH,CAEA,OAAOyC,EAAeL,EAAKC,CAAO,CACpC,CASA,KAAKS,EAAU,CACb,OAAO,OAAOA,GAAY,SAAW,KAAK,KAAK,cAAcA,CAAQ,EAAIA,CAC3E,CAKA,IAAIA,EAAUlD,EAAM,CAClB,IAAMR,EAAO,KAAK,KAAK0D,CAAQ,EAE/B,GAAI1D,EACF,GAAI,CAAC,QAAS,WAAY,QAAQ,EAAE,SAASA,EAAK,QAAQ,EACxD,GAAI,OAAOQ,EAAQ,IACbR,EAAK,MAAQ,WACfA,EAAK,QAAU,CAAC,CAACQ,EAEjBR,EAAK,MAAQQ,MAGf,QAAOR,EAAK,cAGV,OAAOQ,EAAQ,IACjBR,EAAK,UAAYQ,MAEjB,QAAOR,EAAK,SAIpB,CAKA,SAASA,EAAM,CACb,OAAO,KAAK,MAAM,SAASA,GAAQ,KAAK,IAAI,CAC9C,CAKA,KAAKiB,EAAML,EAAO,CAChB,OAAI,OAAOA,EAAU,IACZ,KAAK,KAAK,aAAaK,CAAI,GAElC,KAAK,KAAK,aAAaA,EAAML,CAAK,EAC3BA,EAEX,CAKA,WAAWU,EAAM,CACf,IAAIqC,EAAW,MAAM,KAAK,KAAK,KAAK,QAAQ,EAE5C,GAAIrC,EAAM,CACR,IAAMsC,EAAe,SAAS,cAAc,KAAK,EACjDA,EAAa,MAAM,QAAU,OAC7B,SAAS,KAAK,YAAYA,CAAY,EACtCD,EAAS,QAAQlB,GAASmB,EAAa,YAAYnB,CAAK,CAAC,EAEzDkB,EAAW,MAAM,KAAKC,EAAa,QAAQ,EAAE,IAAItC,CAAI,EACrD,SAAS,KAAK,YAAYsC,CAAY,CACxC,CAEA,OAAOD,CACT,CAKA,SAASvD,EAAKQ,EAAO,CACfR,GAAO,OAAOA,GAAO,SACvB,OAAO,QAAQA,CAAG,EAAE,QAAQ,CAAC,CAACyD,EAAMxD,CAAG,IAAM,CAC3C,KAAK,KAAK,MAAM,YAAYwD,EAAMxD,CAAG,CACvC,CAAC,EAED,KAAK,KAAK,MAAM,YAAYD,EAAKQ,CAAK,CAE1C,CAKA,MAAO,CACL,QAAWK,KAAQ,MAAM,KAAK,SAAS,EAAG,CACxC,IAAIL,EAAQ,KAAK,MAAMK,CAAI,EAE3B,GAAIL,IAAU,OAAW,CACvB,GAAIK,GAAQ,QAAS,CACnB,IAAM6C,EAAQ,KAAK,KAAK,aAAa7C,EAAML,CAAK,EAC5CkD,IACFlD,EAAQ,CAACkD,EAAOlD,CAAK,EAAE,KAAK,GAAG,EAEnC,CAEI,OAAOA,GAAS,SAClB,KAAK,KAAK,aAAaK,EAAML,CAAK,EAGlC,KAAK,KAAKK,CAAI,EAAIL,CAEtB,CACF,CACF,CAKA,QAAS,CACP,YAAK,KAAK,KAAO,OAAO,KAAK,GAAG,GACzB,KAAK,KAAK,EACnB,CAKA,SAASmD,EAAQ,CACXA,IACFA,EAAO,UAAU,IAAI,KAAK,EAC1BA,EAAO,UAAU,IAAI,OAAO,KAAK,OAAO,EAAE,EAC1CA,EAAO,IAAM,KACT,KAAK,KAAK,IAAI,GAAGA,EAAO,aAAa,KAAM,KAAK,KAAK,IAAI,CAAC,EAE9D,KAAK,KAAK,UAAY,GACtB,KAAK,KAAK,YAAYA,CAAM,GAG9B,IAAM/D,EAAO,KAAK,KACZgE,EAAQ,KAAK,WAAW,EACxBzB,EAAS,KAAK,KAAK,WAEzB,OAAAyB,EAAM,QAAQ,EAAE,QAAQ1B,GAAMC,EAAO,aAAaD,EAAItC,EAAK,WAAW,CAAC,EAEvE,KAAK,KAAK,OAAO,EACjB,KAAK,KAAO,OAER+D,IACF,KAAK,KAAOA,GAGPC,CACT,CASA,GAAG/B,EAAWX,EAAM2C,EAAQ,IAAK,CAC/B,KAAK,eAAiB,KAAK,gBAAkB,CAAC,EAE1C,KAAK,eAAehC,CAAS,GAC/B,OAAO,oBAAoBA,EAAW,KAAK,eAAeA,CAAS,CAAC,EAGtE,IAAMiC,EAAgB,IAAI,SAAS,IAAM,CACnC,KAAK,aAAa5C,EAAK,KAAK,IAAI,CACtC,EAAG2C,CAAK,EAER,KAAK,eAAehC,CAAS,EAAIiC,EACjC,OAAO,iBAAiBjC,EAAWiC,CAAa,EAEhD,KAAK,aAAa,IAAM,CACtB,OAAO,oBAAoBjC,EAAWiC,CAAa,EACnD,OAAO,KAAK,eAAejC,CAAS,CACtC,CAAC,CACH,CAKA,eAAeX,EAAM2C,EAAO,CAC1B,KAAK,GAAG,SAAU3C,EAAM2C,CAAK,EAC7B3C,EAAK,CACP,CAKA,eAAeA,EAAM2C,EAAO,CAC1B,KAAK,GAAG,SAAU3C,EAAM2C,CAAK,EAC7B3C,EAAK,CACP,CAKA,gBAAgBgB,EAAIhB,EAAM2C,EAAQ,IAAK,CACrC,IAAMC,EAAgB,IAAI,SAAS,IAAM,CACnC,KAAK,aAAa5C,EAAK,KAAK,KAAMgB,EAAG,sBAAsB,EAAGA,CAAE,CACtE,EAAG2B,CAAK,EAEFE,EAAW,IAAI,eAAeD,CAAa,EACjDC,EAAS,QAAQ7B,CAAE,EAEnBhB,EAAK,KAAK,KAAMgB,EAAG,sBAAsB,EAAGA,CAAE,EAE9C,KAAK,aAAa,IAAM,CACtB6B,EAAS,WAAW,CACtB,CAAC,CACH,CAKA,YAAY7C,EAAM8C,EAAMnD,EAAM,CACxB,OAAOK,GAAQ,WACjB,CAAC8C,EAAM9C,CAAI,EAAI,CAACA,EAAM8C,CAAI,GAG5BnD,IAAS,IAAI,KAAK,OAAOK,CAAI,CAAC,EAE9B,KAAK,oBAAsB,CAAC,EAC5B,cAAc,KAAK,kBAAkBL,CAAI,CAAC,EAE1C,IAAMoD,EAAa,YAAY,IAAM,CAC/B,KAAK,aAAa/C,EAAK,CAC7B,EAAG8C,CAAI,EAEP,YAAK,kBAAkBnD,CAAI,EAAIoD,EAE/B,KAAK,aAAa,IAAM,CACtB,cAAcA,CAAU,EACxB,OAAO,KAAK,kBAAkBpD,CAAI,CACpC,CAAC,EAEMoD,CACT,CASA,QAAQC,KAAYC,EAAM,CACxB,IAAMC,EAAkBC,GAAc,CACpC,GAAI,IAAI,OAAS,IAAI,MAAMH,CAAO,EAAG,CACnC,IAAMI,EAAM,IAAI,MAAMJ,CAAO,EAAE,KAAK,CAAC,CAACK,CAAI,IAAMA,IAASF,CAAS,EAClE,GAAIC,EACF,OAAAA,EAAI,CAAC,EAAE,KAAKD,CAAS,EAAE,GAAGF,CAAI,EACvB,EAEX,CACA,MAAO,EACT,EAGA,GAAIC,EAAe,IAAI,EACrB,MAAO,GAIT,IAAIjC,EAAS,KAAK,KAAK,cACvB,KAAOA,GAAQ,CACb,GAAIA,EAAO,KACLiC,EAAejC,EAAO,GAAG,EAC3B,MAAO,GAGXA,EAASA,EAAO,aAClB,CAEA,MAAO,EACT,CAKA,UAAU+B,EAAShD,EAAM,CACvB,IAAI,QAAU,CAAC,EACf,IAAI,MAAMgD,CAAO,IAAM,CAAC,EACxB,IAAI,MAAMA,CAAO,EAAI,IAAI,MAAMA,CAAO,EAAE,OAAQhC,GAAOA,EAAG,CAAC,EAAE,WAAW,EACxE,IAAI,MAAMgC,CAAO,EAAE,KAAK,CAAC,KAAMhD,CAAI,CAAC,CACtC,CASA,QAAQsD,EAAQhD,EAAQ,CACtBA,IAAW,SAAS,cAAc,UAAU,EAC5C,IAAMO,EAASP,EAAO,UAAY,OAElC,KAAOgD,EAAO,YACRzC,EACFP,EAAO,WAAW,aAAagD,EAAO,UAAWhD,EAAO,WAAW,EAEnEA,EAAO,YAAYgD,EAAO,UAAU,EAIxC,OAAIzC,EACFP,EAAO,WAAW,YAAYA,CAAM,EAEpCgD,EAAO,UAAY,GAGdhD,CACT,CACF,ECnzBA,IAAIiD,GAAE,CAAC,KAAK,EAAE,EAAEC,GAAE,GAAa,OAAO,QAAjB,WAA0B,EAAE,EAAE,cAAc,UAAU,EAAE,OAAO,UAAU,OAAO,QAAQ,GAAG,SAAS,MAAM,YAAY,SAAS,cAAc,OAAO,CAAC,EAAE,CAAC,UAAU,IAAI,GAAG,SAAS,CAAC,GAAG,WAAW,GAAGD,GAAEE,GAAEF,GAAG,CAAC,IAAIE,EAAED,GAAED,CAAC,EAAEG,EAAED,EAAE,KAAK,OAAOA,EAAE,KAAK,GAAGC,CAAC,EAAEA,GAAE,oEAAoEC,GAAE,qBAAqBC,GAAE,OAAOC,EAAE,CAACN,EAAEC,IAAI,CAAC,IAAIC,EAAE,GAAGC,EAAE,GAAGC,EAAE,GAAG,QAAQC,KAAKL,EAAE,CAAC,IAAIO,EAAEP,EAAEK,CAAC,EAAOA,EAAE,CAAC,GAAR,IAAeA,EAAE,CAAC,GAAR,IAAUH,EAAEG,EAAE,IAAIE,EAAE,IAAIJ,GAAQE,EAAE,CAAC,GAAR,IAAUC,EAAEC,EAAEF,CAAC,EAAEA,EAAE,IAAIC,EAAEC,EAAOF,EAAE,CAAC,GAAR,IAAU,GAAGJ,CAAC,EAAE,IAAc,OAAOM,GAAjB,SAAmBJ,GAAGG,EAAEC,EAAEN,EAAEA,EAAE,QAAQ,WAAYD,GAAGK,EAAE,QAAQ,kBAAmBJ,GAAG,IAAI,KAAKA,CAAC,EAAEA,EAAE,QAAQ,KAAKD,CAAC,EAAEA,EAAEA,EAAE,IAAIC,EAAEA,CAAE,CAAE,EAAEI,CAAC,EAAQE,GAAN,OAAUF,EAAE,MAAM,KAAKA,CAAC,EAAEA,EAAEA,EAAE,QAAQ,SAAS,KAAK,EAAE,YAAY,EAAED,GAAGE,EAAE,EAAEA,EAAE,EAAED,EAAEE,CAAC,EAAEF,EAAE,IAAIE,EAAE,IAAI,CAAC,OAAOL,GAAGD,GAAGG,EAAEH,EAAE,IAAIG,EAAE,IAAIA,GAAGD,CAAC,EAAEI,EAAE,CAAC,EAAEC,GAAER,GAAG,CAAC,GAAa,OAAOA,GAAjB,SAAmB,CAAC,IAAIC,EAAE,GAAG,QAAQC,KAAKF,EAAEC,GAAGC,EAAEM,GAAER,EAAEE,CAAC,CAAC,EAAE,OAAOD,CAAC,CAAC,OAAOD,CAAC,EAAES,GAAE,CAACT,EAAEC,EAAEC,EAAEO,EAAEC,IAAI,CAAC,IAAIC,EAAEH,GAAER,CAAC,EAAEY,EAAEL,EAAEI,CAAC,IAAIJ,EAAEI,CAAC,GAAGX,GAAG,CAAC,IAAIC,EAAE,EAAEC,EAAE,GAAG,KAAKD,EAAED,EAAE,QAAQE,EAAE,IAAIA,EAAEF,EAAE,WAAWC,GAAG,IAAI,EAAE,MAAM,KAAKC,CAAC,GAAGS,CAAC,GAAG,GAAG,CAACJ,EAAEK,CAAC,EAAE,CAAC,IAAIX,EAAEU,IAAIX,EAAEA,GAAGA,GAAG,CAAC,IAAIC,EAAEC,EAAEI,EAAE,CAAC,CAAC,CAAC,EAAE,KAAKL,EAAEE,GAAE,KAAKH,EAAE,QAAQI,GAAE,EAAE,CAAC,GAAGH,EAAE,CAAC,EAAEK,EAAE,MAAM,EAAEL,EAAE,CAAC,GAAGC,EAAED,EAAE,CAAC,EAAE,QAAQI,GAAE,GAAG,EAAE,KAAK,EAAEC,EAAE,QAAQA,EAAE,CAAC,EAAEJ,CAAC,EAAEI,EAAE,CAAC,EAAEJ,CAAC,GAAG,CAAC,CAAC,GAAGI,EAAE,CAAC,EAAEL,EAAE,CAAC,CAAC,EAAEA,EAAE,CAAC,EAAE,QAAQI,GAAE,GAAG,EAAE,KAAK,EAAE,OAAOC,EAAE,CAAC,CAAC,GAAGN,CAAC,EAAEO,EAAEK,CAAC,EAAEN,EAAEI,EAAE,CAAC,CAAC,cAAcE,CAAC,EAAEX,CAAC,EAAEA,EAAEC,EAAE,GAAG,IAAIU,CAAC,CAAC,CAAC,IAAI,EAAEV,GAAGK,EAAE,EAAEA,EAAE,EAAE,KAAK,OAAOL,IAAIK,EAAE,EAAEA,EAAEK,CAAC,IAAI,CAACZ,EAAEC,EAAEC,EAAEC,IAAI,CAACA,EAAEF,EAAE,KAAKA,EAAE,KAAK,QAAQE,EAAEH,CAAC,EAAOC,EAAE,KAAK,QAAQD,CAAC,IAArB,KAAyBC,EAAE,KAAKC,EAAEF,EAAEC,EAAE,KAAKA,EAAE,KAAKD,EAAE,GAAGO,EAAEK,CAAC,EAAEX,EAAEQ,EAAE,CAAC,EAAEG,CAAC,EAAEF,GAAE,CAACV,EAAEC,EAAEC,IAAIF,EAAE,OAAQ,CAACA,EAAEG,EAAEC,IAAI,CAAC,IAAIC,EAAEJ,EAAEG,CAAC,EAAE,GAAGC,GAAGA,EAAE,KAAK,CAAC,IAAIL,EAAEK,EAAEH,CAAC,EAAED,EAAED,GAAGA,EAAE,OAAOA,EAAE,MAAM,WAAW,MAAM,KAAKA,CAAC,GAAGA,EAAEK,EAAEJ,EAAE,IAAIA,EAAED,GAAa,OAAOA,GAAjB,SAAmBA,EAAE,MAAM,GAAGM,EAAEN,EAAE,EAAE,EAAOA,IAAL,GAAO,GAAGA,CAAC,CAAC,OAAOA,EAAEG,GAASE,GAAE,GAAK,EAAG,EAAE,EAAE,SAASM,EAAEX,EAAE,CAAC,IAAIE,EAAE,MAAM,CAAC,EAAEC,EAAEH,EAAE,KAAKA,EAAEE,EAAE,CAAC,EAAEF,EAAE,OAAOS,GAAEN,EAAE,QAAQA,EAAE,IAAIO,GAAEP,EAAE,CAAC,EAAE,MAAM,KAAK,UAAU,CAAC,EAAED,EAAE,CAAC,EAAEC,EAAE,OAAQ,CAACH,EAAEC,IAAI,OAAO,OAAOD,EAAEC,GAAGA,EAAE,KAAKA,EAAEC,EAAE,CAAC,EAAED,CAAC,EAAG,CAAC,CAAC,EAAEE,EAAEF,GAAEC,EAAE,MAAM,EAAEA,EAAE,EAAEA,EAAE,EAAEA,EAAE,CAAC,CAAC,CAAC,IAAIU,GAAEC,EAAEC,EAAEC,GAAEJ,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAAEK,GAAEL,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,SAASM,GAAEjB,EAAEC,EAAEC,EAAEC,EAAE,CAACG,EAAE,EAAEL,EAAEW,GAAEZ,EAAEa,EAAEX,EAAEY,EAAEX,CAAC,CAAC,SAASe,GAAElB,EAAEC,EAAE,CAAC,IAAIC,EAAE,MAAM,CAAC,EAAE,OAAO,UAAU,CAAC,IAAIC,EAAE,UAAU,SAASC,EAAEC,EAAEC,EAAE,CAAC,IAAIC,EAAE,OAAO,OAAO,CAAC,EAAEF,CAAC,EAAEG,EAAED,EAAE,WAAWH,EAAE,UAAUF,EAAE,EAAE,OAAO,OAAO,CAAC,MAAMW,GAAGA,EAAE,CAAC,EAAEN,CAAC,EAAEL,EAAE,EAAE,UAAU,KAAKM,CAAC,EAAED,EAAE,UAAUI,EAAE,MAAMT,EAAEC,CAAC,GAAGK,EAAE,IAAIA,EAAE,IAAIP,IAAIM,EAAE,IAAID,GAAG,IAAIG,EAAET,EAAE,OAAOA,EAAE,CAAC,IAAIS,EAAEF,EAAE,IAAIP,EAAE,OAAOO,EAAE,IAAIO,GAAGL,EAAE,CAAC,GAAGK,EAAEP,CAAC,EAAEK,GAAEH,EAAEF,CAAC,CAAC,CAAC,OAAON,EAAEA,EAAEG,CAAC,EAAEA,CAAC,CAAC,CACjqE,IAAOe,GAAQ,CAAE,IAAIR,EAAG,WAAYT,GAAG,KAAMa,GAAG,UAAWC,GAAG,MAAOC,GAAG,OAAQC,EAAE,ECNlF,IAAIE,GAAa,UAAY,CACrB,aAKA,IAAIC,EAAY,IAAI,IAGhBC,EAAW,CACX,WAAY,YACZ,UAAY,CACR,gBAAiBC,EACjB,eAAgBA,EAChB,kBAAmBA,EACnB,iBAAkBA,EAClB,kBAAmBA,EACnB,iBAAkBA,EAClB,uBAAwBA,CAE5B,EACA,KAAM,CACF,MAAO,QACP,eAAgB,SAAUC,EAAK,CAC3B,OAAOA,EAAI,aAAa,aAAa,IAAM,MAC/C,EACA,eAAgB,SAAUA,EAAK,CAC3B,OAAOA,EAAI,aAAa,cAAc,IAAM,MAChD,EACA,aAAcD,EACd,iBAAkBA,CACtB,CACJ,EAKA,SAASE,EAAMC,EAASC,EAAYC,EAAS,CAAC,EAAG,CAEzCF,aAAmB,WACnBA,EAAUA,EAAQ,iBAGlB,OAAOC,GAAe,WACtBA,EAAaE,GAAaF,CAAU,GAGxC,IAAIG,EAAoBC,GAAiBJ,CAAU,EAE/CK,EAAMC,EAAmBP,EAASI,EAAmBF,CAAM,EAE/D,OAAOM,EAAuBR,EAASI,EAAmBE,CAAG,CACjE,CAEA,SAASE,EAAuBR,EAASS,EAAsBH,EAAK,CAChE,GAAIA,EAAI,KAAK,MAAO,CAChB,IAAII,EAAUV,EAAQ,cAAc,MAAM,EACtCW,EAAUF,EAAqB,cAAc,MAAM,EACvD,GAAIC,GAAWC,EAAS,CACpB,IAAIC,EAAWC,EAAkBF,EAASD,EAASJ,CAAG,EAEtD,QAAQ,IAAIM,CAAQ,EAAE,KAAK,UAAY,CACnCJ,EAAuBR,EAASS,EAAsB,OAAO,OAAOH,EAAK,CACrE,KAAM,CACF,MAAO,GACP,OAAQ,EACZ,CACJ,CAAC,CAAC,CACN,CAAC,EACD,MACJ,CACJ,CAEA,GAAIA,EAAI,aAAe,YAGnB,OAAAQ,EAAcL,EAAsBT,EAASM,CAAG,EACzCN,EAAQ,SAEZ,GAAIM,EAAI,aAAe,aAAeA,EAAI,YAAc,KAAM,CAGjE,IAAIS,EAAYC,GAAkBP,EAAsBT,EAASM,CAAG,EAGhEW,EAAkBF,GAAW,gBAC7BG,EAAcH,GAAW,YAGzBI,EAAcC,EAAepB,EAASe,EAAWT,CAAG,EAExD,OAAIS,EAGOM,GAAeJ,EAAiBE,EAAaD,CAAW,EAGxD,CAAC,CAEhB,KACI,MAAM,wCAA0CZ,EAAI,UAE5D,CAQA,SAASgB,EAA2BC,EAAuBjB,EAAK,CAC5D,OAAOA,EAAI,mBAAqBiB,IAA0B,SAAS,eAAiBA,IAA0B,SAAS,IAC3H,CAQA,SAASH,EAAepB,EAASC,EAAYK,EAAK,CAC9C,GAAI,EAAAA,EAAI,cAAgBN,IAAY,SAAS,eAEtC,OAAIC,GAAc,KACjBK,EAAI,UAAU,kBAAkBN,CAAO,IAAM,GAAcA,GAE/DA,EAAQ,OAAO,EACfM,EAAI,UAAU,iBAAiBN,CAAO,EAC/B,MACCwB,EAAYxB,EAASC,CAAU,GASnCK,EAAI,UAAU,kBAAkBN,EAASC,CAAU,IAAM,KAEzDD,aAAmB,iBAAmBM,EAAI,KAAK,SAExCN,aAAmB,iBAAmBM,EAAI,KAAK,QAAU,QAChEO,EAAkBZ,EAAYD,EAASM,CAAG,GAE1CmB,EAAaxB,EAAYD,EAASM,CAAG,EAChCgB,EAA2BtB,EAASM,CAAG,GACxCQ,EAAcb,EAAYD,EAASM,CAAG,IAG9CA,EAAI,UAAU,iBAAiBN,EAASC,CAAU,GAC3CD,GArBHM,EAAI,UAAU,kBAAkBN,CAAO,IAAM,IAC7CM,EAAI,UAAU,gBAAgBL,CAAU,IAAM,GAAcD,GAEhEA,EAAQ,cAAc,aAAaC,EAAYD,CAAO,EACtDM,EAAI,UAAU,eAAeL,CAAU,EACvCK,EAAI,UAAU,iBAAiBN,CAAO,EAC/BC,EAiBf,CAwBA,SAASa,EAAcY,EAAWC,EAAWrB,EAAK,CAE9C,IAAIsB,EAAeF,EAAU,WACzBG,EAAiBF,EAAU,WAC3BG,EAGJ,KAAOF,GAAc,CAMjB,GAJAE,EAAWF,EACXA,EAAeE,EAAS,YAGpBD,GAAkB,KAAM,CACxB,GAAIvB,EAAI,UAAU,gBAAgBwB,CAAQ,IAAM,GAAO,OAEvDH,EAAU,YAAYG,CAAQ,EAC9BxB,EAAI,UAAU,eAAewB,CAAQ,EACrCC,EAA2BzB,EAAKwB,CAAQ,EACxC,QACJ,CAGA,GAAIE,EAAaF,EAAUD,EAAgBvB,CAAG,EAAG,CAC7Cc,EAAeS,EAAgBC,EAAUxB,CAAG,EAC5CuB,EAAiBA,EAAe,YAChCE,EAA2BzB,EAAKwB,CAAQ,EACxC,QACJ,CAGA,IAAIG,EAAaC,EAAeR,EAAWC,EAAWG,EAAUD,EAAgBvB,CAAG,EAGnF,GAAI2B,EAAY,CACZJ,EAAiBM,EAAmBN,EAAgBI,EAAY3B,CAAG,EACnEc,EAAea,EAAYH,EAAUxB,CAAG,EACxCyB,EAA2BzB,EAAKwB,CAAQ,EACxC,QACJ,CAGA,IAAIM,EAAYC,GAAcX,EAAWC,EAAWG,EAAUD,EAAgBvB,CAAG,EAGjF,GAAI8B,EAAW,CACXP,EAAiBM,EAAmBN,EAAgBO,EAAW9B,CAAG,EAClEc,EAAegB,EAAWN,EAAUxB,CAAG,EACvCyB,EAA2BzB,EAAKwB,CAAQ,EACxC,QACJ,CAIA,GAAIxB,EAAI,UAAU,gBAAgBwB,CAAQ,IAAM,GAAO,OAEvDH,EAAU,aAAaG,EAAUD,CAAc,EAC/CvB,EAAI,UAAU,eAAewB,CAAQ,EACrCC,EAA2BzB,EAAKwB,CAAQ,CAC5C,CAGA,KAAOD,IAAmB,MAAM,CAE5B,IAAIS,EAAWT,EACfA,EAAiBA,EAAe,YAChCU,GAAWD,EAAUhC,CAAG,CAC5B,CACJ,CAaA,SAASkC,EAAgBC,EAAMC,EAAIC,EAAYrC,EAAK,CAChD,OAAGmC,IAAS,SAAWnC,EAAI,mBAAqBoC,IAAO,SAAS,cACrD,GAEJpC,EAAI,UAAU,uBAAuBmC,EAAMC,EAAIC,CAAU,IAAM,EAC1E,CAUA,SAASlB,EAAamB,EAAMF,EAAIpC,EAAK,CACjC,IAAIuC,EAAOD,EAAK,SAIhB,GAAIC,IAAS,EAAsB,CAC/B,IAAMC,EAAiBF,EAAK,WACtBG,EAAeL,EAAG,WACxB,QAAWM,KAAiBF,EACxB,GAAI,CAAAN,EAAgBQ,EAAc,KAAMN,EAAI,SAAUpC,CAAG,EAIzD,GAAI,CACIoC,EAAG,aAAaM,EAAc,IAAI,IAAMA,EAAc,QAElDA,EAAc,OAAS,QACvBC,EAAcL,EAAMF,CAAE,EAEtBA,EAAG,aAAaM,EAAc,KAAMA,EAAc,KAAK,EAGnE,OAASE,EAAO,CAEZ,QAAQ,MAAM,2BAA4B,CACtC,QAASR,EACT,aAAcM,EACd,MAAOE,EAAM,OACjB,CAAC,CACL,CAGJ,QAASC,EAAIJ,EAAa,OAAS,EAAG,GAAKI,EAAGA,IAAK,CAC/C,IAAMC,EAAcL,EAAaI,CAAC,EAC9BX,EAAgBY,EAAY,KAAMV,EAAI,SAAUpC,CAAG,GAGlDsC,EAAK,aAAaQ,EAAY,IAAI,GACnCV,EAAG,gBAAgBU,EAAY,IAAI,CAE3C,CACJ,EAGIP,IAAS,GAAmBA,IAAS,IACjCH,EAAG,YAAcE,EAAK,YACtBF,EAAG,UAAYE,EAAK,WAIvBtB,EAA2BoB,EAAIpC,CAAG,GAEnC+C,EAAeT,EAAMF,EAAIpC,CAAG,CAEpC,CAOA,SAAS2C,EAAcL,EAAMF,EAAI,CAC7B,IAAMY,EAAc,IAAI,IAAIV,EAAK,UAAU,MAAM,KAAK,EAAE,OAAO,OAAO,CAAC,EACjEW,EAAY,IAAI,IAAIb,EAAG,UAAU,MAAM,KAAK,EAAE,OAAO,OAAO,CAAC,EAGnE,QAAWc,KAAOD,EACTD,EAAY,IAAIE,CAAG,GACpBd,EAAG,UAAU,OAAOc,CAAG,EAK/B,QAAWA,KAAOF,EACTC,EAAU,IAAIC,CAAG,GAClBd,EAAG,UAAU,IAAIc,CAAG,CAGhC,CAQA,SAASC,EAAqBb,EAAMF,EAAIgB,EAAepD,EAAK,CACxD,GAAIsC,EAAKc,CAAa,IAAMhB,EAAGgB,CAAa,EAAG,CAC3C,IAAIC,EAAenB,EAAgBkB,EAAehB,EAAI,SAAUpC,CAAG,EAC9DqD,IACDjB,EAAGgB,CAAa,EAAId,EAAKc,CAAa,GAEtCd,EAAKc,CAAa,EACbC,GACDjB,EAAG,aAAagB,EAAed,EAAKc,CAAa,CAAC,EAGjDlB,EAAgBkB,EAAehB,EAAI,SAAUpC,CAAG,GACjDoC,EAAG,gBAAgBgB,CAAa,CAG5C,CACJ,CAYA,SAASL,EAAeT,EAAMF,EAAIpC,EAAK,CACnC,GAAIsC,aAAgB,kBAChBF,aAAc,kBACdE,EAAK,OAAS,OAAQ,CAEtB,IAAIgB,EAAYhB,EAAK,MACjBiB,EAAUnB,EAAG,MAGjBe,EAAqBb,EAAMF,EAAI,UAAWpC,CAAG,EAC7CmD,EAAqBb,EAAMF,EAAI,WAAYpC,CAAG,EAEzCsC,EAAK,aAAa,OAAO,EAKnBgB,IAAcC,IAChBrB,EAAgB,QAASE,EAAI,SAAUpC,CAAG,IAC3CoC,EAAG,aAAa,QAASkB,CAAS,EAClClB,EAAG,MAAQkB,IAPVpB,EAAgB,QAASE,EAAI,SAAUpC,CAAG,IAC3CoC,EAAG,MAAQ,GACXA,EAAG,gBAAgB,OAAO,EAQtC,SAAWE,aAAgB,kBACvBa,EAAqBb,EAAMF,EAAI,WAAYpC,CAAG,UACvCsC,aAAgB,qBAAuBF,aAAc,oBAAqB,CACjF,IAAIkB,EAAYhB,EAAK,MACjBiB,EAAUnB,EAAG,MACjB,GAAIF,EAAgB,QAASE,EAAI,SAAUpC,CAAG,EAC1C,OAEAsD,IAAcC,IACdnB,EAAG,MAAQkB,GAEXlB,EAAG,YAAcA,EAAG,WAAW,YAAckB,IAC7ClB,EAAG,WAAW,UAAYkB,EAElC,CACJ,CAKA,SAAS/C,EAAkBiD,EAAYC,EAAazD,EAAK,CAErD,IAAI0D,EAAQ,CAAC,EACTC,EAAU,CAAC,EACXC,EAAY,CAAC,EACbC,EAAgB,CAAC,EAEjBC,EAAiB9D,EAAI,KAAK,MAG1B+D,EAAoB,IAAI,IAC5B,QAAWC,KAAgBR,EAAW,SAClCO,EAAkB,IAAIC,EAAa,UAAWA,CAAY,EAI9D,QAAWC,KAAkBR,EAAY,SAAU,CAG/C,IAAIS,EAAeH,EAAkB,IAAIE,EAAe,SAAS,EAC7DE,EAAenE,EAAI,KAAK,eAAeiE,CAAc,EACrDG,EAAcpE,EAAI,KAAK,eAAeiE,CAAc,EACpDC,GAAgBE,EACZD,EAEAR,EAAQ,KAAKM,CAAc,GAI3BF,EAAkB,OAAOE,EAAe,SAAS,EACjDL,EAAU,KAAKK,CAAc,GAG7BH,IAAmB,SAGfK,IACAR,EAAQ,KAAKM,CAAc,EAC3BJ,EAAc,KAAKI,CAAc,GAIjCjE,EAAI,KAAK,aAAaiE,CAAc,IAAM,IAC1CN,EAAQ,KAAKM,CAAc,CAI3C,CAIAJ,EAAc,KAAK,GAAGE,EAAkB,OAAO,CAAC,EAGhD,IAAIzD,GAAW,CAAC,EAChB,QAAW+D,KAAWR,EAAe,CAEjC,IAAIS,EAAS,SAAS,YAAY,EAAE,yBAAyBD,EAAQ,SAAS,EAAE,WAEhF,GAAIrE,EAAI,UAAU,gBAAgBsE,CAAM,IAAM,GAAO,CACjD,GAAIA,EAAO,MAAQA,EAAO,IAAK,CAC3B,IAAIC,EAAU,KACVC,EAAU,IAAI,QAAQ,SAAUC,GAAU,CAC1CF,EAAUE,EACd,CAAC,EACDH,EAAO,iBAAiB,OAAQ,UAAY,CACxCC,EAAQ,CACZ,CAAC,EACDjE,GAAS,KAAKkE,CAAO,CACzB,CACAf,EAAY,YAAYa,CAAM,EAC9BtE,EAAI,UAAU,eAAesE,CAAM,EACnCZ,EAAM,KAAKY,CAAM,CACrB,CACJ,CAIA,QAAWI,KAAkBf,EACrB3D,EAAI,UAAU,kBAAkB0E,CAAc,IAAM,KACpDjB,EAAY,YAAYiB,CAAc,EACtC1E,EAAI,UAAU,iBAAiB0E,CAAc,GAIrD,OAAA1E,EAAI,KAAK,iBAAiByD,EAAa,CAAC,MAAOC,EAAO,KAAME,EAAW,QAASD,CAAO,CAAC,EACjFrD,EACX,CAMA,SAASqE,GAAM,CAEf,CAEA,SAASpF,GAAO,CAChB,CAMA,SAASqF,EAAchF,EAAQ,CAC3B,IAAIiF,EAAc,CAAC,EAEnB,cAAO,OAAOA,EAAavF,CAAQ,EACnC,OAAO,OAAOuF,EAAajF,CAAM,EAGjCiF,EAAY,UAAY,CAAC,EACzB,OAAO,OAAOA,EAAY,UAAWvF,EAAS,SAAS,EACvD,OAAO,OAAOuF,EAAY,UAAWjF,EAAO,SAAS,EAGrDiF,EAAY,KAAO,CAAC,EACpB,OAAO,OAAOA,EAAY,KAAMvF,EAAS,IAAI,EAC7C,OAAO,OAAOuF,EAAY,KAAMjF,EAAO,IAAI,EACpCiF,CACX,CAEA,SAAS5E,EAAmBP,EAASC,EAAYC,EAAQ,CACrD,OAAAA,EAASgF,EAAchF,CAAM,EACtB,CACH,OAAQF,EACR,WAAYC,EACZ,OAAQC,EACR,WAAYA,EAAO,WACnB,aAAcA,EAAO,aACrB,kBAAmBA,EAAO,kBAC1B,MAAOkF,GAAYpF,EAASC,CAAU,EACtC,QAAS,IAAI,IACb,UAAWC,EAAO,UAClB,KAAMA,EAAO,IACjB,CACJ,CAEA,SAAS8B,EAAaqD,EAAOC,EAAOhF,EAAK,CACrC,OAAI+E,GAAS,MAAQC,GAAS,KACnB,GAEPD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,QACzDD,EAAM,KAAO,IAAMA,EAAM,KAAOC,EAAM,GAC/B,GAEAC,EAAuBjF,EAAK+E,EAAOC,CAAK,EAAI,EAGpD,EACX,CAEA,SAAS9D,EAAY6D,EAAOC,EAAO,CAC/B,OAAID,GAAS,MAAQC,GAAS,KACnB,GAEJD,EAAM,WAAaC,EAAM,UAAYD,EAAM,UAAYC,EAAM,OACxE,CAEA,SAASnD,EAAmBqD,EAAgBC,EAAcnF,EAAK,CAC3D,KAAOkF,IAAmBC,GAAc,CACpC,IAAInD,EAAWkD,EACfA,EAAiBA,EAAe,YAChCjD,GAAWD,EAAUhC,CAAG,CAC5B,CACA,OAAAyB,EAA2BzB,EAAKmF,CAAY,EACrCA,EAAa,WACxB,CAQA,SAASvD,EAAejC,EAAY0B,EAAWG,EAAUD,EAAgBvB,EAAK,CAG1E,IAAIoF,EAA2BH,EAAuBjF,EAAKwB,EAAUH,CAAS,EAE1EgE,EAAiB,KAGrB,GAAID,EAA2B,EAAG,CAC9B,IAAIC,EAAiB9D,EAKjB+D,EAAkB,EACtB,KAAOD,GAAkB,MAAM,CAG3B,GAAI3D,EAAaF,EAAU6D,EAAgBrF,CAAG,EAC1C,OAAOqF,EAKX,GADAC,GAAmBL,EAAuBjF,EAAKqF,EAAgB1F,CAAU,EACrE2F,EAAkBF,EAGlB,OAAO,KAIXC,EAAiBA,EAAe,WACpC,CACJ,CACA,OAAOA,CACX,CAQA,SAAStD,GAAcpC,EAAY0B,EAAWG,EAAUD,EAAgBvB,EAAK,CAEzE,IAAIuF,EAAqBhE,EACrBX,EAAcY,EAAS,YACvBgE,EAAwB,EAE5B,KAAOD,GAAsB,MAAM,CAE/B,GAAIN,EAAuBjF,EAAKuF,EAAoB5F,CAAU,EAAI,EAG9D,OAAO,KAIX,GAAIuB,EAAYM,EAAU+D,CAAkB,EACxC,OAAOA,EAGX,GAAIrE,EAAYN,EAAa2E,CAAkB,IAG3CC,IACA5E,EAAcA,EAAY,YAItB4E,GAAyB,GACzB,OAAO,KAKfD,EAAqBA,EAAmB,WAC5C,CAEA,OAAOA,CACX,CAEA,SAAS1F,GAAaF,EAAY,CAC9B,IAAI8F,EAAS,IAAI,UAGbC,EAAyB/F,EAAW,QAAQ,uCAAwC,EAAE,EAG1F,GAAI+F,EAAuB,MAAM,UAAU,GAAKA,EAAuB,MAAM,UAAU,GAAKA,EAAuB,MAAM,UAAU,EAAG,CAClI,IAAIC,EAAUF,EAAO,gBAAgB9F,EAAY,WAAW,EAE5D,GAAI+F,EAAuB,MAAM,UAAU,EACvC,OAAAC,EAAQ,qBAAuB,GACxBA,EACJ,CAEH,IAAIC,EAAcD,EAAQ,WAC1B,OAAIC,GACAA,EAAY,qBAAuB,GAC5BA,GAEA,IAEf,CACJ,KAAO,CAIH,IAAID,EADcF,EAAO,gBAAgB,mBAAqB9F,EAAa,qBAAsB,WAAW,EAClF,KAAK,cAAc,UAAU,EAAE,QACzD,OAAAgG,EAAQ,qBAAuB,GACxBA,CACX,CACJ,CAEA,SAAS5F,GAAiBJ,EAAY,CAClC,GAAIA,GAAc,KAGd,OADoB,SAAS,cAAc,KAAK,EAE7C,GAAIA,EAAW,qBAElB,OAAOA,EACJ,GAAIA,aAAsB,KAAM,CAEnC,IAAMkG,EAAc,SAAS,cAAc,KAAK,EAChD,OAAAA,EAAY,OAAOlG,CAAU,EACtBkG,CACX,KAAO,CAGH,IAAMA,EAAc,SAAS,cAAc,KAAK,EAChD,QAAWrG,IAAO,CAAC,GAAGG,CAAU,EAC5BkG,EAAY,OAAOrG,CAAG,EAE1B,OAAOqG,CACX,CACJ,CAEA,SAAS9E,GAAeJ,EAAiBE,EAAaD,EAAa,CAC/D,IAAIkF,EAAQ,CAAC,EACTpC,EAAQ,CAAC,EACb,KAAO/C,GAAmB,MACtBmF,EAAM,KAAKnF,CAAe,EAC1BA,EAAkBA,EAAgB,gBAEtC,KAAOmF,EAAM,OAAS,GAAG,CACrB,IAAIC,EAAOD,EAAM,IAAI,EACrBpC,EAAM,KAAKqC,CAAI,EACflF,EAAY,cAAc,aAAakF,EAAMlF,CAAW,CAC5D,CAEA,IADA6C,EAAM,KAAK7C,CAAW,EACfD,GAAe,MAClBkF,EAAM,KAAKlF,CAAW,EACtB8C,EAAM,KAAK9C,CAAW,EACtBA,EAAcA,EAAY,YAE9B,KAAOkF,EAAM,OAAS,GAClBjF,EAAY,cAAc,aAAaiF,EAAM,IAAI,EAAGjF,EAAY,WAAW,EAE/E,OAAO6C,CACX,CAEA,SAAShD,GAAkBf,EAAYD,EAASM,EAAK,CACjD,IAAIgG,EACJA,EAAiBrG,EAAW,WAC5B,IAAIsG,EAAcD,EACdE,EAAQ,EACZ,KAAOF,GAAgB,CACnB,IAAIG,EAAWC,GAAaJ,EAAgBtG,EAASM,CAAG,EACpDmG,EAAWD,IACXD,EAAcD,EACdE,EAAQC,GAEZH,EAAiBA,EAAe,WACpC,CACA,OAAOC,CACX,CAEA,SAASG,GAAarB,EAAOC,EAAOhF,EAAK,CACrC,OAAIkB,EAAY6D,EAAOC,CAAK,EACjB,GAAKC,EAAuBjF,EAAK+E,EAAOC,CAAK,EAEjD,CACX,CAEA,SAAS/C,GAAWD,EAAUhC,EAAK,CAC/ByB,EAA2BzB,EAAKgC,CAAQ,EACpChC,EAAI,UAAU,kBAAkBgC,CAAQ,IAAM,KAElDA,EAAS,OAAO,EAChBhC,EAAI,UAAU,iBAAiBgC,CAAQ,EAC3C,CAMA,SAASqE,GAAoBrG,EAAKsG,EAAI,CAClC,MAAO,CAACtG,EAAI,QAAQ,IAAIsG,CAAE,CAC9B,CAEA,SAASC,GAAevG,EAAKsG,EAAIE,EAAY,CAEzC,OADYxG,EAAI,MAAM,IAAIwG,CAAU,GAAKnH,GAC5B,IAAIiH,CAAE,CACvB,CAEA,SAAS7E,EAA2BzB,EAAK+F,EAAM,CAC3C,IAAIU,EAAQzG,EAAI,MAAM,IAAI+F,CAAI,GAAK1G,EACnC,QAAWiH,KAAMG,EACbzG,EAAI,QAAQ,IAAIsG,CAAE,CAE1B,CAEA,SAASrB,EAAuBjF,EAAK+E,EAAOC,EAAO,CAC/C,IAAI0B,EAAY1G,EAAI,MAAM,IAAI+E,CAAK,GAAK1F,EACpCsH,EAAa,EACjB,QAAWL,KAAMI,EAGTL,GAAoBrG,EAAKsG,CAAE,GAAKC,GAAevG,EAAKsG,EAAItB,CAAK,GAC7D,EAAE2B,EAGV,OAAOA,CACX,CAUA,SAASC,GAAqBb,EAAMc,EAAO,CACvC,IAAIC,EAAaf,EAAK,cAElBgB,EAAahB,EAAK,iBAAiB,MAAM,EAC7C,QAAWvG,KAAOuH,EAAY,CAC1B,IAAIC,EAAUxH,EAGd,KAAOwH,IAAYF,GAAcE,GAAW,MAAM,CAC9C,IAAIP,EAAQI,EAAM,IAAIG,CAAO,EAEzBP,GAAS,OACTA,EAAQ,IAAI,IACZI,EAAM,IAAIG,EAASP,CAAK,GAE5BA,EAAM,IAAIjH,EAAI,EAAE,EAChBwH,EAAUA,EAAQ,aACtB,CACJ,CACJ,CAYA,SAASlC,GAAYmC,EAAYtH,EAAY,CACzC,IAAIkH,EAAQ,IAAI,IAChB,OAAAD,GAAqBK,EAAYJ,CAAK,EACtCD,GAAqBjH,EAAYkH,CAAK,EAC/BA,CACX,CAKA,MAAO,CACH,MAAApH,EACA,SAAAH,CACJ,CACJ,EAAG,ECr3BP,IAAM4H,GAAoBC,GAAS,CACjC,IAAMC,EAAQD,EACX,MAAM,eAAe,EACrB,IAAIE,GAAKA,EAAE,KAAK,CAAC,EACjB,OAAOA,GAAKA,CAAC,EAEZC,EAAS,EACPC,EAAQ,CAAC,EAEf,QAASC,EAAI,EAAGA,EAAIJ,EAAM,OAAQI,IAAK,CACrC,IAAMC,EAAOL,EAAMI,CAAC,EACdE,EAAWN,EAAMI,EAAI,CAAC,EACtBG,EAAeP,EAAMI,EAAI,CAAC,EAGhC,GAAIC,EAAK,WAAW,GAAG,EAErB,GAAI,CAACA,EAAK,WAAW,IAAI,GAAK,CAACA,EAAK,SAAS,IAAI,GAAKC,GAAY,CAACA,EAAS,WAAW,GAAG,GAAKC,GAAgBA,EAAa,WAAW,IAAI,EAAG,CAE5I,IAAMC,EAAe,KAAK,IAAI,EAAGN,CAAM,EACvCC,EAAM,KAAK,KAAK,OAAOK,CAAY,EAAIH,EAAOC,EAAWC,CAAY,EACrEH,GAAK,CACP,SAESC,EAAK,WAAW,IAAI,EAAG,CAC9BH,IACA,IAAMM,EAAe,KAAK,IAAI,EAAGN,CAAM,EACvCC,EAAM,KAAK,KAAK,OAAOK,CAAY,EAAIH,CAAI,CAC7C,SAESA,EAAK,SAAS,IAAI,GAAKA,EAAK,SAAS,KAAK,EAAG,CACpD,IAAMG,EAAe,KAAK,IAAI,EAAGN,CAAM,EACvCC,EAAM,KAAK,KAAK,OAAOK,CAAY,EAAIH,CAAI,CAC7C,KAEK,CACH,IAAMG,EAAe,KAAK,IAAI,EAAGN,CAAM,EACvCC,EAAM,KAAK,KAAK,OAAOK,CAAY,EAAIH,CAAI,EAC3CH,GACF,SAGOG,EAAM,CACb,IAAMG,EAAe,KAAK,IAAI,EAAGN,CAAM,EACvCC,EAAM,KAAK,KAAK,OAAOK,CAAY,EAAIH,CAAI,CAC7C,CACF,CAEA,OAAOF,EAAM,KAAK;AAAA,CAAI,CACxB,EAEMM,GAAO,IAAM,CACjB,IAAMC,EAAO,CAAC,EACRC,EAAW,CAAC,EACdC,EAAe,EACfC,EAAgB,KAGpB,SAAS,iBAAiB,UAAYC,GAAM,CAC1C,GAAIA,EAAE,MAAQ,SAAU,CACtBA,EAAE,eAAe,EACjB,IAAMC,EAAS,SAAS,eAAe,aAAa,EAC9CC,EAAS,SAAS,eAAe,mBAAmB,EAEtDD,GAEFA,EAAO,OAAO,EACdE,EAAgB,GACPD,IAETA,EAAO,OAAO,EACdE,EAAc,EAElB,MAAWJ,EAAE,MAAQ,aAAeA,EAAE,MAAQ,cAAgBA,EAAE,MAAQ,WAAaA,EAAE,MAAQ,cAC9E,SAAS,eAAe,aAAa,GACtCJ,EAAK,OAAS,IAC1BI,EAAE,eAAe,EACbA,EAAE,MAAQ,aAAeF,EAAe,GAC1CA,IACA,aAAa,QAAQ,aAAcA,CAAY,EAC/CC,EAAc,GACLC,EAAE,MAAQ,cAAgBF,EAAeF,EAAK,OAAS,GAChEE,IACA,aAAa,QAAQ,aAAcA,CAAY,EAC/CC,EAAc,GACLC,EAAE,MAAQ,WAAaF,EAAe,GAC/CA,EAAe,KAAK,IAAI,EAAGA,EAAe,CAAC,EAC3C,aAAa,QAAQ,aAAcA,CAAY,EAC/CC,EAAc,GACLC,EAAE,MAAQ,aAAeF,EAAeF,EAAK,OAAS,IAC/DE,EAAe,KAAK,IAAIF,EAAK,OAAS,EAAGE,EAAe,CAAC,EACzD,aAAa,QAAQ,aAAcA,CAAY,EAC/CC,EAAc,GAItB,CAAC,EAED,IAAMI,EAAkB,IAAM,CAC5B,IAAIE,EAAM,SAAS,eAAe,mBAAmB,EAChDA,IACHA,EAAM,SAAS,KAAK,YAAY,SAAS,cAAc,QAAQ,CAAC,EAChEA,EAAI,GAAK,oBACTA,EAAI,UAAY,ycAChBA,EAAI,MAAM,QACR,wRAKFA,EAAI,QAAU,IAAM,CAClBA,EAAI,OAAO,EACXD,EAAc,CAChB,EAEJ,EAEMA,EAAgB,IAAM,CAC1B,IAAIE,EAAI,SAAS,eAAe,aAAa,EAC7C,GAAI,CAACA,EAAG,CACNA,EAAI,SAAS,KAAK,YAAY,SAAS,cAAc,KAAK,CAAC,EAC3DA,EAAE,GAAK,cACP,IAAMC,EAAY,OAAO,aAAe,SAAS,gBAAgB,UACjED,EAAE,MAAM,QACN,2BAA6BC,EAAY,IAAM,+OAInD,CAGA,IAAMC,EAAa,SAAS,aAAa,QAAQ,YAAY,CAAC,EAC1D,CAAC,MAAMA,CAAU,GAAKA,GAAc,GAAKA,EAAaZ,EAAK,OAC7DE,EAAeU,EAEfV,EAAeF,EAAK,OAAS,EAG/BG,EAAgB,IAAM,CACpB,IAAMU,EAAUb,EAAK,IAAI,CAACc,EAAGpB,IAAM,CACjC,IAAIqB,EAAU,UACd,OAAIrB,IAAMQ,IACJD,EAASP,CAAC,IAAM,SAClBqB,EAAU,UACDd,EAASP,CAAC,IAAM,UACzBqB,EAAU,YAGP,oHAAoHrB,IAAMQ,EAAe,OAASa,CAAO,UAAUrB,IAAMQ,EAAe,OAAS,MAAM,iBAAiBR,CAAC,KAAKA,EAAI,CAAC,WAC5O,CAAC,EAAE,KAAK,EAAE,EAEVgB,EAAE,UACA,2OAE+EG,EAAU,kOAGkDb,EAAKE,CAAY,EAAI,eAGlKQ,EAAE,cAAc,gCAAgC,EAAE,QAAU,IAAM,CAChEA,EAAE,OAAO,EACTH,EAAgB,CAClB,EAEAG,EAAE,iBAAiB,oBAAoB,EAAE,QAAQD,GAAO,CACtDA,EAAI,QAAU,IAAM,CAClBP,EAAe,SAASO,EAAI,QAAQ,KAAK,EACzC,aAAa,QAAQ,aAAcP,CAAY,EAC/CC,EAAc,CAChB,CACF,CAAC,CACH,EAEAA,EAAc,CAChB,EAEA,OAAOa,GAAK,CACV,GAAI,CAAC,SAAS,KAAM,CAClB,OAAO,sBAAuB,IAAMjB,EAAIiB,CAAC,CAAE,EAC3C,MACF,CAGA,IAAIC,EAAe,OAAOD,EAEtBA,aAAa,OACXA,EAAE,WAAa,KAAK,UACtBA,EAAIA,EAAE,aAAe,OAAOA,CAAC,EAE7BA,EAAI5B,GAAiB4B,EAAE,SAAS,GAIhCA,IAAM,SAAaA,EAAI,aACvBA,IAAM,OAAQA,EAAI,QAElB,MAAM,QAAQA,CAAC,EACjBC,EAAe,QACN,OAAOD,GAAM,UAAYA,IAAM,OACxCC,EAAe,UAGb,OAAOD,GAAK,WACdA,EAAI,KAAK,UAAUA,EAAG,CAACE,EAAKC,IACtB,OAAOA,GAAU,WACZ,OAAOA,CAAK,EAEdA,EACN,CAAC,EAAE,WAAW,IAAK,MAAM,GAG9BH,EAAIA,EAAE,KAAK,EAEXhB,EAAK,KAAKgB,EAAI;AAAA;AAAA,QAAaC,CAAY,EAAE,EACzChB,EAAS,KAAKgB,CAAY,EAGX,CAAC,CAAC,SAAS,eAAe,aAAa,GAOpDf,EAAeF,EAAK,OAAS,EAC7B,aAAa,QAAQ,aAAcE,CAAY,EAC3CC,GACFA,EAAc,GANhBK,EAAc,CASlB,CACF,GAAG,EAEC,OAAO,OAAW,KAAe,CAAC,OAAO,MAC3C,OAAO,IAAMT,GAGf,IAAOqB,GAAQrB,EC9Of,IAAMsB,GAAe,IAAM,CAEzB,IAAMC,EAAO,SAAS,OAAO,SAAS,IAAI,GAAK,GAC/C,GAAI,EAAE,IAAI,MAAQ,IAASA,EAAO,MAAQ,IAAI,MAAQ,IAAS,OAG/D,IAAMC,EAAqB,SAAS,iBAAiB,wBAAwB,EAE7E,GAAIA,EAAmB,OAAS,EAAG,CAEjCA,EAAmB,QAAQC,GAAMA,EAAG,OAAO,CAAC,EAC5C,MACF,CAGoB,SAAS,iBAAiB,eAAe,EAEjD,QAAQA,GAAM,CACxB,IAAIC,EAAgB,KAChBC,EAAgB,KAapB,GAVIF,EAAG,UAAU,SAAS,KAAK,GAAKA,EAAG,KAAOA,EAAG,IAAI,SACnDC,EAAgBD,EAAG,IAAI,QACvBE,EAAgB,OAGTF,EAAG,UAAU,SAAS,QAAQ,GAAKA,EAAG,QAAUA,EAAG,OAAO,aACjEC,EAAgBD,EAAG,OAAO,WAC1BE,EAAgB,UAGdD,EAAe,CAEjB,IAAME,EAAU,SAAS,cAAc,KAAK,EAC5CA,EAAQ,UAAY,wBAGpB,IAAMC,EAAOJ,EAAG,sBAAsB,EAChCK,EAAY,OAAO,aAAe,SAAS,gBAAgB,UAC3DC,EAAa,OAAO,aAAe,SAAS,gBAAgB,WAGlEH,EAAQ,MAAM,QAAU;AAAA;AAAA,eAEfC,EAAK,IAAMC,CAAS;AAAA,gBACnBD,EAAK,KAAOE,CAAU;AAAA,iBACrBF,EAAK,KAAK;AAAA,kBACTA,EAAK,MAAM;AAAA,4BACDF,IAAkB,SAAW,OAAS,KAAK;AAAA;AAAA;AAAA,QAMjE,IAAMK,EAAQ,SAAS,cAAc,KAAK,EAC1CA,EAAM,YAAcN,EACpBM,EAAM,MAAM,QAAU;AAAA;AAAA;AAAA;AAAA,sBAINL,IAAkB,SAAW,OAAS,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAa3DK,EAAM,iBAAiB,QAAUC,GAAM,CACrCA,EAAE,gBAAgB,EAClB,IAAI,IAAIR,CAAE,CACZ,CAAC,EAEDG,EAAQ,YAAYI,CAAK,EACzB,SAAS,KAAK,YAAYJ,CAAO,CACnC,CACF,CAAC,CACH,EAGA,SAAS,iBAAiB,UAAYM,GAAU,EACzCA,EAAM,SAAWA,EAAM,UAAYA,EAAM,MAAQ,MAE/CA,EAAM,OAAO,QAAQ,MAAM,IAC9BA,EAAM,eAAe,EACrBZ,GAAa,GAGnB,CAAC,EAED,IAAOa,GAAQb,GC5Ef,IAAMc,GAAoB,IAAI,IAAI,CAChC,OAAQ,OAAQ,KAAM,MAAO,QAAS,KAAM,MAC5C,QAAS,OAAQ,OAAQ,SAAU,QAAS,KAC9C,CAAC,EAGKC,GAAe,IAAI,iBAAiBC,GAAa,CACrD,QAAWC,KAAYD,EACrB,GAAIC,EAAS,OAAS,aAAc,CAClC,IAAMC,EAAMD,EAAS,OAAO,IAC5B,GAAIC,EAAK,CACP,IAAMC,EAAOF,EAAS,cAChBG,EAAQH,EAAS,OAAO,aAAaE,CAAI,EAC/CD,EAAI,MAAMC,CAAI,EAAIC,EAClBF,EAAI,cAAcC,EAAMC,CAAK,CAC/B,CACF,CAEJ,CAAC,EAmBc,SAARC,EAAyBF,EAAMG,EAAO,CAC3C,IAAMC,EAAM,WAAW,QAAQ,KAAO,WAAW,IAGjD,GAAI,CAACJ,EAAK,SAAS,GAAG,EAAG,CACvB,QAAQ,MAAM,sBAAsBA,CAAI,yBAAyB,EACjE,MACF,CAMA,GAHAG,EAAQE,GAAcD,EAAKJ,EAAMG,CAAK,EAGlCA,EAAM,KAAM,CACd,IAAMG,EAAUH,EAAM,MAAQ,MAC9BA,EAAM,KAAOA,EAAM,KAChB,QAAQ,mBAAoB,IAAIG,CAAO,6BAA6BN,CAAI,oBAAoBA,CAAI,MAAM,EACtG,QAAQ,UAAW,KAAKM,CAAO,GAAG,EAErCH,EAAM,YAAcI,EAAeJ,EAAM,KAAM,CAAE,KAAAH,CAAK,CAAC,CACzD,CAGIG,EAAM,MACRA,EAAM,IAAMC,EAAI,UAAUD,EAAM,IAAK,CAAE,KAAAH,CAAK,CAAC,GAI/CI,EAAI,QAAQJ,CAAI,EAAIG,EAGf,eAAe,IAAIH,CAAI,GAC1B,eAAe,OAAOA,EAAM,cAAc,WAAY,CACpD,mBAAoB,CACdQ,GAAiB,KAAML,CAAK,EAC9BM,GAAYT,EAAM,IAAI,EAEtB,sBAAsB,IAAMS,GAAYT,EAAM,IAAI,CAAC,CAEvD,CACF,CAAC,CAEL,CAUA,SAASK,GAAcD,EAAKJ,EAAMG,EAAO,CAEvC,GAAIA,EAAM,qBAAqBO,EAC7B,OAAIP,EAAM,OAAMA,EAAM,KAAOQ,GAAgBR,EAAM,IAAI,GAChDA,EAIT,IAAMS,EAAW,IAAIT,EACfU,EAAW,cAAcH,CAAQ,CAAC,EAGlCI,EAAQ,CACZ,GAAG,OAAO,oBAAoBF,CAAQ,EACtC,GAAG,OAAO,oBAAoBT,EAAM,SAAS,CAC/C,EAAE,OAAOY,GAAKA,IAAM,eAAiBA,IAAM,WAAW,EAEtD,QAAWC,KAAQF,EACjBD,EAAS,UAAUG,CAAI,EAAIJ,EAASI,CAAI,EAI1C,IAAMC,EAAY,CAAE,KAAM,OAAQ,OAAQ,SAAU,IAAK,MAAO,KAAM,UAAW,EACjF,OAAW,CAACC,EAAMC,CAAE,IAAK,OAAO,QAAQF,CAAS,EAC3CL,EAASM,CAAI,IAAGL,EAASM,CAAE,EAAIP,EAASM,CAAI,GAIlD,OAAIN,EAAS,OACXC,EAAS,KAAOF,GAAgBC,EAAS,IAAI,GAI3CA,EAAS,QACXR,EAAI,QAAQ,IAAM,SAAS,KAAK,YAAY,SAAS,cAAcJ,CAAI,CAAC,CAAC,EAG3EI,EAAI,WAAW,GAAGJ,CAAI,WAAW,EAC1Ba,CACT,CAMA,SAASF,GAAgBS,EAAM,CAC7B,OAAOA,EAAK,QAAQ,0BAA2B,CAACC,EAAOC,EAAKC,IACnD5B,GAAkB,IAAI2B,CAAG,EAAID,EAAQ,IAAIC,CAAG,GAAGC,CAAK,MAAMD,CAAG,GACrE,CACH,CAKA,SAASd,GAAiBgB,EAAMrB,EAAO,CACrC,IAAMsB,EAAOD,EAAK,aAAa,UAAU,EACzC,GAAIC,IAAS,QAAS,MAAO,GAE7B,IAAMC,EAAY,OAAOvB,EAAM,MAAS,WAAaA,EAAM,KAAKqB,CAAI,EAAIrB,EAAM,KAC9E,MAAO,CAAC,EAAEsB,GAAQC,GAAaF,EAAK,WAAW,CAAC,GAAKA,EAAK,YAC5D,CASA,SAASf,GAAYT,EAAMwB,EAAM,CAE/B,GADI,CAACA,EAAK,aACNA,EAAK,WAAW,SAAS,KAAK,EAAG,OAErC,IAAMrB,EAAQ,IAAI,QAAQH,CAAI,EACxB2B,EAAW,OAAOxB,EAAM,UAAa,WAAaA,EAAM,SAASqB,CAAI,EAAIrB,EAAM,SAC/EyB,EAAU,SAAS,cAAcD,GAAY,KAAK,EAIxD,GAFAC,EAAQ,UAAU,IAAI,MAAO,OAAO5B,CAAI,EAAE,EAEtC,CAACwB,EAAK,WAAY,CACpB,QAAQ,KAAK,QAAQxB,CAAI,0BAA0B,EACnD,MACF,CAGAwB,EAAK,WAAW,aAAaI,EAASJ,CAAI,EAG1C,IAAMzB,EAAM,IAAII,EA0ChB,GAzCAJ,EAAI,IAAM,EAAE,IAAI,cAChB,IAAI,UAAU,IAAIA,EAAI,IAAKA,CAAG,EAE9BA,EAAI,QAAUyB,EACdzB,EAAI,QAAUC,EACdD,EAAI,KAAO6B,EACX7B,EAAI,MAAQI,EAAM,SAASqB,EAAMI,CAAO,EACxC7B,EAAI,MAAQI,EAGZJ,EAAI,QAAQyB,EAAMI,CAAO,EAEzBA,EAAQ,IAAM7B,EAGVI,EAAM,QAAUA,EAAM,SAAW,KACnC,OAAOA,EAAM,MAAM,IAAMJ,GAIvB,OAAO,IAAGA,EAAI,MAAQ,EAAE6B,CAAO,GAG/B7B,EAAI,MAAM,IAAI6B,EAAQ,aAAa,KAAM7B,EAAI,MAAM,EAAE,EAKzDA,EAAI,YAAY,GAGGA,EAAI,QAAUA,EAAI,MAAQA,EAAI,SAAWA,EAAI,SACrD,KAAKA,EAAKA,EAAI,KAAK,EAG9BA,EAAI,UAAU,EAGdA,EAAI,QAAQA,EAAI,KAAK,EAGjBA,EAAI,SAAU,CAChB,IAAM8B,EAAO9B,EAAI,KAAK,WAAa,OAASA,EAAI,KAAOA,EAAI,KAAK,MAAM,EAClE8B,IACFA,EAAK,SAAYC,GAAM,CACrBA,EAAE,eAAe,EACjB/B,EAAI,SAASA,EAAI,SAAS,CAAC,CAC7B,EAEJ,CAGA,GAAIA,EAAI,cAAe,CACrBH,GAAa,QAAQgC,EAAS,CAAE,WAAY,EAAK,CAAC,EAClD,OAAW,CAACG,EAAK9B,CAAK,IAAK,OAAO,QAAQF,EAAI,KAAK,EACjDA,EAAI,cAAcgC,EAAK9B,CAAK,CAEhC,CACF,CCnOe,SAAR+B,EAAyBC,EAASC,EAAM,CAE7C,GAAI,UAAU,SAAW,EACvB,OAAOC,EAAYF,CAAO,EAI5B,GAAIC,GAAM,SAAS,QAAQ,EACzB,OAAOC,EAAYD,CAAI,EAIzB,GAAID,GAAW,CAACA,EAAQ,SAAS,GAAG,GAAK,CAACA,EAAQ,SAAS,GAAG,GAAK,CAACA,EAAQ,SAAS,GAAG,EAAG,CACzF,QAAQ,MAAM,sBAAsBA,CAAO,8CAA8C,EACzF,MACF,CAGA,IAAMG,EAAYC,GAAkBJ,EAASK,GAAeJ,CAAI,CAAC,EAGjEK,GAAkBN,CAAO,EAGzBO,GAAiBP,EAASG,CAAS,CACrC,CASA,SAASD,EAAYM,EAAM,CAEzB,GAAIA,aAAgB,KAAM,CACxB,IAAMC,EAAOD,EACbC,EAAK,OAAO,EAEZ,IAAMC,EAAUD,EAAK,aAAa,KAAK,EAGvC,GAAIC,GAAS,SAAS,GAAG,GAAKA,GAAS,SAAS,GAAG,EACjD,OAAOC,GAAeD,CAAO,EAI/B,GAAIA,GAAW,CAACA,EAAQ,SAAS,GAAG,EAAG,CACrC,QAAQ,MAAM,sBAAsBA,CAAO,yBAAyB,EACpE,MACF,CAEA,OAAOX,EAAQW,EAASD,EAAK,SAAS,CACxC,EAGaD,EAAO,IAAI,QAAQA,CAAI,EAAI,SAAS,MAC5C,iBAAiB,yBAAyB,EAAE,QAAQI,GAAKV,EAAYU,CAAC,CAAC,CAC9E,CAKA,SAASD,GAAeE,EAAK,CAC3B,IAAI,WAAW,gBAAgBA,CAAG,EAAE,EAEpC,IAAI,MAAMA,CAAG,EACV,KAAKC,GAAW,CAEf,IAAMC,EADM,IAAI,UAAU,EAAE,gBAAgBD,EAAS,WAAW,EACxC,iBAAiB,yBAAyB,EAElE,GAAIC,EAAY,OAAS,EAEvBA,EAAY,QAAQC,GAAM,CACxB,IAAMC,EAAOD,EAAG,aAAa,KAAK,EAClC,GAAIC,GAAQ,CAACA,EAAK,SAAS,GAAG,GAAK,CAACA,EAAK,SAAS,GAAG,GAAK,CAACA,EAAK,SAAS,GAAG,EAAG,CAC7E,QAAQ,MAAM,sBAAsBA,CAAI,yBAAyB,EACjE,MACF,CACAlB,EAAQkB,EAAMD,EAAG,SAAS,CAC5B,CAAC,MACI,CAEL,IAAMC,EAAOJ,EAAI,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,GAAG,EAAE,CAAC,EAC9Cd,EAAQkB,EAAMH,CAAO,CACvB,CACF,CAAC,EACA,MAAMI,GAAS,CACd,IAAI,QAAQ,UAAW,mBAAmBL,CAAG,MAAMK,EAAM,OAAO,EAAE,CACpE,CAAC,CACL,CAWA,SAASC,GAAeC,EAAM,CAC5B,IAAMC,EAAS,CAAE,OAAQ,GAAI,MAAO,GAAI,KAAM,GAAI,KAAM,EAAG,EACrDC,EAAQF,EAAK,MAAM;AAAA,CAAI,EAEzBG,EAAQ,CAAC,EACTC,EAAO,GAEX,QAASC,KAAQH,EACfG,EAAOA,EAAK,KAAK,EAGbA,EAAK,WAAW,SAAS,GAAK,CAACJ,EAAO,QAAUG,IAAS,OAC3DA,EAAO,SACEC,EAAK,WAAW,OAAO,GAAK,CAACJ,EAAO,OAC7CG,EAAO,OACEC,EAAK,WAAW,QAAQ,EACjCD,EAAO,QAGEC,EAAK,SAAS,YAAW,GAAKD,IAAS,UAAY,CAACH,EAAO,QACpEA,EAAO,OAASE,EAAM,KAAK;AAAA,CAAI,EAC/BA,EAAQ,CAAC,EACTC,EAAO,IACEC,EAAK,SAAS,UAAU,GAAKD,IAAS,SAC/CH,EAAO,MAAQE,EAAM,KAAK;AAAA,CAAI,EAC9BA,EAAQ,CAAC,EACTC,EAAO,KACGC,EAAK,SAAS,SAAS,GAAKA,EAAK,SAAS,WAAW,IAAMD,IAAS,QAC9EH,EAAO,KAAOE,EAAM,KAAK;AAAA,CAAI,EAC7BA,EAAQ,CAAC,EACTC,EAAO,IAGEA,EACTD,EAAM,KAAKE,CAAI,EAEfJ,EAAO,MAAQI,EAAO;AAAA,EAK1B,OAAIJ,EAAO,MACTK,GAAoBL,EAAO,IAAI,EAG1BA,CACT,CAKA,SAASK,GAAoBC,EAAU,CACrC,IAAMC,EAAY,IAAI,QAAQD,CAAQ,EAEtC,MAAM,KAAKC,EAAU,QAAQ,EAAE,QAAQC,GAAQ,CAC7C,GAAIA,EAAK,UAAY,SAAU,CAC7B,IAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9C,MAAM,KAAKD,EAAK,UAAU,EAAE,QAAQE,GAAQ,CAC1CD,EAAO,aAAaC,EAAK,KAAMA,EAAK,KAAK,CAC3C,CAAC,EACDD,EAAO,OAAS,kBAEZD,EAAK,IACP,SAAS,KAAK,YAAYC,CAAM,GACvBA,EAAO,KAAK,SAAS,YAAY,GAAKA,EAAO,OAAS,YAC/DA,EAAO,YAAcD,EAAK,YAC1B,SAAS,KAAK,YAAYC,CAAM,EAEpC,MACE,SAAS,KAAK,YAAYD,EAAK,UAAU,EAAI,CAAC,CAElD,CAAC,CACH,CASA,SAASG,GAAkBC,EAASC,EAAO,CACzC,IAAIC,EAAQD,EAAM,OAQlB,GALK,aAAa,KAAKC,CAAK,IAC1BA,EAAQ;AAAA,EAAYA,CAAK;AAAA,IAIvB,OAAOD,EAAM,KAAK,EAAE,SAAS,GAAG,EAAG,CACrC,IAAIE,EAAM,IAAI,SAASF,EAAM,KAAK,EAClCE,EAAMA,EAAI,SAAS,MAAM,GAAK,oBAAoB,KAAKA,CAAG,EACtDA,EACA;AAAA,EAAWA,CAAG;AAAA,GAClBD,EAAQA,EAAM,QAAQ,SAAU;AAAA,YAAeC,CAAG;AAAA,EAAO,CAC3D,CAGA,GAAI,KAAK,KAAK,OAAOF,EAAM,IAAI,CAAC,EAAG,CACjC,IAAMd,EAAOc,EAAM,KAChB,WAAW,IAAK,QAAQ,EACxB,WAAW,IAAK,KAAK,EACxBC,EAAQA,EAAM,QAAQ,SAAU;AAAA,aAAgBf,CAAI;AAAA,EAAO,CAC7D,CAGA,GAAM,CAACiB,EAAQC,CAAK,EAAIH,EAAM,MAAM,aAAc,CAAC,EACnD,MAAO,GAAGE,CAAM;AAAA;AAAA,cAAoBJ,CAAO;AAAA,EAAeK,CAAK,GACjE,CAKA,SAASC,GAAiBN,EAASO,EAAM,CAEvC,GAAIA,EAAK,SAAS,SAAS,EACzB,IAAI,KAAK,CAAE,OAAQA,CAAK,CAAC,EAGzB,WAAW,IAAM,CACV,IAAI,QAAQP,CAAO,GACtB,IAAI,aAAa,aAAaA,CAAO,2BAA2B,CAEpE,EAAG,GAAI,MAEP,IAAI,CACF,IAAI,SAASO,CAAI,EAAE,CACrB,OAAS,EAAG,CACV,IAAI,aAAa,aAAaP,CAAO,oBAAoB,EAAE,OAAO,EAAE,EACpE,QAAQ,IAAIO,CAAI,CAClB,CAEJ,CAKA,SAASC,GAAkBR,EAAS,CAClC,GAAI,CAACA,EAAS,OAEd,IAAIS,EAAU,SAAS,eAAe,mBAAmB,EACpDA,IACHA,EAAU,SAAS,cAAc,OAAO,EACxCA,EAAQ,GAAK,oBACb,SAAS,KAAK,YAAYA,CAAO,GAGnC,IAAMC,EAAU,CAAC,GAAG,OAAO,KAAK,IAAI,OAAO,EAAGV,CAAO,EAAE,KAAK,EAAE,KAAK,IAAI,EACvES,EAAQ,YAAc,GAAGC,CAAO;AAAA,CAClC,CC7PA,IAAMC,GAAc,CAClB,KAAM,CAAC,EACP,UAAW,IAAI,IACf,YAAa,IAAI,IACjB,kBAAmB,IAAI,IAEvB,OAAOC,EAAKC,EAAOC,EAAU,CAC3B,IAAI,WAAW,2BAA2BF,CAAG,KAAKC,CAAK,UAAUC,CAAQ,GAAG,EAG5E,IAAMC,EAAY,KAAK,UAAU,IAAIH,CAAG,EACpCG,GACFA,EAAU,QAAQC,GAAQ,CACpBA,EAAK,aACPA,EAAK,oBAAoBJ,EAAKC,EAAOC,CAAQ,EAC7CE,EAAK,UAAU,GAEfD,EAAU,OAAOC,CAAI,CAEzB,CAAC,EAIH,IAAMC,EAAc,KAAK,YAAY,IAAIL,CAAG,EACxCK,GACFA,EAAY,QAAQC,GAAQ,CAC1B,GAAI,CACFA,EAAKL,EAAOC,EAAUF,CAAG,CAC3B,OAASO,EAAO,CACd,QAAQ,MAAM,+BAA+BP,CAAG,IAAKO,CAAK,CAC5D,CACF,CAAC,EAIH,KAAK,kBAAkB,QAAQD,GAAQ,CACrC,GAAI,CACFA,EAAKN,EAAKC,EAAOC,CAAQ,CAC3B,OAASK,EAAO,CACd,QAAQ,MAAM,8BAA+BA,CAAK,CACpD,CACF,CAAC,CACH,EAEA,YAAYC,EAAW,CACrB,OAAO,IAAI,MAAM,CAAC,EAAG,CACnB,IAAK,CAACC,EAAQT,KAEZQ,EAAU,mBAAqB,IAAI,IAC9BA,EAAU,iBAAiB,IAAIR,CAAG,IACrCQ,EAAU,iBAAiB,IAAIR,CAAG,EAE7B,KAAK,UAAU,IAAIA,CAAG,GACzB,KAAK,UAAU,IAAIA,EAAK,IAAI,GAAK,EAEnC,KAAK,UAAU,IAAIA,CAAG,EAAE,IAAIQ,CAAS,GAGhC,KAAK,KAAKR,CAAG,GAGtB,IAAK,CAACS,EAAQT,EAAKC,IAAU,CAC3B,IAAMC,EAAW,KAAK,KAAKF,CAAG,EAC9B,OAAIE,IAAaD,IACf,KAAK,KAAKD,CAAG,EAAIC,EACjB,KAAK,OAAOD,EAAKC,EAAOC,CAAQ,GAE3B,EACT,CACF,CAAC,CACH,EAGA,IAAIF,EAAKC,EAAO,CACd,IAAMC,EAAW,KAAK,KAAKF,CAAG,EAC1BE,IAAaD,IACf,KAAK,KAAKD,CAAG,EAAIC,EACjB,KAAK,OAAOD,EAAKC,EAAOC,CAAQ,EAEpC,EAEA,IAAIF,EAAK,CACP,OAAO,KAAK,KAAKA,CAAG,CACtB,EAGA,QAAQA,EAAKM,EAAM,CACjB,IAAMH,EAAY,KAAK,UAAU,IAAIH,CAAG,EACpCG,GACFA,EAAU,QAAQC,GAAQ,CACpBA,EAAK,YACPE,EAAKF,CAAI,EAETD,EAAU,OAAOC,CAAI,CAEzB,CAAC,CAEL,EAKA,UAAUM,EAAWJ,EAAM,CACzB,GAAI,OAAOI,GAAc,WAEvB,YAAK,kBAAkB,IAAIA,CAAS,EAC7B,IAAM,KAAK,kBAAkB,OAAOA,CAAS,EAC/C,CAEL,IAAMV,EAAMU,EACZ,OAAK,KAAK,YAAY,IAAIV,CAAG,GAC3B,KAAK,YAAY,IAAIA,EAAK,IAAI,GAAK,EAErC,KAAK,YAAY,IAAIA,CAAG,EAAE,IAAIM,CAAI,EAC3B,IAAM,CACX,IAAMK,EAAiB,KAAK,YAAY,IAAIX,CAAG,EAC3CW,IACFA,EAAe,OAAOL,CAAI,EACtBK,EAAe,OAAS,GAC1B,KAAK,YAAY,OAAOX,CAAG,EAGjC,CACF,CACF,CACF,EAEOY,GAAQb,GC3Jf,IAAOc,GAASC,GAAQ,CAiBtBA,EAAI,KAAO,CAACC,EAAQC,IAAa,CAC/B,GAAID,EAAO,SAAU,CACfA,EAAO,UAAY,UACrBD,EAAI,KAAK,CAAC,OAAQC,EAAO,SAAS,CAAC,EACnCA,EAAO,OAAO,IAEdA,EAAO,iBAAiB,QAAQ,EAAE,QAASE,GAAMH,EAAI,KAAKG,CAAC,CAAE,EAC7DF,EAAO,iBAAiB,sCAAsC,EAAE,QAASE,GAAMH,EAAI,QAAQG,CAAC,CAAE,GAGhG,MACF,CAEA,GAAI,OAAOF,GAAW,UAAYA,IAAW,KAC3C,MAAM,IAAI,MAAM,mCAAmC,EAGrD,IAAIG,EAAKC,EAAa,CAAC,EAAGC,EAE1B,GAAIL,EAAO,OAAQ,CACjB,GAAIA,EAAO,OAAO,SAAS,SAAS,EAAG,CACjCC,GACFF,EAAI,aAAa,wFAAwF,EAI3G,IAAMO,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,KAAO,SACdA,EAAO,YAAcN,EAAO,OAC5B,SAAS,KAAK,YAAYM,CAAM,EAChC,sBAAsB,IAAIA,EAAO,OAAO,CAAC,CAC3C,KACE,IAAI,CACF,IAAI,SAASN,EAAO,MAAM,EAAE,EACxBC,GAAUA,EAAS,CACzB,OAASM,EAAO,CACdR,EAAI,aAAa,0BAA2BQ,CAAK,EACjD,QAAQ,IAAIP,EAAO,MAAM,CAC3B,CAEF,MACF,SAAWA,EAAO,GAAI,CACpBG,EAAMH,EAAO,GACbK,EAAc,SAEd,OAAW,CAACG,EAAKC,CAAK,IAAK,OAAO,QAAQT,CAAM,EAC1CQ,IAAQ,MAAQA,IAAQ,WAC1BJ,EAAWI,CAAG,EAAIC,GAIlBT,EAAO,SACTI,EAAW,KAAO,SAEtB,SAAWJ,EAAO,IAAK,CACrBG,EAAMH,EAAO,IACbK,EAAc,OACdD,EAAW,IAAM,aAEjB,OAAW,CAACI,EAAKC,CAAK,IAAK,OAAO,QAAQT,CAAM,EAC1CQ,IAAQ,QACVJ,EAAWI,CAAG,EAAIC,EAGxB,KACE,OAAM,IAAI,MAAM,uDAAuD,EAGzE,IAAMC,EAAe,SAAS,cAAc,GAAGL,CAAW,SAASF,CAAG,OAAOE,CAAW,UAAUF,CAAG,IAAI,EACzG,GAAIO,EACF,OAAIT,GAAUA,EAAS,EAChBS,EAGT,IAAMC,EAAU,SAAS,cAAcN,CAAW,EAE9CA,IAAgB,OAClBM,EAAQ,KAAOR,EAEfQ,EAAQ,IAAMR,EAGhB,OAAW,CAACK,EAAKC,CAAK,IAAK,OAAO,QAAQL,CAAU,EAClDO,EAAQ,aAAaH,EAAKC,CAAK,EAGjC,OAAIR,GAAYD,EAAO,UACrBW,EAAQ,OAAS,IAAM,CAEjBX,EAAO,QAAUK,IAAgB,UACnC,OAAOF,GAAK,KAAKS,GAAU,CACzB,OAAOZ,EAAO,MAAM,EAAIY,EAAO,SAAWA,EAAOZ,EAAO,MAAM,GAAKY,CACrE,CAAC,EAAE,MAAML,GAAS,CAChB,QAAQ,MAAM,0BAA0BP,EAAO,MAAM,IAAKO,CAAK,CACjE,CAAC,EAECN,GAAUA,EAAS,CACzB,GAGF,SAAS,KAAK,YAAYU,CAAO,EAE1BA,CACT,EAGA,IAAME,EAAkB,EAAI,GAAK,IAC3BC,EAAuB,IAa7Bf,EAAI,MAAQ,YAAYgB,EAAM,CAE5BhB,EAAI,cAAgB,IAAI,IAExB,IAAIiB,EAAS,MACTC,EACAhB,EAGA,OAAOc,EAAK,CAAC,GAAM,UAAY,WAAW,KAAKA,EAAK,CAAC,CAAC,IACxDC,EAASD,EAAK,MAAM,GAItBE,EAAMF,EAAK,MAAM,EAGjB,IAAIG,EAAO,CAAC,EACRC,EAAO,KAWX,GAVI,OAAOJ,EAAK,CAAC,GAAM,WACrBI,EAAOJ,EAAK,MAAM,GAIhB,OAAOA,EAAK,CAAC,GAAM,aACrBd,EAAWc,EAAK,MAAM,GAIpBI,GACF,GAAIH,IAAW,MAAO,CAEpB,IAAMI,EAAS,IAAI,gBAAgBD,CAAI,EACvCF,IAAQA,EAAI,SAAS,GAAG,EAAI,IAAM,KAAOG,EAAO,SAAS,CAC3D,SAAWJ,IAAW,OAAQ,CAE5B,IAAMK,EAAW,IAAI,SACrB,OAAW,CAACb,EAAKC,CAAK,IAAK,OAAO,QAAQU,CAAI,EAC5CE,EAAS,OAAOb,EAAKC,CAAK,EAE5BS,EAAK,KAAOG,CACd,EAIFH,EAAK,OAASF,EAGd,IAAMM,EAAW,GAAGN,CAAM,IAAIC,CAAG,IAAI,KAAK,UAAUC,CAAI,CAAC,GAGnDK,EAASxB,EAAI,YAAY,IAAIuB,CAAQ,EAC3C,GAAIC,GAAW,KAAK,IAAI,EAAIA,EAAO,UAAYV,EAAkB,CAE/D,GADAd,EAAI,WAAW,oBAAoBiB,CAAM,IAAIC,CAAG,EAAE,EAC9ChB,EAAU,CACZA,EAASsB,EAAO,IAAI,EACpB,MACF,CACA,OAAO,QAAQ,QAAQA,EAAO,IAAI,CACpC,CAGAxB,EAAI,WAAW,eAAeiB,CAAM,IAAIC,CAAG,EAAE,EAG7C,IAAMO,EAAmBC,GACnBA,EAAS,QAAQ,IAAI,cAAc,GAAG,SAAS,kBAAkB,EAC5DA,EAAS,KAAK,EAEhBA,EAAS,KAAK,EAIjBC,EAAe,CAAClB,EAAKW,IAAS,CAElC,GAAIpB,EAAI,YAAY,MAAQe,EAAsB,CAChD,IAAMa,EAAY5B,EAAI,YAAY,KAAK,EAAE,KAAK,EAAE,MAChDA,EAAI,YAAY,OAAO4B,CAAS,CAClC,CACA5B,EAAI,YAAY,IAAIS,EAAK,CAAE,KAAAW,EAAM,UAAW,KAAK,IAAI,CAAE,CAAC,CAC1D,EAGA,GAAIlB,EAAU,CACZ,MAAMgB,EAAKC,CAAI,EACZ,KAAKM,CAAe,EACpB,KAAKL,GAAQ,CACZO,EAAaJ,EAAUH,CAAI,EAC3BlB,EAASkB,CAAI,CACf,CAAC,EACA,MAAMZ,GAASR,EAAI,QAAQ,QAASQ,CAAK,CAAC,EAC7C,MACF,CAGA,OAAO,MAAMU,EAAKC,CAAI,EACnB,KAAKM,CAAe,EACpB,KAAKL,IACJO,EAAaJ,EAAUH,CAAI,EACpBA,EACR,CACL,EAGApB,EAAI,gBAAkB,IAAM,CAC1BA,EAAI,aAAa,MAAM,CACzB,EAEAA,EAAI,YAAc,CAAC6B,EAAOC,EAAU,KAAO,CAEzC,IAAMC,EAAM,SAASF,EAAM,QAAQ,IAAK,EAAE,EAAG,EAAE,EACzCG,EAAM,KAAK,MAAM,KAAOF,CAAO,EAC/BG,GAAKF,GAAO,IAAMC,EAClBE,GAAKH,GAAO,EAAI,KAAUC,EAC1BG,GAAKJ,EAAM,KAAYC,EAC7B,MAAO,KAAO,UAAaC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,KAAO,OAAWC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,KAAO,KAASC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,MAAM,SAAS,EAAE,EAAE,MAAM,CAAC,CACvK,EAEAnC,EAAI,aAAe,CAAC6B,EAAOC,EAAU,KAAO,CAE1C,IAAMC,EAAM,SAASF,EAAM,QAAQ,IAAK,EAAE,EAAG,EAAE,EACzCG,EAAM,KAAK,MAAM,KAAOF,CAAO,EAC/BG,GAAKF,GAAO,IAAMC,EAClBE,GAAKH,GAAO,EAAI,KAAUC,EAC1BG,GAAKJ,EAAM,KAAYC,EAC7B,MAAO,KAAO,UAAaC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,KAAO,OAAWC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,KAAO,KAASC,EAAI,IAAMA,EAAI,EAAI,EAAIA,EAAI,MAAM,SAAS,EAAE,EAAE,MAAM,CAAC,CACvK,EAMAnC,EAAI,WAAcoC,GACZ,OAAOA,GAAS,SACXA,EACJ,QAAQ,0CAA2C,EAAE,EACrD,WAAW,IAAK,OAAO,EACvB,WAAW,IAAK,QAAQ,EACxB,WAAW,IAAK,QAAQ,EACxB,WAAW,IAAK,MAAM,EACtB,WAAW,IAAK,MAAM,EAEpBA,IAAS,OAAY,GAAKA,EAInCpC,EAAI,QAAU,CAACoB,EAAMiB,EAAO,QAAU,CACpC,GAAIjB,aAAgB,KAClB,OAAOA,EACF,CACL,IAAMkB,EAAO,SAAS,cAAcD,CAAI,EACxC,OAAAC,EAAK,UAAYlB,EACVkB,CACT,CACF,EAGAtC,EAAI,aAAe,CAACuC,EAAMC,EAAQ,WAAa,CACzC,CAACD,GAAQ,CAACA,EAAK,gBACnB,MAAM,KAAKA,EAAK,cAAc,QAAQ,EAAE,QAAQE,GAAS,CACvDA,EAAM,UAAU,OAAOD,CAAK,CAC9B,CAAC,EACDD,EAAK,UAAU,IAAIC,CAAK,EAC1B,EAEAxC,EAAI,OAAU0C,GACL,CAAC,IAAK,OAAQ,IAAI,EAAE,SAAS,OAAOA,CAAG,EAAE,YAAY,CAAC,EAI/D1C,EAAI,IAAM,IACVA,EAAI,IAAM,IACD,YAAc,EAAEA,EAAI,KAAK,SAAS,EAAE,EAO7CA,EAAI,YAAc,EAClBA,EAAI,QAAU,CAAC,EACfA,EAAI,QAAU,CAAC2C,EAAMxB,EAAO,CAAC,IAAM,CACjC,GAAI,OAAOwB,GAAQ,WAAY,CAC7B,IAAMC,EAAM,EAAE5C,EAAI,YAElB,OAAImB,EAAK,QAEPnB,EAAI,QAAQ4C,CAAG,EAAID,EAGnB3C,EAAI,QAAQ4C,CAAG,EAAI,IAAI5B,IAAS,CAC9B,IAAM6B,EAASF,EAAK,GAAG3B,CAAI,EAC3B,cAAOhB,EAAI,QAAQ4C,CAAG,EACfC,CACT,EAGK,eAAeD,CAAG,GAC3B,CACF,EAGA5C,EAAI,cAAgB,IAAM,CACxBA,EAAI,QAAU,CAAC,CACjB,EAGAA,EAAI,YAAe8C,GAAY,CAC7B,GAAKA,EAGA,IAAI,OAAOA,GAAY,WAC1B,OAAOA,EAEJ,GAAI,OAAOA,GAAY,SAAU,CAGpC,IAAMC,EAAmB,wCACnBC,EAAkB,oBAExB,OAAID,EAAiB,KAAKD,CAAO,GAAKE,EAAgB,KAAKF,CAAO,EACzD,IAAI,SAAS,UAAYA,CAAO,EAAE,EAChCA,EAAQ,SAAS,GAAG,GAAK,CAACA,EAAQ,SAAS,GAAG,EAEhD,IAAI,SAAS,8BAA8BA,CAAO,OAAO,EAGzD,IAAI,SAASA,CAAO,CAE/B,MApBE,OAAO,IAAI,CAAC,CAqBhB,EAGA9C,EAAI,QAAWE,GAAa,CACtB,SAAS,aAAe,UAC1B,SAAS,iBAAiB,mBAAoB,IAAI,CAChDA,EAAS,CACX,EAAG,CAAE,KAAM,EAAK,CAAC,EAEjBA,EAAS,CAEb,EAGAF,EAAI,KAAQiD,GAAQ,CAClB,IAAIC,EAAkBC,EAAWC,EAAMC,EAAGC,EAAGC,EAI7C,IAHAL,EAAmB,WACnBC,EAAY,SACZC,EAAOF,EACFG,EAAIC,EAAI,EAAGC,EAAMN,EAAI,OAAS,EAAI,GAAKM,EAAMD,GAAKC,EAAMD,GAAKC,EAAMF,EAAI,GAAKE,EAAM,EAAED,EAAI,EAAEA,EAC7FF,GAAQH,EAAI,WAAWI,CAAC,EACxBD,GAAQD,EAEV,OAAOC,EAAK,SAAS,EAAE,EAAE,WAAW,IAAK,EAAE,CAC7C,EAEApD,EAAI,IAAM,CAACwD,EAAKrC,EAAO,CAAC,EAAGsC,EAAO,KAAO,CACvC,IAAMC,EAAO,mBAAmB,KAAK,UAAUvC,CAAI,CAAC,EACpD,MAAO,IAAIqC,CAAG,gBAAgBE,CAAI,KAAKD,CAAI,KAAKD,CAAG,GAIrD,EAGAxD,EAAI,UAAY,CAAC2C,EAAMgB,IAAa,CAClCA,IAAa,IAERhB,EAAK,GACR,WAAW,IAAI,CACb3C,EAAI,UAAU2C,EAAMgB,CAAQ,CAC9B,EAAGA,CAAQ,CAEf,EAGA,IAAMC,EAAyB,IAG/B5D,EAAI,SAAW,CAAC2C,EAAMkB,EAAQD,IAA2B,CACvD,IAAIE,EAAU,EACVC,EAEJ,OAAO,YAAY/C,EAAM,CACvB,IAAMgD,EAAM,KAAK,IAAI,EAEjBA,EAAMF,GAAWD,GACnBlB,EAAK,MAAM,KAAM3B,CAAI,EACrB8C,EAAUE,IAEV,aAAaD,CAAO,EACpBA,EAAU,WAAW,IAAM,CACzBpB,EAAK,MAAM,KAAM3B,CAAI,EACrB8C,EAAU,KAAK,IAAI,CACrB,EAAGD,GAASG,EAAMF,EAAQ,EAE9B,CACF,CAEF,EChbA,IAAMG,GAAY,CAAC,EAEZC,GAASC,GAAQ,CACtBA,EAAI,SAAW,CAACC,EAAMC,IAAY,CAChC,GAAIA,EACFJ,GAAUG,CAAI,EAAIC,MAElB,eAAO,QAAQJ,EAAS,EAAE,QAAQ,CAAC,CAACK,EAAKC,CAAG,IAAI,CAC9CH,EAAOA,EAAK,WAAW,IAAIE,CAAG,IAAK,GAAGC,CAAG,GAAG,EAC5CH,EAAOA,EAAK,WAAW,YAAYE,CAAG,IAAK,GAAGC,CAAG,GAAG,CACtD,CAAC,EAEMH,CAEX,EAEAD,EAAI,SAAS,SAAU,2BAA2B,EAClDA,EAAI,SAAS,SAAU,mDAAmD,EAC1EA,EAAI,SAAS,UAAW,6BAA6B,CACvD,ECqBA,IAAMK,EAAM,CAACC,EAAMC,IAAU,CAE3B,GAAI,OAAOD,GAAS,SAAU,CAC5B,IAAME,EAAMH,EAAI,UAAU,IAAIC,CAAI,EAClC,GAAIE,EAAK,OAAOA,EAChBH,EAAI,aAAa,sBAAsBC,CAAI,cAAc,EACzD,MACF,CAEA,GAAI,CAACA,EAAM,CACTD,EAAI,aAAa,SAAS,EAC1B,MACF,CAGA,GAAIE,EAAO,CAMT,GALiB,OAAOA,GAAU,YAChC,CAAC,YAAY,KAAKA,EAAM,SAAS,CAAC,GAClC,CAAC,iBAAiB,KAAKA,EAAM,SAAS,CAAC,EAG3B,CACZ,IAAME,EAAO,MACV,KAAK,SAAS,iBAAiB,YAAYH,CAAI,EAAE,CAAC,EAClD,OAAOI,GAAKA,EAAE,GAAG,EACpB,OAAAD,EAAK,QAAQE,GAAMJ,EAAMI,EAAG,GAAG,CAAC,EACzBF,CACT,CAGA,OAAI,OAAOF,GAAU,WACZF,EAAI,KAAKC,EAAMC,CAAK,EAItBK,EAAQN,EAAMC,CAAK,CAC5B,CAGA,IAAMM,EAAOP,EAAK,SACdA,EAAK,QAAQ,MAAM,EACnB,SAAS,cAAcA,EAAK,SAAS,GAAG,EAAIA,EAAO,YAAYA,CAAI,EAAE,EAEzE,GAAI,CAACO,EAAM,CACTR,EAAI,aAAa,SAASC,CAAI,cAAc,EAC5C,MACF,CAEA,GAAI,CAACO,EAAK,IAAK,CACbR,EAAI,aAAa,SAASC,CAAI,wBAAwB,EACtD,MACF,CAEA,OAAOO,EAAK,GACd,EAOAR,EAAI,QAAU,CAAC,EAGfA,EAAI,cAAgB,EAGpBA,EAAI,UAAY,IAAI,IAQpBA,EAAI,KAAO,CAACS,EAAOR,IAAS,CAC1B,IAAIO,EAAO,OAAOC,GAAU,SAAW,SAAS,KAAK,cAAcA,CAAK,EAAIA,EAGxE,OAAOD,EAAK,KAAQ,aAAYA,EAAOA,EAAK,CAAC,GAEjD,IAAME,EAAWT,EAAO,YAAYA,CAAI,GAAK,OACvCU,EAAcH,EAAK,QAAQE,CAAQ,EAEzC,GAAIC,GAAa,IAAK,OAAOA,EAAY,IAEzCX,EAAI,QAAQ,OAAQ,2BAA4B,CAAE,SAAUS,EAAO,SAAUD,CAAK,CAAC,CACrF,EAGAR,EAAI,KAAO,IAAM,QAAQ,IAAI,kBAAmB,OAAO,KAAKA,EAAI,SAAW,CAAC,CAAC,CAAC,EAW9EA,EAAI,SAAYY,GAASC,GAAO,IAAID,CAAI,EAQxCZ,EAAI,UAAY,CAACc,EAAUC,EAAO,CAAC,IAAM,CAGvC,GAFI,OAAOD,GAAa,aAAYA,EAAWA,EAAS,GAEpDA,EAAS,SAAS,GAAG,EAAG,CAC1B,IAAIF,EAAOE,EACR,MAAM;AAAA,CAAI,EACV,OAAOE,GAAQ,CAAE,WAAW,KAAKA,CAAI,CAAE,EACvC,KAAK;AAAA,CAAI,EAERD,EAAK,OAAMH,EAAO,UAAUA,CAAI,MACpCA,EAAOA,EAAK,QAAQ,eAAgB,YAAYG,EAAK,IAAI,EAAE,EAC3DD,EAAWd,EAAI,SAASY,CAAI,CAC9B,CAEA,OAAAZ,EAAI,QAAQ,IAAM,SAAS,KAAK,cAAc,UAAU,IAAIc,CAAQ,CAAC,EAC9DA,CACT,EAWAd,EAAI,SAAW,CAACiB,EAAQC,IAAY,CAElC,MAAM,KAAKD,EAAO,UAAU,EAAE,QAAQE,GAAQ,CAC5CD,EAAQ,aAAaC,EAAK,KAAMA,EAAK,KAAK,CAC5C,CAAC,EAEDC,GAAU,MAAMH,EAAQC,EAAS,CAAE,WAAY,WAAY,CAAC,EAG5D,IAAMG,EAAOJ,EAAO,YAChBI,GAAM,WAAa,KAAK,WAAa,CAACA,EAAK,YAAY,KAAK,GAC9DA,EAAK,OAAO,CAEhB,EAMArB,EAAI,YAAc,IAAI,IACtBA,EAAI,MAAQ,CAAC,EAObA,EAAI,QAAU,CAACsB,KAAYC,IAAS,CAElCvB,EAAI,MAAMsB,CAAO,GAAG,QAAQhB,GAAMA,EAAG,CAAC,EAAE,KAAKA,EAAG,CAAC,CAAC,EAAE,GAAGiB,CAAI,CAAC,EAG5D,IAAMC,EAAOxB,EAAI,YAAY,IAAIsB,CAAO,EACpCE,GACFA,EAAK,QAAQC,GAAO,CACdA,EAAI,MAAM,YACZA,EAAI,SAAS,KAAKA,EAAI,KAAM,GAAGF,CAAI,EAEnCC,EAAK,OAAOC,CAAG,CAEnB,CAAC,CAEL,EASAzB,EAAI,UAAY,CAACQ,EAAMkB,EAAWC,IAAa,CAEzC,OAAOD,GAAc,aACvBC,EAAWD,EACXA,EAAYlB,EACZA,EAAO,SAAS,MAEd,OAAOA,GAAS,WAClBA,EAAO,SAAS,cAAcA,CAAI,GAG/BR,EAAI,YAAY,IAAI0B,CAAS,GAChC1B,EAAI,YAAY,IAAI0B,EAAW,IAAI,GAAK,EAG1C,IAAMF,EAAOxB,EAAI,YAAY,IAAI0B,CAAS,EAG1CF,EAAK,QAAQC,GAAO,CACdA,EAAI,OAASjB,GAAQiB,EAAI,WAAaE,GAAUH,EAAK,OAAOC,CAAG,CACrE,CAAC,EAED,IAAMG,EAAe,CAAE,KAAApB,EAAM,SAAAmB,CAAS,EACtC,OAAAH,EAAK,IAAII,CAAY,EAEd,IAAMJ,EAAK,OAAOI,CAAY,CACvC,EAOA5B,EAAI,MAAQ,CACV,MAAO,IAAI,IACX,SAAU,EAEV,IAAI6B,EAAO,CACT,IAAMC,EAAM,KAAK,WACjB,YAAK,MAAM,IAAIA,EAAKD,CAAK,EAClBC,CACT,EAEA,IAAIA,EAAK,CACP,OAAO,KAAK,MAAM,IAAIA,CAAG,CAC3B,EAEA,OAAOA,EAAK,CACV,IAAMD,EAAQ,KAAK,MAAM,IAAIC,CAAG,EAChC,YAAK,MAAM,OAAOA,CAAG,EACdD,CACT,CACF,EAMA7B,EAAI,aAAe,CAACY,EAAMmB,IAAS,CAGjC,GAFAnB,EAAO,QAAQA,CAAI,GACnB,QAAQ,MAAMA,CAAI,EACdmB,EACF,MAAO,iHAAiHnB,CAAI,SAEhI,EAEAZ,EAAI,WAAcY,GAAS,CACrBZ,EAAI,KACN,QAAQ,IAAI,QAAQ,OAAOY,CAAI,EAAE,UAAU,EAAG,GAAG,CAAC,EAAE,CAExD,EAGAZ,EAAI,QAAU,CAACgC,EAAMC,EAASC,IAAY,CACxC,IAAMC,EAAW,OAAOH,CAAI,KAAKC,GAAS,WAAW,GAAKA,CAAO,GACjE,eAAQ,MAAME,EAAUD,GAAW,EAAE,EAC9BC,CACT,EASAC,GAAapC,CAAG,EAChBqC,GAASrC,CAAG,EAEZA,EAAI,QAAUsC,EACdtC,EAAI,MAAQuC,GACZvC,EAAI,IAAMwC,GACVxC,EAAI,aAAeyC,GAEnBzC,EAAI,QAAQ,IAAMA,EAAI,WAAW,oCAAoC,CAAC,EAEtE,IAAO0C,EAAQ1C,ECvTX,OAAO,OAAW,MACpB,OAAO,QAAU2C,EACjB,OAAO,IAAMC,GAIf,iCAOA,IAAMC,GAAW,IAAI,iBAAiBC,GAAa,CACjD,OAAW,CAAE,WAAAC,EAAY,aAAAC,CAAa,IAAKF,EAEzCC,EAAW,QAAQE,GAAQ,CACrBA,EAAK,WAAa,IAElBA,EAAK,UAAU,sCAAsC,IACvDL,EAAI,QAAQK,CAAI,EAChBA,EAAK,OAAO,GAGdA,EAAK,mBAAmB,sCAAsC,EAAE,QAAQC,GAAO,CAC7EN,EAAI,QAAQM,CAAG,EACfA,EAAI,OAAO,CACb,CAAC,EACH,CAAC,EAGDF,EAAa,QAAQC,GAAQ,CAC3B,GAAIA,EAAK,WAAa,EAAG,OAGzB,IAAME,EAAWC,GAAO,CAClBA,EAAG,MACLR,EAAI,UAAU,OAAOQ,EAAG,IAAI,GAAG,EAC/BA,EAAG,IAAI,aAAa,EAExB,EAGAD,EAAQF,CAAI,EAGZA,EAAK,mBAAmB,MAAM,GAAG,QAAQE,CAAO,CAClD,CAAC,CAEL,CAAC,EAEDN,GAAS,QAAQ,SAAS,gBAAiB,CACzC,UAAW,GACX,QAAS,EACX,CAAC,EAMD,IAAOQ,GAAQT",
  "names": ["defaults_exports", "__export", "loadDefaults", "init_defaults", "__esmMin", "props", "tag", "data", "dom", "html", "nodeName", "el", "memoStore", "MEMO_STORE_MAX_SIZE", "storedNode", "oldestKey", "contentNode", "n", "name", "attrs", "data", "parts", "c", "node", "k", "v", "value", "parseLoopBinding", "binding", "match", "s", "getLoopVarNames", "parsed", "names", "buildCollectionExpr", "collection", "buildLoopParams", "destructure", "indexName", "params", "index", "isArrowFunction", "expr", "transformArrowToHandler", "loopVars", "arrowMatch", "body", "eventParam", "eventRegex", "varName", "varRegex", "funcName", "extractBracedExpression", "text", "startIndex", "depth", "i", "char", "quote", "getAttributeContext", "pos", "j", "attrEnd", "attrName", "getEventAttributeContext", "attr", "createSvelteTemplate", "opts", "componentName", "blocks", "_", "name", "content", "result", "ifStack", "loopVarStack", "loopStack", "expression", "endIndex", "cond", "loopInfo", "hasElse", "isEach", "rest", "asIdx", "inIdx", "collectionExpr", "loopParams", "allLoopVars", "handler", "funcBody", "tplFunc", "ctx", "e", "cache", "createTemplate", "text", "opts", "hasLegacySyntax", "convertLegacySyntax", "fn", "createSvelteTemplate", "hasLegacySyntax", "text", "convertLegacySyntax", "componentName", "FezBase", "node", "newNode", "attrs", "attr", "key", "val", "newVal", "e", "data", "formNode", "formData", "formObject", "value", "n", "kind", "message", "context", "name", "v", "callback", "text", "base", "func", "template", "nodeName", "renderedTpl", "createTemplate", "fetchAttr", "target", "classes", "lastClass", "c", "isCb", "eventName", "newEl", "isSlot", "oldEl", "candidates", "el", "parent", "isNested", "child", "newMemoEl", "newMemoElKey", "storedNode", "oldMemoEl", "oldMemoElKey", "method", "obj", "handler", "o", "k", "oldValue", "createReactive", "property", "receiver", "currentValue", "result", "selector", "children", "tmpContainer", "prop", "klass", "inNode", "nodes", "delay", "throttledFunc", "observer", "tick", "intervalID", "channel", "args", "handle_publish", "component", "sub", "comp", "source", "e", "t", "a", "r", "l", "s", "n", "o", "c", "i", "p", "u", "d", "f", "g", "b", "m", "h", "y", "gobber_default", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromAttributes", "toAttributes", "fromAttribute", "syncClassList", "error", "i", "toAttribute", "syncInputValue", "fromClasses", "toClasses", "cls", "syncBooleanAttribute", "attributeName", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "log", "mergeDefaults", "finalConfig", "createIdMap", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "log_pretty_print", "html", "parts", "p", "indent", "lines", "i", "part", "nextPart", "nextNextPart", "actualIndent", "LOG", "logs", "logTypes", "currentIndex", "renderContent", "e", "dialog", "button", "createLogButton", "showLogDialog", "btn", "d", "scrollTop", "savedIndex", "buttons", "_", "bgColor", "o", "originalType", "key", "value", "dump_default", "highlightAll", "port", "existingHighlights", "el", "componentName", "componentType", "overlay", "rect", "scrollTop", "scrollLeft", "label", "e", "event", "highlight_all_default", "SELF_CLOSING_TAGS", "attrObserver", "mutations", "mutation", "fez", "name", "value", "connect", "klass", "Fez", "ensureFezBase", "slotTag", "createTemplate", "shouldRenderFast", "connectNode", "FezBase", "closeCustomTags", "instance", "newKlass", "props", "p", "prop", "configMap", "from", "to", "html", "match", "tag", "attrs", "node", "attr", "klassFast", "nodeName", "newNode", "form", "e", "key", "compile", "tagName", "html", "compileBulk", "classCode", "generateClassCode", "compileToClass", "hideCustomElement", "executeClassCode", "data", "node", "fezName", "compileFromUrl", "n", "url", "content", "fezElements", "el", "name", "error", "compileToClass", "html", "result", "lines", "block", "type", "line", "processHeadElements", "headHtml", "container", "node", "script", "attr", "generateClassCode", "tagName", "parts", "klass", "css", "before", "after", "executeClassCode", "code", "hideCustomElement", "styleEl", "allTags", "GlobalState", "key", "value", "oldValue", "listeners", "comp", "subscribers", "func", "error", "component", "target", "keyOrFunc", "keySubscribers", "global_state_default", "utility_default", "Fez", "config", "callback", "n", "src", "attributes", "elementType", "script", "error", "key", "value", "existingNode", "element", "module", "FETCH_CACHE_TTL", "FETCH_CACHE_MAX_SIZE", "args", "method", "url", "opts", "data", "params", "formData", "cacheKey", "cached", "processResponse", "response", "storeInCache", "oldestKey", "color", "percent", "num", "amt", "R", "G", "B", "text", "name", "root", "node", "klass", "child", "val", "func", "uid", "result", "pointer", "arrowFuncPattern", "functionPattern", "str", "FNV_OFFSET_BASIS", "FNV_PRIME", "hash", "i", "j", "ref", "tag", "html", "json", "pingRate", "DEFAULT_THROTTLE_DELAY", "delay", "lastRun", "timeout", "now", "CssMixins", "css_mixin_default", "Fez", "name", "content", "key", "val", "Fez", "name", "klass", "fez", "list", "n", "el", "connect", "node", "onode", "selector", "closestNode", "text", "gobber_default", "cssClass", "opts", "line", "target", "newNode", "attr", "Idiomorph", "next", "channel", "args", "subs", "sub", "eventName", "callback", "subscription", "value", "key", "show", "kind", "message", "context", "errorMsg", "utility_default", "css_mixin_default", "compile", "global_state_default", "dump_default", "highlight_all_default", "root_default", "FezBase", "root_default", "observer", "mutations", "addedNodes", "removedNodes", "node", "tpl", "cleanup", "el", "fez_default"]
}
