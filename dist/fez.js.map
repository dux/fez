{
  "version": 3,
  "sources": ["../src/fez/defaults.js", "../src/fez/lib/n.js", "../src/fez/lib/svelte-template-lib.js", "../src/fez/lib/svelte-template.js", "../src/fez/lib/template.js", "../src/fez/lib/pubsub.js", "../src/fez/instance.js", "../src/fez/vendor/gobber.js", "../src/fez/vendor/idiomorph.js", "../src/fez/utils/dump.js", "../src/fez/utils/highlight_all.js", "../src/fez/connect.js", "../src/fez/compile.js", "../src/fez/lib/global-state.js", "../src/fez/lib/localstorage.js", "../src/fez/lib/await-helper.js", "../src/fez/lib/index.js", "../src/fez/utility.js", "../src/fez/utils/css_mixin.js", "../src/fez/root.js", "../src/fez.js"],
  "sourcesContent": ["// Wrap defaults in a function to avoid immediate execution\nconst loadDefaults = () => {\n  // include fez component by name\n  //<fez-component name=\"some-node\" :props=\"fez.props\"></fez-component>\n  Fez(\n    \"fez-component\",\n    class {\n      init(props) {\n        const tag = document.createElement(props.name);\n        tag.props = props.props || props[\"data-props\"] || props;\n\n        while (this.root.firstChild) {\n          this.root.parentNode.insertBefore(\n            this.root.lastChild,\n            tag.nextSibling,\n          );\n        }\n\n        this.root.innerHTML = \"\";\n        this.root.appendChild(tag);\n      }\n    },\n  );\n\n  // include remote data from url\n  // <fez-include src=\"./demo/fez/ui-slider.html\"></fez-include>\n  Fez(\n    \"fez-include\",\n    class {\n      init(props) {\n        Fez.fetch(props.src, (data) => {\n          const dom = Fez.domRoot(data);\n          Fez.head(dom); // include scripts and load fez components\n          this.root.innerHTML = dom.innerHTML;\n        });\n      }\n    },\n  );\n\n  // Show node only if test validates\n  // <fez-if if=\"window.foo\">...\n  Fez(\n    \"fez-if\",\n    class {\n      init(props) {\n        const test = new Function(`return (${props.if || props.test})`);\n        if (!test()) {\n          this.root.remove();\n        }\n      }\n    },\n  );\n\n  // Render all components with their demos\n  // <fez-demo></fez-demo>\n  // <fez-demo name=\"ui-clock\"></fez-demo>\n  // Also supports ?fez=NAME query string\n  Fez(\n    \"fez-demo\",\n    class {\n      init(props) {\n        this.state.ready = false;\n        this.state.components = [];\n        this.state.filtered = false;\n        this.state.showAllUrl = \"\";\n\n        // Check for name from props or query string\n        const urlParams = new URLSearchParams(window.location.search);\n        const name = props.name || urlParams.get(\"fez\");\n\n        // If filtering, store URL without ?fez param\n        if (urlParams.get(\"fez\")) {\n          const url = new URL(window.location.href);\n          url.searchParams.delete(\"fez\");\n          this.state.showAllUrl = url.pathname + url.search;\n          this.state.filtered = true;\n        }\n\n        // Wait for components to be loaded, then render\n        const checkReady = () => {\n          // If name provided, render only that component\n          if (name) {\n            if (Fez.index[name]?.demo) {\n              this.state.components = [name];\n              this.state.ready = true;\n            } else {\n              setTimeout(checkReady, 100);\n            }\n          } else {\n            // Render all components that have demos\n            const names = Fez.index.withDemo().sort();\n            if (names.length > 0) {\n              this.state.components = names;\n              this.state.ready = true;\n            } else {\n              setTimeout(checkReady, 100);\n            }\n          }\n        };\n        checkReady();\n      }\n\n      showHtml(name) {\n        const html = Fez.index[name]?.demo || \"No demo HTML\";\n        Fez.log(\"Demo HTML: \" + name + \"\\n\\n\" + html);\n      }\n\n      showFez(name) {\n        Fez.log(\n          \"Fez source: \" +\n            name +\n            \"\\n\\n\" +\n            (Fez.index[name]?.source || \"Source not available\"),\n        );\n      }\n\n      openSingle(name) {\n        const url = new URL(window.location.href);\n        url.searchParams.set(\"fez\", name);\n        window.location.href = url.toString();\n      }\n\n      openCodePen(name) {\n        const demo = Fez.index[name]?.demo || \"\";\n        const code = Fez.index[name]?.source || \"\";\n        const body = [\n          '<link rel=\"stylesheet\" href=\"//cdn.simplecss.org/simple.css\" />\\n<scr' +\n            'ipt src=\"//dux.github.io/fez/dist/fez.js\"></scr' +\n            \"ipt>\",\n          \"<!-- FEZ code start -->\\n<x\" +\n            `mp fez=\"${name}\">\\n${code}\\n</xm` +\n            \"p>\\n<!-- FEZ code end -->\",\n          `<!-- HTML code start -->\\n${demo}\\n<!-- HTML code end -->`,\n        ];\n\n        const data = {\n          title: \"Fez component - \" + name,\n          html: body.join(\"\\n\\n\"),\n          css: \"body { padding-top: 50px; }\",\n          js: \"\",\n          editors: \"100\",\n        };\n\n        const form = document.createElement(\"form\");\n        form.method = \"POST\";\n        form.action = \"https://codepen.io/pen/define\";\n        form.target = \"_blank\";\n\n        const input = document.createElement(\"input\");\n        input.type = \"hidden\";\n        input.name = \"data\";\n        input.value = JSON.stringify(data);\n\n        form.appendChild(input);\n        document.body.appendChild(form);\n        form.submit();\n        document.body.removeChild(form);\n      }\n\n      renderDemo(el) {\n        const name = el.dataset.name;\n        Fez.index.apply(name, el);\n      }\n\n      renderInfo(el) {\n        const name = el.dataset.name;\n        const data = Fez.index.get(name);\n        if (data.info) {\n          el.innerHTML = data.info.innerHTML;\n        } else {\n          el.innerHTML = \"<em>No info available</em>\";\n        }\n      }\n\n      CSS() {\n        return `:fez {\n        display: block;\n        font-family: system-ui, -apple-system, sans-serif;\n      }\n      .fez-demo-item {\n        margin-bottom: 40px;\n      }\n      .fez-demo-title {\n        display: flex;\n        align-items: center;\n        gap: 15px;\n        font-size: 18px;\n        font-weight: 600;\n        margin: 0 0 25px 0;\n        &::before {\n          content: '';\n          flex: 1;\n          height: 1px;\n          background: #ddd;\n        }\n        &::after {\n          content: '';\n          flex: 1;\n          height: 1px;\n          background: #ddd;\n        }\n        .fez-demo-show-all, .fez-demo-open-single {\n          font-size: 14px;\n          font-weight: normal;\n          color: #666;\n          text-decoration: none;\n          cursor: pointer;\n          &:hover { text-decoration: underline; }\n        }\n      }\n      .fez-demo-cols {\n        display: flex;\n        gap: 40px;\n        @media (max-width: 768px) {\n          flex-direction: column;\n          gap: 20px;\n        }\n      }\n      .fez-demo-left, .fez-demo-right {\n        flex: 1;\n        min-width: 0;\n        overflow: visible;\n      }\n      .fez-demo-content {\n        min-height: 50px;\n      }\n      .fez-demo-info {\n        background: #fff;\n        border: 1px solid #ddd;\n        border-radius: 6px;\n        padding: 20px;\n        line-height: 1.6;\n        ul { margin: 0; padding-left: 20px; }\n        code { background: #e8e8e8; padding: 2px 5px; border-radius: 3px; font-size: 13px; }\n      }\n      .fez-demo-buttons {\n        margin-top: 30px;\n        display: flex;\n        gap: 10px;\n      }\n      .fez-demo-btn {\n        padding: 8px 16px;\n        border: 1px solid #ccc;\n        background: #fff;\n        border-radius: 4px;\n        cursor: pointer;\n        &:hover { background: #f0f0f0; }\n      }`;\n      }\n\n      HTML() {\n        return `{#if state.ready}\n        {#each state.components as name}\n          <div class=\"fez-demo-item\">\n            <h2 class=\"fez-demo-title\">{name}{#if state.filtered} <a href=\"{state.showAllUrl}\" class=\"fez-demo-show-all\">show all</a>{:else} <a onclick=\"fez.openSingle('{name}')\" class=\"fez-demo-open-single\">open</a>{/if}</h2>\n            <div class=\"fez-demo-cols\">\n              <div class=\"fez-demo-left\">\n                <div class=\"fez-demo-content\" data-name={name} fez-use=\"renderDemo\"></div>\n              </div>\n              <div class=\"fez-demo-right\">\n                <div class=\"fez-demo-info\" data-name={name} fez-use=\"renderInfo\"></div>\n                <div class=\"fez-demo-buttons\">\n                  <button class=\"fez-demo-btn\" onclick=\"fez.showHtml('{name}')\">Demo HTML</button>\n                  <button class=\"fez-demo-btn\" onclick=\"fez.showFez('{name}')\">Fez Component</button>\n                  <button class=\"fez-demo-btn\" onclick=\"fez.openCodePen('{name}')\">CodePen</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        {/each}\n      {:else}\n        <div style=\"padding: 40px; text-align: center; color: #888;\">Loading components...</div>\n      {/if}`;\n      }\n    },\n  );\n};\n\n// Only load defaults if Fez is available and DOM exists\nif (\n  typeof Fez !== \"undefined\" &&\n  Fez &&\n  typeof document !== \"undefined\" &&\n  document.head\n) {\n  loadDefaults();\n}\n\n// Export for use in tests\nexport { loadDefaults };\n", "// Exposes node building method, that gets node name, attrs and body.\n// n('span', {id: id}), n('.foo', {id: id}, body), n('.foo', {id: id}, [...])\n// * you can switch places for attrs and body, and body can be list of nodes\n// * n('.foo.bar') -> n('div', { class: 'foo bar' })\n//\n// copyright @dux, 2024\n// Licence MIT\n\nexport default function n(name, attrs = {}, data) {\n  if (typeof attrs === 'string') {\n    [attrs, data] = [data, attrs]\n    attrs ||= {}\n  }\n\n  if (attrs instanceof Node) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (Array.isArray(name)) {\n    data = name\n    name = 'div'\n  }\n\n  if (typeof attrs !== 'object' || Array.isArray(attrs)) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (name.includes('.')) {\n    const parts = name.split('.')\n    name = parts.shift() || 'div'\n    const c = parts.join(' ');\n    if (attrs.class) {\n      attrs.class += ` ${c}`;\n    } else {\n      attrs.class = c\n    }\n  }\n\n  const node = document.createElement(name);\n\n  for (const [k, v] of Object.entries(attrs)) {\n    if (typeof v === 'function') {\n      node[k] = v.bind(this)\n    } else {\n      const value = String(v).replaceAll('fez.', this.fezHtmlRoot);\n      node.setAttribute(k, value)\n    }\n  }\n\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const n of data) {\n        node.appendChild(n)\n      }\n    } else if (data instanceof Node) {\n      node.appendChild(data)\n    } else {\n      node.innerHTML = String(data)\n    }\n  }\n\n  return node\n}\n", "// Template utility functions for svelte-template parser\n// Extracted to keep main parser file smaller\n\n/**\n * Parse loop binding to get params and detect object iteration\n */\nexport function parseLoopBinding(binding) {\n  const isDestructured = binding.startsWith('[')\n\n  if (isDestructured) {\n    const match = binding.match(/^\\[([^\\]]+)\\](?:\\s*,\\s*(\\w+))?$/)\n    if (match) {\n      return {\n        params: match[1].split(',').map(s => s.trim()),\n        indexParam: match[2] || null,\n        isDestructured: true\n      }\n    }\n  }\n\n  const parts = binding.split(',').map(s => s.trim())\n\n  // 2 params without brackets = destructuring\n  // Runtime auto-converts: Array.isArray(c) ? c : Object.entries(c)\n  if (parts.length === 2) {\n    return { params: parts, indexParam: null, isDestructured: true }\n  }\n\n  return { params: parts, indexParam: null, isDestructured: false }\n}\n\n/**\n * Get loop variable names from binding\n */\nexport function getLoopVarNames(binding) {\n  const parsed = parseLoopBinding(binding)\n  const names = [...parsed.params]\n  if (parsed.indexParam) names.push(parsed.indexParam)\n  // Add implicit i for single-param\n  if (parsed.params.length === 1 && !names.includes('i')) names.push('i')\n  return names\n}\n\n/**\n * Get loop item variables (non-index) from binding\n * These are variables that could be objects/arrays (not primitives like indices)\n */\nexport function getLoopItemVars(binding) {\n  const parsed = parseLoopBinding(binding)\n  // For 2-param destructuring: [value, index] - only first is item var\n  if (parsed.isDestructured && parsed.params.length === 2) {\n    return [parsed.params[0]]\n  }\n  // For other destructured bindings, all params are item vars\n  if (parsed.isDestructured) {\n    return parsed.params\n  }\n  // For {#each items as item, index}, only 'item' is the item var\n  // For {#each obj as key, value, index}, 'key' and 'value' are item vars\n  if (parsed.params.length >= 3) {\n    // Last param is index, rest are item vars\n    return parsed.params.slice(0, -1)\n  }\n  if (parsed.params.length === 2) {\n    // Could be \"item, index\" - first is item, second is index\n    return [parsed.params[0]]\n  }\n  // Single param is the item var\n  return parsed.params\n}\n\n/**\n * Build collection expression for iteration\n */\nexport function buildCollectionExpr(collection, binding) {\n  const parsed = parseLoopBinding(binding)\n\n  // 2-param destructuring uses Fez.toPairs for unified array/object handling\n  // Array: ['a', 'b'] \u2192 [['a', 0], ['b', 1]] (value, index)\n  // Object: {x: 1} \u2192 [['x', 1]] (key, value)\n  if (parsed.isDestructured && parsed.params.length === 2) {\n    return `Fez.toPairs(${collection})`\n  }\n\n  // 3+ params: object iteration with explicit index\n  if (parsed.isDestructured || parsed.params.length >= 3) {\n    return `((_c)=>Array.isArray(_c)?_c:(_c&&typeof _c===\"object\")?Object.entries(_c):[])(${collection})`\n  }\n\n  return `(${collection}||[])`\n}\n\n/**\n * Build loop callback params\n */\nexport function buildLoopParams(binding) {\n  const parsed = parseLoopBinding(binding)\n\n  if (parsed.isDestructured) {\n    const destructure = '[' + parsed.params.join(', ') + ']'\n    const indexName = parsed.indexParam || (parsed.params.includes('i') ? '_i' : 'i')\n    return destructure + ', ' + indexName\n  }\n\n  if (parsed.params.length >= 3) {\n    const params = [...parsed.params]\n    const index = params.pop()\n    return '[' + params.join(', ') + '], ' + index\n  }\n\n  if (parsed.params.length === 2) {\n    return parsed.params.join(', ')\n  }\n\n  // If loop var is 'i', use '_i' for index to avoid collision\n  const indexName = parsed.params[0] === 'i' ? '_i' : 'i'\n  return parsed.params[0] + ', ' + indexName\n}\n\n/**\n * Check if expression is an arrow function\n */\nexport function isArrowFunction(expr) {\n  // Match: () => ..., (e) => ..., (e, foo) => ..., e => ...\n  return /^\\s*(\\([^)]*\\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>/.test(expr)\n}\n\n/**\n * Transform arrow function to onclick-compatible string\n * Input: \"(e) => removeTask(index)\" with loopVars = ['item', 'index', 'i']\n *\n * For loop variables that are item references (not indices), we store the handler\n * in fezGlobals to capture the value at render time. For index-only references,\n * we use simple interpolation since indices are primitives.\n *\n * Output for index-only: \"fez.removeTask(${index})\"\n * Output for item refs: \"${'Fez(' + UID + ').fezGlobals.delete(' + fez.fezGlobals.set(() => fez.removeTask(item)) + ')()'}\"\n */\nexport function transformArrowToHandler(expr, loopVars = [], loopItemVars = []) {\n  // Extract the arrow function body\n  const arrowMatch = expr.match(/^\\s*(?:\\([^)]*\\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*(.+)$/s)\n  if (!arrowMatch) return expr\n\n  let body = arrowMatch[1].trim()\n\n  // Check if arrow has event param: (e) => or (event) => or e =>\n  const paramMatch = expr.match(/^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)?\\s*(?:,\\s*[^)]+)?\\)?\\s*=>/)\n  const eventParam = paramMatch?.[1]\n  const hasEventParam = eventParam && ['e', 'event', 'ev'].includes(eventParam)\n\n  // Check if body references loop item variables (non-index vars that could be objects)\n  const usedItemVars = loopItemVars.filter(varName => {\n    const varRegex = new RegExp(`\\\\b${varName}\\\\b`)\n    return varRegex.test(body)\n  })\n\n  // If arrow function uses item variables (not just indices), store the function in fezGlobals\n  // This ensures object references are captured at render time\n  if (usedItemVars.length > 0) {\n    // Replace event param with 'event' in the body if needed\n    if (hasEventParam && eventParam !== 'event') {\n      const eventRegex = new RegExp(`\\\\b${eventParam}\\\\b`, 'g')\n      body = body.replace(eventRegex, 'event')\n    }\n\n    // Prefix bare function calls with fez.\n    body = body.replace(/(?<![.\\w])([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g, (match, funcName) => {\n      const globals = ['console', 'window', 'document', 'Math', 'JSON', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'parseInt', 'parseFloat', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval', 'alert', 'confirm', 'prompt', 'fetch', 'event']\n      if (globals.includes(funcName)) {\n        return match\n      }\n      return `fez.${funcName}(`\n    })\n\n    // Store the function with captured loop vars, retrieve and call at click time\n    // Uses IIFE to build the string at render time with UID and set() evaluated\n    return `\\${'Fez(' + UID + ').fezGlobals.delete(' + fez.fezGlobals.set(() => ${body}) + ')()'}`\n  }\n\n  // No item variables - use simple interpolation for indices (original behavior)\n  // Replace event param with 'event' (the actual DOM event)\n  if (hasEventParam && eventParam !== 'event') {\n    const eventRegex = new RegExp(`\\\\b${eventParam}\\\\b`, 'g')\n    body = body.replace(eventRegex, 'event')\n  }\n\n  // Interpolate loop variables - they need to be evaluated at render time\n  // e.g., removeTask(index) becomes removeTask(${index})\n  for (const varName of loopVars) {\n    // Match the variable as a standalone identifier (not part of another word)\n    // and not already inside a template literal\n    const varRegex = new RegExp(`(?<!\\\\$\\\\{)\\\\b${varName}\\\\b(?![^{]*\\\\})`, 'g')\n    body = body.replace(varRegex, `\\${${varName}}`)\n  }\n\n  // Prefix bare function calls with fez.\n  body = body.replace(/(?<![.\\w])([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*\\(/g, (match, funcName) => {\n    const globals = ['console', 'window', 'document', 'Math', 'JSON', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'parseInt', 'parseFloat', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval', 'alert', 'confirm', 'prompt', 'fetch', 'event']\n    if (globals.includes(funcName)) {\n      return match\n    }\n    return `fez.${funcName}(`\n  })\n\n  return body\n}\n\n/**\n * Extract a braced expression with proper depth counting\n */\nexport function extractBracedExpression(text, startIndex) {\n  let depth = 0\n  let i = startIndex\n\n  while (i < text.length) {\n    const char = text[i]\n    if (char === '{') {\n      depth++\n    } else if (char === '}') {\n      depth--\n      if (depth === 0) {\n        return { expression: text.slice(startIndex + 1, i), endIndex: i }\n      }\n    } else if (char === '\"' || char === \"'\" || char === '`') {\n      // Skip string literals\n      const quote = char\n      i++\n      while (i < text.length && text[i] !== quote) {\n        if (text[i] === '\\\\') i++\n        i++\n      }\n    }\n    i++\n  }\n  throw new Error(`Unmatched brace at ${startIndex}`)\n}\n\n/**\n * Check if position is inside an attribute (attr={...})\n * Returns the attribute name if inside one, null otherwise\n */\nexport function getAttributeContext(text, pos) {\n  // Look backwards for pattern like: attr={\n  // We need to find the last '=' before pos that's preceded by an attribute name\n  let j = pos - 1\n  // Skip whitespace and opening brace\n  while (j >= 0 && (text[j] === '{' || text[j] === ' ' || text[j] === '\\t')) j--\n  if (j >= 0 && text[j] === '=') {\n    // Found '=', now look for attribute name\n    j--\n    while (j >= 0 && (text[j] === ' ' || text[j] === '\\t')) j--\n    // Extract attribute name\n    let attrEnd = j + 1\n    while (j >= 0 && /[a-zA-Z0-9_:-]/.test(text[j])) j--\n    const attrName = text.slice(j + 1, attrEnd)\n    if (attrName && /^[a-zA-Z]/.test(attrName)) {\n      return attrName.toLowerCase()\n    }\n  }\n  return null\n}\n\n/**\n * Check if position is inside an event attribute (onclick=, onchange=, etc.)\n * Returns the attribute name if inside one, null otherwise\n */\nexport function getEventAttributeContext(text, pos) {\n  const attr = getAttributeContext(text, pos)\n  if (attr && /^on[a-z]+$/.test(attr)) {\n    return attr\n  }\n  return null\n}\n", "// Svelte-like template parser for Fez\n// Compiles to a single function that returns HTML string\n//\n// Supports:\n//   {#if cond}...{:else if cond}...{:else}...{/if}\n//   {#unless cond}...{/unless}\n//   {#each items as item}...{/each}        - implicit index `i` available\n//   {#each items as item, index}...{/each} - explicit index name\n//   {#for item in items}...{/for}          - implicit index `i` available\n//   {#for item, index in items}...{/for}   - explicit index name\n//   {#each obj as key, value, index}       - object iteration (3 params)\n//   {#await promise}...{:then value}...{:catch error}...{/await}\n//   {@html rawContent}                     - unescaped HTML\n//   {@json obj}                            - debug JSON output\n//   {expression}                           - escaped expression\n\nimport {\n  getLoopVarNames,\n  getLoopItemVars,\n  buildCollectionExpr,\n  buildLoopParams,\n  isArrowFunction,\n  transformArrowToHandler,\n  extractBracedExpression,\n  getAttributeContext,\n  getEventAttributeContext\n} from './svelte-template-lib.js'\n\n/**\n * Compile template to a function that returns HTML string\n *\n * @param {string} text - Template source\n * @param {Object} opts - Options\n * @param {string} opts.name - Component name for error messages\n */\nexport default function createSvelteTemplate(text, opts = {}) {\n  const componentName = opts.name || 'unknown'\n\n  try {\n    // Decode HTML entities that might have been encoded by browser DOM\n    text = text\n      .replaceAll('&#x60;', '`')\n      .replaceAll('&lt;', '<')\n      .replaceAll('&gt;', '>')\n      .replaceAll('&amp;', '&')\n\n    // Process block definitions and references before parsing\n    const blocks = {}\n    text = text.replace(/\\{@block\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/block\\}/g, (_, name, content) => {\n      blocks[name] = content\n      return ''\n    })\n    text = text.replace(/\\{@block:(\\w+)\\}/g, (_, name) => blocks[name] || '')\n\n    // Convert :attr=\"expr\" to use Fez(UID).fezGlobals for passing values through DOM\n    // This allows loop variables to be passed as props to child components\n    // :file=\"el.file\" -> :file={`Fez(${UID}).fezGlobals.delete(${fez.fezGlobals.set(el.file)})`}\n    // Uses Fez(UID) so child component can find parent's fezGlobals\n    text = text.replace(/:(\\w+)=\"([^\"{}]+)\"/g, (match, attr, expr) => {\n      // Only convert if expr looks like a variable access (not a string literal)\n      if (/^[\\w.[\\]]+$/.test(expr.trim())) {\n        return `:${attr}={\\`Fez(\\${UID}).fezGlobals.delete(\\${fez.fezGlobals.set(${expr})})\\`}`\n      }\n      return match\n    })\n\n    // Remove HTML comments\n    text = text.replace(/<!--[\\s\\S]*?-->/g, '')\n\n    // Normalize whitespace between tags\n    text = text.replace(/>\\s+</g, '><').trim()\n\n    // Convert self-closing custom elements to paired tags\n    // <ui-icon name=\"foo\" /> -> <ui-icon name=\"foo\"></ui-icon>\n    // Custom elements contain a hyphen in the tag name\n    text = text.replace(/<([a-z][a-z0-9]*-[a-z0-9-]*)([^>]*?)\\s*\\/>/gi, '<$1$2></$1>')\n\n    // Convert self-closing <slot /> to <slot></slot>\n    text = text.replace(/<slot\\s*\\/>/gi, '<slot></slot>')\n\n    // Parse and build template literal\n    let result = ''\n    let i = 0\n    const ifStack = []  // Track if blocks have else\n    const loopVarStack = []  // Track all loop variables for arrow function transformation\n    const loopItemVarStack = []  // Track item vars (non-index) that could be objects\n    const loopStack = []  // Track loop info for :else support\n    const awaitStack = []  // Track await blocks for :then/:catch\n    let awaitCounter = 0  // Unique ID for each await block\n\n    while (i < text.length) {\n      // Skip JavaScript template literals (backtick strings)\n      // Content inside backticks should not be processed as Fez expressions\n      if (text[i] === '`') {\n        result += '\\\\`'\n        i++\n        // Copy everything until closing backtick\n        while (i < text.length && text[i] !== '`') {\n          if (text[i] === '\\\\') {\n            // Handle escaped characters\n            result += '\\\\\\\\'\n            i++\n            if (i < text.length) {\n              if (text[i] === '`') {\n                result += '\\\\`'\n              } else if (text[i] === '$') {\n                result += '\\\\$'\n              } else {\n                result += text[i]\n              }\n              i++\n            }\n          } else if (text[i] === '$' && text[i + 1] === '{') {\n            // Keep JS template literal interpolation as-is (escape $ for outer template)\n            result += '\\\\${'\n            i += 2\n            // Copy until matching }\n            let depth = 1\n            while (i < text.length && depth > 0) {\n              if (text[i] === '{') depth++\n              else if (text[i] === '}') depth--\n              if (depth > 0 || text[i] !== '}') {\n                if (text[i] === '`') result += '\\\\`'\n                else if (text[i] === '\\\\') result += '\\\\\\\\'\n                else result += text[i]\n              } else {\n                result += '}'\n              }\n              i++\n            }\n          } else {\n            // Regular character inside backticks - escape special chars for outer template\n            if (text[i] === '$') {\n              result += '\\\\$'\n            } else {\n              result += text[i]\n            }\n            i++\n          }\n        }\n        if (i < text.length) {\n          result += '\\\\`'\n          i++\n        }\n        continue\n      }\n\n      // Escaped brace\n      if (text[i] === '\\\\' && text[i + 1] === '{') {\n        result += '{'\n        i += 2\n        continue\n      }\n\n      // Expression or directive\n      if (text[i] === '{') {\n        const { expression, endIndex } = extractBracedExpression(text, i)\n        const expr = expression.trim()\n\n        // Check if this is a JavaScript object literal (e.g., {d: 'top'}, {foo: 1, bar: 2})\n        // Object literals start with key: where key is identifier or quoted string\n        if (/^(\\w+|\"\\w+\"|'\\w+')\\s*:/.test(expr)) {\n          // Keep object literal as-is in the output\n          result += '{' + expression + '}'\n          i = endIndex + 1\n          continue\n        }\n\n        // Block directives\n        if (expr.startsWith('#if ')) {\n          const cond = expr.slice(4)\n          result += '${(' + cond + ') ? `'\n          ifStack.push(false)  // No else yet\n        }\n        else if (expr.startsWith('#unless ')) {\n          const cond = expr.slice(8)\n          result += '${!(' + cond + ') ? `'\n          ifStack.push(false)  // No else yet\n        }\n        else if (expr === ':else') {\n          // Check if we're inside a loop (for empty list handling)\n          if (loopStack.length > 0 && !ifStack.length) {\n            // :else inside a loop - for empty array case\n            const loopInfo = loopStack[loopStack.length - 1]\n            loopInfo.hasElse = true\n            result += '`).join(\"\") : `'\n          } else {\n            // :else inside an if block\n            result += '` : `'\n            ifStack[ifStack.length - 1] = true  // Has else\n          }\n        }\n        else if (expr.startsWith(':else if ')) {\n          const cond = expr.slice(9)\n          result += '` : (' + cond + ') ? `'\n          // Keep hasElse as false - still need final else\n        }\n        else if (expr === '/if' || expr === '/unless') {\n          const hasElse = ifStack.pop()\n          result += hasElse ? '`}' : '` : ``}'\n        }\n        else if (expr.startsWith('#each ') || expr.startsWith('#for ')) {\n          const isEach = expr.startsWith('#each ')\n          let collection, binding\n\n          if (isEach) {\n            const rest = expr.slice(6)\n            const asIdx = rest.indexOf(' as ')\n            collection = rest.slice(0, asIdx).trim()\n            binding = rest.slice(asIdx + 4).trim()\n          } else {\n            const rest = expr.slice(5)\n            const inIdx = rest.indexOf(' in ')\n            binding = rest.slice(0, inIdx).trim()\n            collection = rest.slice(inIdx + 4).trim()\n          }\n\n          const collectionExpr = buildCollectionExpr(collection, binding)\n          const loopParams = buildLoopParams(binding)\n\n          // Track loop variables for arrow function transformation\n          loopVarStack.push(getLoopVarNames(binding))\n          loopItemVarStack.push(getLoopItemVars(binding))\n\n          // Track loop info for :else support\n          // Use a wrapper that allows checking length and provides else support\n          // ((_arr) => _arr.length ? _arr.map(...).join('') : elseContent)(collection)\n          loopStack.push({ collectionExpr, hasElse: false })\n\n          result += '${((_arr) => _arr.length ? _arr.map((' + loopParams + ') => `'\n        }\n        else if (expr === '/each' || expr === '/for') {\n          loopVarStack.pop()  // Remove loop vars when exiting loop\n          loopItemVarStack.pop()  // Remove item vars when exiting loop\n          const loopInfo = loopStack.pop()\n          if (loopInfo.hasElse) {\n            // Close the else branch\n            result += '`)(' + loopInfo.collectionExpr + ')}'\n          } else {\n            // No else - just close the ternary with empty string\n            result += '`).join(\"\") : \"\")(' + loopInfo.collectionExpr + ')}'\n          }\n        }\n        // {#await promise}...{:then value}...{:catch error}...{/await}\n        else if (expr.startsWith('#await ')) {\n          const promiseExpr = expr.slice(7).trim()\n          const awaitId = awaitCounter++\n          awaitStack.push({ awaitId, promiseExpr, hasThen: false, hasCatch: false, thenVar: '_value', catchVar: '_error' })\n          // Start with pending block - Fez.await returns { status, value, error }\n          result += '${((_aw) => _aw.status === \"pending\" ? `'\n        }\n        else if (expr.startsWith(':then')) {\n          const awaitInfo = awaitStack[awaitStack.length - 1]\n          if (awaitInfo) {\n            awaitInfo.hasThen = true\n            // Extract optional value binding: {:then value} or just {:then}\n            awaitInfo.thenVar = expr.slice(5).trim() || '_value'\n            result += '` : _aw.status === \"resolved\" ? ((' + awaitInfo.thenVar + ') => `'\n          }\n        }\n        else if (expr.startsWith(':catch')) {\n          const awaitInfo = awaitStack[awaitStack.length - 1]\n          if (awaitInfo) {\n            awaitInfo.hasCatch = true\n            // Extract optional error binding: {:catch error} or just {:catch}\n            awaitInfo.catchVar = expr.slice(6).trim() || '_error'\n            if (awaitInfo.hasThen) {\n              // Close the :then block, open :catch\n              result += '`)(_aw.value) : _aw.status === \"rejected\" ? ((' + awaitInfo.catchVar + ') => `'\n            } else {\n              // No :then block, go directly from pending to catch (skip resolved state)\n              result += '` : _aw.status === \"rejected\" ? ((' + awaitInfo.catchVar + ') => `'\n            }\n          }\n        }\n        else if (expr === '/await') {\n          const awaitInfo = awaitStack.pop()\n          if (awaitInfo) {\n            // Close the await expression\n            // The structure depends on which blocks were present:\n            // - pending + then + catch: pending ? ... : resolved ? ...then... : ...catch...\n            // - pending + then: pending ? ... : resolved ? ...then... : ``\n            // - pending + catch: pending ? ... : rejected ? ...catch... : ``\n            // - pending only: pending ? ... : ``\n            if (awaitInfo.hasThen && awaitInfo.hasCatch) {\n              result += '`)(_aw.error) : ``)(Fez.fezAwait(fez, ' + awaitInfo.awaitId + ', ' + awaitInfo.promiseExpr + '))}'\n            } else if (awaitInfo.hasThen) {\n              result += '`)(_aw.value) : ``)(Fez.fezAwait(fez, ' + awaitInfo.awaitId + ', ' + awaitInfo.promiseExpr + '))}'\n            } else if (awaitInfo.hasCatch) {\n              result += '`)(_aw.error) : ``)(Fez.fezAwait(fez, ' + awaitInfo.awaitId + ', ' + awaitInfo.promiseExpr + '))}'\n            } else {\n              // Only pending block (no :then or :catch)\n              result += '` : ``)(Fez.fezAwait(fez, ' + awaitInfo.awaitId + ', ' + awaitInfo.promiseExpr + '))}'\n            }\n          }\n        }\n        else if (expr.startsWith('@html ')) {\n          const content = expr.slice(6)\n          result += '${' + content + '}'\n        }\n        else if (expr.startsWith('@json ')) {\n          const content = expr.slice(6)\n          result += '${`<pre class=\"json\">${Fez.htmlEscape(JSON.stringify(' + content + ', null, 2))}</pre>`}'\n        }\n        else if (isArrowFunction(expr)) {\n          // Arrow function - check if we're in an event attribute\n          const eventAttr = getEventAttributeContext(text, i)\n          if (eventAttr) {\n            // Get all current loop variables\n            const allLoopVars = loopVarStack.flat()\n            const allItemVars = loopItemVarStack.flat()\n            let handler = transformArrowToHandler(expr, allLoopVars, allItemVars)\n            // Escape double quotes for HTML attribute\n            handler = handler.replace(/\"/g, '&quot;')\n            // Output as quoted attribute value with interpolation for loop vars\n            result += '\"' + handler + '\"'\n          } else {\n            // Arrow function outside event attribute - just output as expression\n            result += '${' + expr + '}'\n          }\n        }\n        else {\n          // Plain expression - check if inside attribute\n          const attrContext = getAttributeContext(text, i)\n          if (attrContext) {\n            // Inside attribute - wrap with quotes and escape\n            result += '\"${Fez.htmlEscape(' + expr + ')}\"'\n          } else {\n            // Regular content - just escape HTML\n            result += '${Fez.htmlEscape(' + expr + ')}'\n          }\n        }\n\n        i = endIndex + 1\n        continue\n      }\n\n      // Escape special characters for template literal\n      if (text[i] === '$' && text[i + 1] === '{') {\n        result += '\\\\$'\n      } else if (text[i] === '\\\\') {\n        result += '\\\\\\\\'\n      } else {\n        result += text[i]\n      }\n      i++\n    }\n\n    // Build the function\n    const funcBody = `\n      const fez = this;\n      with (this) {\n        return \\`${result}\\`\n      }\n    `\n\n    const tplFunc = new Function(funcBody)\n\n    return (ctx) => {\n      try {\n        return tplFunc.bind(ctx)()\n      } catch (e) {\n        console.error(`FEZ svelte template runtime error in <${ctx.fezName || componentName}>:`, e.message)\n        console.error('Template source:', result.substring(0, 500))\n        return ''\n      }\n    }\n  } catch (e) {\n    console.error(`FEZ svelte template compile error in <${componentName}>:`, e.message)\n    console.error('Template:', text.substring(0, 200))\n    return () => ''\n  }\n}\n", "/**\n * Fez Template Compiler\n *\n * Compiles Svelte-style templates to render functions.\n * Supports legacy {{ }} and [[ ]] syntax via auto-conversion.\n *\n * Syntax:\n *   {expression}        - Output escaped value\n *   {@html expr}        - Output raw HTML\n *   {@json expr}        - Output formatted JSON\n *   {#if cond}...{/if}  - Conditional\n *   {#each arr as item} - Loop\n *   {#for item in arr}  - Loop (alt syntax)\n */\n\nimport createSvelteTemplate from './svelte-template.js'\n\n// Template cache\nconst cache = new Map()\n\n// =============================================================================\n// MAIN EXPORT\n// =============================================================================\n\n/**\n * Create a template render function\n *\n * @param {string} text - Template HTML\n * @param {Object} opts - { name: componentName }\n * @returns {Function} Render function (ctx) => html\n */\nexport default function createTemplate(text, opts = {}) {\n  // Check cache\n  if (cache.has(text)) {\n    return cache.get(text)\n  }\n\n  // Convert legacy syntax if detected\n  if (hasLegacySyntax(text)) {\n    text = convertLegacySyntax(text, opts.name)\n  }\n\n  // Compile\n  const fn = createSvelteTemplate(text, opts)\n  cache.set(text, fn)\n\n  return fn\n}\n\n/**\n * Clear template cache (for testing)\n */\nexport function clearTemplateCache() {\n  cache.clear()\n}\n\n// =============================================================================\n// LEGACY SYNTAX SUPPORT\n// =============================================================================\n\n/**\n * Check if text uses old {{ }} or [[ ]] syntax\n */\nfunction hasLegacySyntax(text) {\n  return (text.includes('{{') && text.includes('}}')) ||\n         (text.includes('[[') && text.includes(']]'))\n}\n\n/**\n * Convert {{ }}/[[ ]] syntax to { } syntax\n *\n * Mappings:\n *   {{ expr }}      -> {expr}\n *   {{if cond}}     -> {#if cond}\n *   {{for x in y}}  -> {#for x in y}\n *   {{each y as x}} -> {#each y as x}\n *   {{raw x}}       -> {@html x}\n *   {{json x}}      -> {@json x}\n *   {{block x}}     -> {@block x}\n */\nfunction convertLegacySyntax(text, componentName) {\n  // Normalize [[ ]] to {{ }}\n  text = text.replaceAll('[[', '{{').replaceAll(']]', '}}')\n\n  // Blocks\n  text = text.replace(/\\{\\{block\\s+(\\w+)\\s*\\}\\}/g, '{@block $1}')\n  text = text.replace(/\\{\\{\\/block\\}\\}/g, '{/block}')\n  text = text.replace(/\\{\\{block:([\\w\\-]+)\\s*\\}\\}/g, '{@block:$1}')\n\n  // Conditionals\n  text = text.replace(/\\{\\{#?if\\s+(.*?)\\}\\}/g, '{#if $1}')\n  text = text.replace(/\\{\\{\\/if\\}\\}/g, '{/if}')\n  text = text.replace(/\\{\\{#?unless\\s+(.*?)\\}\\}/g, '{#unless $1}')\n  text = text.replace(/\\{\\{\\/unless\\}\\}/g, '{/unless}')\n  text = text.replace(/\\{\\{:?else\\}\\}/g, '{:else}')\n\n  // Loops\n  text = text.replace(/\\{\\{#?for\\s+(.*?)\\}\\}/g, '{#for $1}')\n  text = text.replace(/\\{\\{\\/for\\}\\}/g, '{/for}')\n  text = text.replace(/\\{\\{#?each\\s+(.*?)\\}\\}/g, '{#each $1}')\n  text = text.replace(/\\{\\{\\/each\\}\\}/g, '{/each}')\n\n  // Special directives\n  text = text.replace(/\\{\\{#?(?:raw|html)\\s+(.*?)\\}\\}/g, '{@html $1}')\n  text = text.replace(/\\{\\{json\\s+(.*?)\\}\\}/g, '{@json $1}')\n\n  // Expressions\n  text = text.replace(/\\{\\{\\s*(.*?)\\s*\\}\\}/g, '{$1}')\n\n  // Log warning\n  if (componentName) {\n    console.warn(`Fez component \"${componentName}\" uses old {{ ... }} notation, converting.`)\n  }\n\n  return text\n}\n", "/**\n * Fez Pub/Sub System\n *\n * Global API:\n *   Fez.subscribe('event', callback)                 // Always fires\n *   Fez.subscribe('#selector', 'event', callback)   // Fires if selector found at publish time\n *   Fez.subscribe(node, 'event', callback)          // Fires if node.isConnected\n *   Fez.publish('event', ...args)                    // Broadcast to all\n *\n * Instance API (see instance.js):\n *   this.subscribe('event', callback)               // Auto-cleanup on destroy\n *   this.publish('event', ...args)                  // Bubble to parent components\n */\n\n// =============================================================================\n// STORAGE\n// =============================================================================\n\n// Global subscriptions: channel -> Set of { selector, node, callback }\nconst globalSubs = new Map()\n\n// Component subscriptions: channel -> [[component, callback], ...]\n// Used for parent-child bubbling (this.publish)\nconst componentSubs = {}\n\n// =============================================================================\n// GLOBAL PUB/SUB\n// =============================================================================\n\n/**\n * Subscribe to a channel (global)\n *\n * @param {string|Node} nodeOrSelector - Selector, node, or channel name\n * @param {string|Function} channelOrCallback - Channel name or callback\n * @param {Function} [callback] - Callback function\n * @returns {Function} Unsubscribe function\n *\n * @example\n *   subscribe('user-login', (user) => console.log(user))\n *   subscribe('#header', 'theme-change', (theme) => ...)\n *   subscribe(document.body, 'resize', () => ...)\n */\nfunction subscribe(nodeOrSelector, channelOrCallback, callback) {\n  let selector = null\n  let node = null\n  let channel\n\n  // Normalize arguments\n  if (typeof channelOrCallback === 'function') {\n    // subscribe('event', callback)\n    channel = nodeOrSelector\n    callback = channelOrCallback\n  } else {\n    // subscribe(node/selector, 'event', callback)\n    channel = channelOrCallback\n    if (typeof nodeOrSelector === 'string') {\n      selector = nodeOrSelector  // Store selector, resolve at publish time\n    } else {\n      node = nodeOrSelector  // Store node reference\n    }\n  }\n\n  if (!globalSubs.has(channel)) {\n    globalSubs.set(channel, new Set())\n  }\n\n  const channelSubs = globalSubs.get(channel)\n\n  // Remove duplicate (same selector/node + callback)\n  for (const sub of channelSubs) {\n    if (sub.callback === callback && sub.selector === selector && sub.node === node) {\n      channelSubs.delete(sub)\n    }\n  }\n\n  const subscription = { selector, node, callback }\n  channelSubs.add(subscription)\n\n  // Return unsubscribe function\n  return () => channelSubs.delete(subscription)\n}\n\n/**\n * Publish to a channel (global broadcast)\n *\n * @param {string} channel - Event name\n * @param {...any} args - Arguments to pass to callbacks\n */\nfunction publish(channel, ...args) {\n  const channelSubs = globalSubs.get(channel)\n  if (channelSubs) {\n    for (const sub of channelSubs) {\n      let target = null\n\n      if (sub.selector) {\n        // Resolve selector at publish time\n        target = document.querySelector(sub.selector)\n        if (!target) continue  // Skip if not found\n      } else if (sub.node) {\n        // Check node connection\n        if (!sub.node.isConnected) {\n          channelSubs.delete(sub)  // Auto-cleanup disconnected\n          continue\n        }\n        target = sub.node\n      }\n\n      // Call with target as context (or null for global)\n      try {\n        sub.callback.call(target, ...args)\n      } catch (e) {\n        console.error(`Fez pubsub error on \"${channel}\":`, e)\n      }\n    }\n  }\n\n  // Also trigger component subscriptions (legacy compatibility)\n  if (componentSubs[channel]) {\n    componentSubs[channel].forEach(([comp, cb]) => {\n      if (comp.isConnected) {\n        cb.bind(comp)(...args)\n      }\n    })\n  }\n}\n\n// =============================================================================\n// COMPONENT PUB/SUB (for this.subscribe / this.publish)\n// =============================================================================\n\n/**\n * Subscribe from a component (used by this.subscribe)\n * Stores subscription for parent-child bubbling\n *\n * @param {FezBase} component - Component instance\n * @param {string} channel - Event name\n * @param {Function} callback - Handler function\n * @returns {Function} Unsubscribe function\n */\nfunction componentSubscribe(component, channel, callback) {\n  componentSubs[channel] ||= []\n\n  // Clean up disconnected components\n  componentSubs[channel] = componentSubs[channel].filter(([comp]) => comp.isConnected)\n\n  // Add subscription\n  componentSubs[channel].push([component, callback])\n\n  // Return unsubscribe function\n  return () => {\n    componentSubs[channel] = componentSubs[channel].filter(\n      ([comp, cb]) => !(comp === component && cb === callback)\n    )\n  }\n}\n\n/**\n * Publish from a component (used by this.publish)\n * Bubbles up through parent components\n *\n * @param {FezBase} component - Component instance\n * @param {string} channel - Event name\n * @param {...any} args - Arguments\n * @returns {boolean} True if a parent handled the event\n */\nfunction componentPublish(component, channel, ...args) {\n  const handlePublish = (comp) => {\n    if (componentSubs[channel]) {\n      const sub = componentSubs[channel].find(([c]) => c === comp)\n      if (sub) {\n        sub[1].bind(comp)(...args)\n        return true\n      }\n    }\n    return false\n  }\n\n  // Check current component first\n  if (handlePublish(component)) {\n    return true\n  }\n\n  // Bubble up to parent components\n  let parent = component.root?.parentElement\n  while (parent) {\n    if (parent.fez) {\n      if (handlePublish(parent.fez)) {\n        return true\n      }\n    }\n    parent = parent.parentElement\n  }\n\n  return false\n}\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nexport {\n  subscribe,\n  publish,\n  componentSubscribe,\n  componentPublish,\n  globalSubs,\n  componentSubs\n}\n", "/**\n * FezBase - Base class for all Fez components\n *\n * Provides lifecycle hooks, reactive state, DOM utilities, and template rendering\n */\n\nimport parseNode from './lib/n.js'\nimport createTemplate from './lib/template.js'\nimport { componentSubscribe, componentPublish } from './lib/pubsub.js'\n\nexport default class FezBase {\n\n  // ===========================================================================\n  // STATIC METHODS\n  // ===========================================================================\n\n  static nodeName = 'div'\n\n  /**\n   * Extract props from a DOM node's attributes\n   * Handles :attr syntax for evaluated expressions and data-props JSON\n   */\n  static getProps(node, newNode) {\n    let attrs = {}\n\n    // Direct props attachment\n    if (node.props) {\n      return node.props\n    }\n\n    // Collect attributes\n    for (const attr of node.attributes) {\n      attrs[attr.name] = attr.value\n    }\n\n    // Evaluate :attr expressions\n    for (const [key, val] of Object.entries(attrs)) {\n      if ([':'].includes(key[0])) {\n        delete attrs[key]\n        try {\n          const newVal = new Function(`return (${val})`).bind(newNode)()\n          attrs[key.replace(/[\\:_]/, '')] = newVal\n        } catch (e) {\n          Fez.onError('attr', `<${node.tagName.toLowerCase()}> Error evaluating ${key}=\"${val}\": ${e.message}`)\n        }\n      }\n    }\n\n    // Handle data-props JSON\n    if (attrs['data-props']) {\n      let data = attrs['data-props']\n      if (typeof data == 'object') {\n        return data\n      } else {\n        if (data[0] != '{') {\n          data = decodeURIComponent(data)\n        }\n        try {\n          attrs = JSON.parse(data)\n        } catch (e) {\n          Fez.onError('props', `<${node.tagName.toLowerCase()}> Invalid JSON in data-props: ${e.message}`)\n        }\n      }\n    }\n    // Handle JSON template\n    else if (attrs['data-json-template']) {\n      const data = newNode.previousSibling?.textContent\n      if (data) {\n        try {\n          attrs = JSON.parse(data)\n          newNode.previousSibling.remove()\n        } catch (e) {\n          Fez.onError('props', `<${node.tagName.toLowerCase()}> Invalid JSON in template: ${e.message}`)\n        }\n      }\n    }\n\n    return attrs\n  }\n\n  /**\n   * Get form data from closest/child form\n   */\n  static formData(node) {\n    const formNode = node.closest('form') || node.querySelector('form')\n    if (!formNode) {\n      Fez.consoleLog('No form found for formData()')\n      return {}\n    }\n    const formData = new FormData(formNode)\n    const formObject = {}\n    formData.forEach((value, key) => {\n      formObject[key] = value\n    });\n    return formObject\n  }\n\n  // ===========================================================================\n  // CONSTRUCTOR & CORE\n  // ===========================================================================\n\n  constructor() {}\n\n  n = parseNode\n  fezBlocks = {}\n\n  // Store for passing values to child components (e.g., loop vars)\n  fezGlobals = {\n    _data: new Map(),\n    _counter: 0,\n    set(value) {\n      const key = this._counter++\n      this._data.set(key, value)\n      return key\n    },\n    delete(key) {\n      const value = this._data.get(key)\n      this._data.delete(key)\n      return value\n    }\n  }\n\n  /**\n   * Report error with component name always included\n   */\n  fezError(kind, message, context) {\n    const name = this.fezName || this.root?.tagName?.toLowerCase() || 'unknown'\n    return Fez.onError(kind, `<${name}> ${message}`, context)\n  }\n\n  /**\n   * String selector for use in HTML nodes\n   */\n  get fezHtmlRoot() {\n    return `Fez(${this.UID}).`\n  }\n\n  /**\n   * Check if node is attached to DOM\n   */\n  get isConnected() {\n    return !!this.root?.isConnected\n  }\n\n  /**\n   * Get single node property\n   */\n  prop(name) {\n    let v = this.oldRoot[name] || this.props[name]\n    if (typeof v == 'function') {\n      v = v.bind(this.root)\n    }\n    return v\n  }\n\n  // ===========================================================================\n  // LIFECYCLE HOOKS\n  // ===========================================================================\n\n  connect() {}\n  onMount() {}\n  beforeRender() {}\n  afterRender() {}\n  onDestroy() {}\n  onStateChange() {}\n  onGlobalStateChange() {}\n  onPropsChange() {}\n\n  /**\n   * Centralized destroy logic - called by MutationObserver when element is removed\n   */\n  fezOnDestroy() {\n    // Guard against double-cleanup\n    if (this._destroyed) return\n    this._destroyed = true\n\n    // Execute cleanup callbacks (intervals, observers, event listeners)\n    if (this._onDestroyCallbacks) {\n      this._onDestroyCallbacks.forEach(callback => {\n        try {\n          callback()\n        } catch (e) {\n          this.fezError('destroy', 'Error in cleanup callback', e)\n        }\n      })\n      this._onDestroyCallbacks = []\n    }\n\n    // Call user's onDestroy hook\n    this.onDestroy()\n    this.onDestroy = () => {}\n\n    // Clean up root references\n    if (this.root) {\n      this.root.fez = undefined\n    }\n    this.root = undefined\n  }\n\n  /**\n   * Add a cleanup callback for destroy\n   */\n  addOnDestroy(callback) {\n    this._onDestroyCallbacks = this._onDestroyCallbacks || [];\n    this._onDestroyCallbacks.push(callback);\n  }\n\n  // ===========================================================================\n  // RENDERING\n  // ===========================================================================\n\n  /**\n   * Parse HTML and replace fez. references\n   */\n  fezParseHtml(text) {\n    const base = this.fezHtmlRoot.replaceAll('\"', '&quot;')\n    text = text\n      .replace(/([!'\"\\s;])fez\\.(\\w)/g, `$1${base}$2`)\n      .replace(/>\\s+</g, '><')\n    return text.trim()\n  }\n\n  /**\n   * Schedule work on next animation frame (debounced by name)\n   */\n  fezNextTick(func, name) {\n    if (name) {\n      this._nextTicks ||= {}\n      this._nextTicks[name] ||= window.requestAnimationFrame(() => {\n        func.bind(this)()\n        this._nextTicks[name] = null\n      }, name)\n    } else {\n      window.requestAnimationFrame(func.bind(this))\n    }\n  }\n\n  /**\n   * Force a re-render on next frame\n   */\n  fezRefresh() {\n    this.fezNextTick(() => this.fezRender(), 'refresh')\n  }\n\n  /**\n   * Alias for fezRefresh - can be overwritten\n   */\n  refresh() {\n    this.fezRefresh()\n  }\n\n  /**\n   * Render the component template to DOM\n   * Uses Idiomorph for efficient DOM diffing\n   */\n  fezRender(template) {\n    // Check instance-level template first, then class-level\n    template ||= this.fezHtmlFunc || this?.class?.fezHtmlFunc\n\n    if (!template || !this.root) return\n\n    // Prevent re-render loops from state changes in beforeRender/afterRender\n    this._isRendering = true\n\n    this.beforeRender()\n\n    const nodeName = typeof this.class.nodeName == 'function' ? this.class.nodeName(this.root) : this.class.nodeName\n    const newNode = document.createElement(nodeName || 'div')\n\n    let renderedTpl\n    if (Array.isArray(template)) {\n      if (template[0] instanceof Node) {\n        template.forEach(n => newNode.appendChild(n))\n      } else {\n        renderedTpl = template.join('')\n      }\n    }\n    else if (typeof template == 'string') {\n      const name = this.root?.tagName?.toLowerCase()\n      renderedTpl = createTemplate(template, { name })(this)\n    }\n    else if (typeof template == 'function') {\n      renderedTpl = template(this)\n    }\n\n    if (renderedTpl) {\n      if (renderedTpl instanceof DocumentFragment || renderedTpl instanceof Node) {\n        newNode.appendChild(renderedTpl)\n      } else {\n        renderedTpl = renderedTpl.replace(/\\s\\w+=\"undefined\"/g, '')\n        newNode.innerHTML = this.fezParseHtml(renderedTpl)\n      }\n    }\n\n    this.fezKeepNode(newNode)\n\n    // Save input values for fez-this/fez-bind bound elements before morph\n    const savedInputValues = new Map()\n    this.root.querySelectorAll('input, textarea, select').forEach(el => {\n      if (el._fezThisName) {\n        savedInputValues.set(el._fezThisName, {\n          value: el.value,\n          checked: el.checked\n        })\n      }\n    })\n\n    Fez.morphdom(this.root, newNode)\n\n    // Restore input values after morph - find element by _fezThisName property\n    savedInputValues.forEach((saved, name) => {\n      let el = null\n      this.root.querySelectorAll('input, textarea, select').forEach(input => {\n        if (input._fezThisName === name) el = input\n      })\n      if (el) {\n        el.value = saved.value\n        if (saved.checked !== undefined) el.checked = saved.checked\n      }\n    })\n\n    this.fezRenderPostProcess()\n    this.afterRender()\n\n    this._isRendering = false\n  }\n\n  /**\n   * Post-render processing for fez-* attributes\n   */\n  fezRenderPostProcess() {\n    const fetchAttr = (name, func) => {\n      this.root.querySelectorAll(`*[${name}]`).forEach((n) => {\n        let value = n.getAttribute(name)\n        n.removeAttribute(name)\n        if (value) {\n          func.bind(this)(value, n)\n        }\n      })\n    }\n\n    // fez-this=\"button\" -> this.button = node\n    fetchAttr('fez-this', (value, n) => {\n      (new Function('n', `this.${value} = n`)).bind(this)(n)\n      // Mark element for value preservation on re-render\n      n._fezThisName = value\n    })\n\n    // fez-use=\"animate\" -> this.animate(node)\n    fetchAttr('fez-use', (value, n) => {\n      if (value.includes('=>')) {\n        Fez.getFunction(value)(n)\n      }\n      else {\n        if (value.includes('.')) {\n          Fez.getFunction(value).bind(n)()\n        }\n        else {\n          const target = this[value]\n          if (typeof target == 'function') {\n            target(n)\n          } else {\n            this.fezError('fez-use', `\"${value}\" is not a function`)\n          }\n        }\n      }\n    })\n\n    // fez-class=\"dialog animate\" -> add class after init for animation\n    fetchAttr('fez-class', (value, n) => {\n      let classes = value.split(/\\s+/)\n      let lastClass = classes.pop()\n      classes.forEach((c) => n.classList.add(c))\n      if (lastClass) {\n        setTimeout(() => {\n          n.classList.add(lastClass)\n        }, 1)\n      }\n    })\n\n    // fez-bind=\"state.inputNode\" -> two-way binding\n    fetchAttr('fez-bind', (text, n) => {\n      if (['INPUT', 'SELECT', 'TEXTAREA'].includes(n.nodeName)) {\n        const value = (new Function(`return this.${text}`)).bind(this)()\n        const isCb = n.type.toLowerCase() == 'checkbox'\n        const eventName = ['SELECT'].includes(n.nodeName) || isCb ? 'onchange' : 'onkeyup'\n        n.setAttribute(eventName, `${this.fezHtmlRoot}${text} = this.${isCb ? 'checked' : 'value'}`)\n        this.val(n, value)\n        // Mark element for value preservation on re-render\n        n._fezThisName = text\n      } else {\n        this.fezError('fez-bind', `Can't bind \"${text}\" to ${n.nodeName} (needs INPUT, SELECT or TEXTAREA)`)\n      }\n    })\n\n    // Normalize disabled attribute\n    this.root.querySelectorAll(`*[disabled]`).forEach((n) => {\n      let value = n.getAttribute('disabled')\n      if (['false'].includes(value)) {\n        n.removeAttribute('disabled')\n      } else {\n        n.setAttribute('disabled', 'true')\n      }\n    })\n  }\n\n  /**\n   * Handle fez-keep attributes for preserved nodes\n   */\n  fezKeepNode(newNode) {\n    newNode.querySelectorAll('[fez-keep]').forEach(newEl => {\n      const key = newEl.getAttribute('fez-keep')\n      const isSlot = key === 'default-slot' || key.startsWith('slot-')\n\n      let oldEl\n      if (isSlot) {\n        // Find slot belonging to THIS component, not nested\n        const candidates = this.root.querySelectorAll(`[fez-keep=\"${key}\"]`)\n        for (const el of candidates) {\n          let parent = el.parentElement\n          let isNested = false\n          while (parent && parent !== this.root) {\n            if (parent.classList.contains('fez')) {\n              isNested = true\n              break\n            }\n            parent = parent.parentElement\n          }\n          if (!isNested) {\n            oldEl = el\n            break\n          }\n        }\n      } else {\n        oldEl = this.root.querySelector(`[fez-keep=\"${key}\"]`)\n      }\n\n      if (oldEl) {\n        // Move the old element to replace the new placeholder\n        // This preserves all children including nested fez components\n        newEl.parentNode.replaceChild(oldEl, newEl)\n      } else if (isSlot) {\n        if (newEl.getAttribute('hide')) {\n          this.state = null\n          const parent = newEl.parentNode\n          Array.from(this.root.childNodes).forEach(child => {\n            parent.insertBefore(child, newEl)\n          })\n          newEl.remove()\n        } else {\n          const children = Array.from(this.root.childNodes)\n          children.forEach(child => {\n            newEl.appendChild(child)\n          })\n        }\n      }\n    })\n  }\n\n\n\n  // ===========================================================================\n  // REACTIVE STATE\n  // ===========================================================================\n\n  /**\n   * Register component: setup CSS, state, and bind methods\n   */\n  fezRegister() {\n    if (this.css) {\n      this.css = Fez.globalCss(this.css, { name: this.fezName, wrap: true })\n    }\n\n    if (this.class.css) {\n      this.class.css = Fez.globalCss(this.class.css, { name: this.fezName })\n    }\n\n    this.state ||= this.fezReactiveStore()\n    this.globalState = Fez.state.createProxy(this)\n    this.fezRegisterBindMethods()\n  }\n\n  /**\n   * Bind all instance methods to this\n   */\n  fezRegisterBindMethods() {\n    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n      .filter(method => method !== 'constructor' && typeof this[method] === 'function')\n    methods.forEach(method => this[method] = this[method].bind(this))\n  }\n\n  /**\n   * Create a reactive store that triggers re-renders on changes\n   */\n  fezReactiveStore(obj, handler) {\n    obj ||= {}\n\n    handler ||= (o, k, v, oldValue) => {\n      if (v != oldValue) {\n        this.onStateChange(k, v, oldValue)\n        // Don't schedule re-render during init/mount or if already rendering\n        if (!this._isRendering && !this._isInitializing) {\n          this.fezNextTick(this.fezRender, 'fezRender')\n        }\n      }\n    }\n\n    handler.bind(this)\n\n    function createReactive(obj, handler) {\n      if (typeof obj !== 'object' || obj === null || obj instanceof Promise) {\n        return obj;\n      }\n\n      return new Proxy(obj, {\n        set(target, property, value, receiver) {\n          const currentValue = Reflect.get(target, property, receiver);\n\n          if (currentValue !== value) {\n            if (typeof value === 'object' && value !== null && !(value instanceof Promise)) {\n              value = createReactive(value, handler);\n            }\n\n            const result = Reflect.set(target, property, value, receiver);\n            handler(target, property, value, currentValue);\n            return result;\n          }\n\n          return true;\n        },\n        get(target, property, receiver) {\n          const value = Reflect.get(target, property, receiver);\n          if (typeof value === 'object' && value !== null && !(value instanceof Promise)) {\n            return createReactive(value, handler);\n          }\n          return value;\n        }\n      });\n    }\n\n    return createReactive(obj, handler);\n  }\n\n  // ===========================================================================\n  // DOM HELPERS\n  // ===========================================================================\n\n  /**\n   * Find element by selector\n   */\n  find(selector) {\n    return typeof selector == 'string' ? this.root.querySelector(selector) : selector\n  }\n\n  /**\n   * Get or set node value (input/textarea/select or innerHTML)\n   */\n  val(selector, data) {\n    const node = this.find(selector)\n\n    if (node) {\n      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(node.nodeName)) {\n        if (typeof data != 'undefined') {\n          if (node.type == 'checkbox') {\n            node.checked = !!data\n          } else {\n            node.value = data\n          }\n        } else {\n          return node.value\n        }\n      } else {\n        if (typeof data != 'undefined') {\n          node.innerHTML = data\n        } else {\n          return node.innerHTML\n        }\n      }\n    }\n  }\n\n  /**\n   * Instance form data helper\n   */\n  formData(node) {\n    return this.class.formData(node || this.root)\n  }\n\n  /**\n   * Get or set root attribute\n   */\n  attr(name, value) {\n    if (typeof value === 'undefined') {\n      return this.root.getAttribute(name)\n    } else {\n      this.root.setAttribute(name, value)\n      return value\n    }\n  }\n\n  /**\n   * Get root children as array, optionally transform\n   * Returns captured children if no slot in template\n   * Pass true to convert children to objects with attrs as keys, innerHTML as .html, original node as .ROOT\n   */\n  childNodes(func) {\n    let children = this._fezChildNodes || Array.from(this.root.children)\n    if (func === true) {\n      children = children.map(node => {\n        const obj = { html: node.innerHTML, ROOT: node }\n        for (const attr of node.attributes) {\n          obj[attr.name] = attr.value\n        }\n        return obj\n      })\n    } else if (func) {\n      children = children.map(func)\n    }\n    return children\n  }\n\n  /**\n   * Set CSS properties on root\n   */\n  setStyle(key, value) {\n    if (key && typeof key == 'object') {\n      Object.entries(key).forEach(([prop, val]) => {\n        this.root.style.setProperty(prop, val);\n      });\n    } else {\n      this.root.style.setProperty(key, value);\n    }\n  }\n\n  /**\n   * Copy props as attributes to root\n   */\n  copy() {\n    for (const name of Array.from(arguments)) {\n      let value = this.props[name]\n\n      if (value !== undefined) {\n        if (name == 'class') {\n          const klass = this.root.getAttribute(name, value)\n          if (klass) {\n            value = [klass, value].join(' ')\n          }\n        }\n\n        if (typeof value == 'string') {\n          this.root.setAttribute(name, value)\n        }\n        else {\n          this.root[name] = value\n        }\n      }\n    }\n  }\n\n  /**\n   * Get or set root ID\n   */\n  rootId() {\n    this.root.id ||= `fez_${this.UID}`\n    return this.root.id\n  }\n\n  /**\n   * Dissolve component into parent\n   */\n  dissolve(inNode) {\n    if (inNode) {\n      inNode.classList.add('fez')\n      inNode.classList.add(`fez-${this.fezName}`)\n      inNode.fez = this\n      if (this.attr('id')) inNode.setAttribute('id', this.attr('id'))\n\n      this.root.innerHTML = ''\n      this.root.appendChild(inNode)\n    }\n\n    const node = this.root\n    const nodes = this.childNodes()\n    const parent = this.root.parentNode\n\n    nodes.reverse().forEach(el => parent.insertBefore(el, node.nextSibling))\n\n    this.root.remove()\n    this.root = undefined\n\n    if (inNode) {\n      this.root = inNode\n    }\n\n    return nodes\n  }\n\n  // ===========================================================================\n  // EVENTS\n  // ===========================================================================\n\n  /**\n   * Add window event listener with auto-cleanup\n   */\n  on(eventName, func, delay = 200) {\n    this._eventHandlers = this._eventHandlers || {};\n\n    if (this._eventHandlers[eventName]) {\n      window.removeEventListener(eventName, this._eventHandlers[eventName]);\n    }\n\n    const throttledFunc = Fez.throttle(() => {\n      if (this.isConnected) func.call(this);\n    }, delay);\n\n    this._eventHandlers[eventName] = throttledFunc;\n    window.addEventListener(eventName, throttledFunc);\n\n    this.addOnDestroy(() => {\n      window.removeEventListener(eventName, throttledFunc);\n      delete this._eventHandlers[eventName];\n    });\n  }\n\n  /**\n   * Window resize handler\n   */\n  onWindowResize(func, delay) {\n    this.on('resize', func, delay);\n    func();\n  }\n\n  /**\n   * Window scroll handler\n   */\n  onWindowScroll(func, delay) {\n    this.on('scroll', func, delay);\n    func();\n  }\n\n  /**\n   * Element resize handler using ResizeObserver\n   */\n  onElementResize(el, func, delay = 200) {\n    const throttledFunc = Fez.throttle(() => {\n      if (this.isConnected) func.call(this, el.getBoundingClientRect(), el);\n    }, delay);\n\n    const observer = new ResizeObserver(throttledFunc);\n    observer.observe(el);\n\n    func.call(this, el.getBoundingClientRect(), el);\n\n    this.addOnDestroy(() => {\n      observer.disconnect();\n    });\n  }\n\n  /**\n   * Timeout with auto-cleanup\n   */\n  setTimeout(func, delay) {\n    const timeoutID = setTimeout(() => {\n      if (this.isConnected) func()\n    }, delay)\n\n    this.addOnDestroy(() => clearTimeout(timeoutID))\n\n    return timeoutID\n  }\n\n  /**\n   * Interval with auto-cleanup\n   */\n  setInterval(func, tick, name) {\n    if (typeof func == 'number') {\n      [tick, func] = [func, tick]\n    }\n\n    name ||= Fez.fnv1(String(func))\n\n    this._setIntervalCache ||= {}\n    clearInterval(this._setIntervalCache[name])\n\n    const intervalID = setInterval(() => {\n      if (this.isConnected) func()\n    }, tick)\n\n    this._setIntervalCache[name] = intervalID\n\n    this.addOnDestroy(() => {\n      clearInterval(intervalID);\n      delete this._setIntervalCache[name];\n    });\n\n    return intervalID\n  }\n\n  // ===========================================================================\n  // PUB/SUB\n  // ===========================================================================\n\n  /**\n   * Publish to parent components (bubbles up through DOM)\n   * @param {string} channel - Event name\n   * @param {...any} args - Arguments to pass\n   * @returns {boolean} True if a parent handled the event\n   */\n  publish(channel, ...args) {\n    return componentPublish(this, channel, ...args)\n  }\n\n  /**\n   * Subscribe to a channel (auto-cleanup on destroy)\n   * @param {string} channel - Event name\n   * @param {Function} func - Handler function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(channel, func) {\n    const unsubscribe = componentSubscribe(this, channel, func)\n    this.addOnDestroy(unsubscribe)\n    return unsubscribe\n  }\n\n  // ===========================================================================\n  // SLOTS\n  // ===========================================================================\n\n  /**\n   * Copy child nodes natively to preserve bound events\n   */\n  fezSlot(source, target) {\n    target ||= document.createElement('template')\n    const isSlot = target.nodeName == 'SLOT'\n\n    while (source.firstChild) {\n      if (isSlot) {\n        target.parentNode.insertBefore(source.lastChild, target.nextSibling);\n      } else {\n        target.appendChild(source.firstChild)\n      }\n    }\n\n    if (isSlot) {\n      target.parentNode.removeChild(target)\n    } else {\n      source.innerHTML = ''\n    }\n\n    return target\n  }\n}\n", "/**\n * Skipped minification because the original files appears to be already minified.\n * Original file: /npm/goober@2.1.14/dist/goober.modern.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\nlet e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,a=e=>{let a=t(e),r=a.data;return a.data=\"\",r},r=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,l=/\\/\\*[^]*?\\*\\/|  +/g,s=/\\n+/g,n=(e,t)=>{let a=\"\",r=\"\",l=\"\";for(let s in e){let o=e[s];\"@\"==s[0]?\"i\"==s[1]?a=s+\" \"+o+\";\":r+=\"f\"==s[1]?n(o,s):s+\"{\"+n(o,\"k\"==s[1]?\"\":t)+\"}\":\"object\"==typeof o?r+=n(o,t?t.replace(/([^,])+/g,(e=>s.replace(/(^:.*)|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)))):s):null!=o&&(s=/^--/.test(s)?s:s.replace(/[A-Z]/g,\"-$&\").toLowerCase(),l+=n.p?n.p(s,o):s+\":\"+o+\";\")}return a+(t&&l?t+\"{\"+l+\"}\":l)+r},o={},c=e=>{if(\"object\"==typeof e){let t=\"\";for(let a in e)t+=a+c(e[a]);return t}return e},i=(e,t,a,i,p)=>{let u=c(e),d=o[u]||(o[u]=(e=>{let t=0,a=11;for(;t<e.length;)a=101*a+e.charCodeAt(t++)>>>0;return\"go\"+a})(u));if(!o[d]){let t=u!==e?e:(e=>{let t,a,n=[{}];for(;t=r.exec(e.replace(l,\"\"));)t[4]?n.shift():t[3]?(a=t[3].replace(s,\" \").trim(),n.unshift(n[0][a]=n[0][a]||{})):n[0][t[1]]=t[2].replace(s,\" \").trim();return n[0]})(e);o[d]=n(p?{[\"@keyframes \"+d]:t}:t,a?\"\":\".\"+d)}let f=a&&o.g?o.g:null;return a&&(o.g=o[d]),((e,t,a,r)=>{r?t.data=t.data.replace(r,e):-1===t.data.indexOf(e)&&(t.data=a?e+t.data:t.data+e)})(o[d],t,i,f),d},p=(e,t,a)=>e.reduce(((e,r,l)=>{let s=t[l];if(s&&s.call){let e=s(a),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;s=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":n(e,\"\"):!1===e?\"\":e}return e+r+(null==s?\"\":s)}),\"\");function u(e){let a=this||{},r=e.call?e(a.p):e;return i(r.unshift?r.raw?p(r,[].slice.call(arguments,1),a.p):r.reduce(((e,t)=>Object.assign(e,t&&t.call?t(a.p):t)),{}):r,t(a.target),a.g,a.o,a.k)}let d,f,g,b=u.bind({g:1}),m=u.bind({k:1});function h(e,t,a,r){n.p=t,d=e,f=a,g=r}function y(e,t){let a=this||{};return function(){let r=arguments;function l(s,n){let o=Object.assign({},s),c=o.className||l.className;a.p=Object.assign({theme:f&&f()},o),a.o=/ *go\\d+/.test(c),o.className=u.apply(a,r)+(c?\" \"+c:\"\"),t&&(o.ref=n);let i=e;return e[0]&&(i=o.as||e,delete o.as),g&&i[0]&&g(o),d(i,o)}return t?t(l):l}}\nexport default { css:u, extractCss: a, glob: b, keyframes: m, setup: h, styled: y }\n", "// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n\n                    try {\n                        if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                            // Use classList for class attribute to preserve animations\n                            if (fromAttribute.name === 'class') {\n                                syncClassList(from, to);\n                            } else {\n                                to.setAttribute(fromAttribute.name, fromAttribute.value);\n                            }\n                        }\n                    } catch (error) {\n                        // dux fix\n                        console.error('Error setting attribute:', {\n                            badNode: to,\n                            badAttribute: fromAttribute,\n                            error: error.message,\n                        });\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * Sync class attribute using classList.add/remove to preserve CSS animations\n         * @param from {Element} element to sync classes from\n         * @param to {Element} element to sync classes to\n         */\n        function syncClassList(from, to) {\n            const fromClasses = new Set(from.className.split(/\\s+/).filter(Boolean));\n            const toClasses = new Set(to.className.split(/\\s+/).filter(Boolean));\n\n            // Remove classes that are no longer present\n            for (const cls of toClasses) {\n                if (!fromClasses.has(cls)) {\n                    to.classList.remove(cls);\n                }\n            }\n\n            // Add new classes\n            for (const cls of fromClasses) {\n                if (!toClasses.has(cls)) {\n                    to.classList.add(cls);\n                }\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n", "// pretty print HTML\nconst log_pretty_print = (html) => {\n  const parts = html\n    .split(/(<\\/?[^>]+>)/g)\n    .map((p) => p.trim())\n    .filter((p) => p);\n\n  let indent = 0;\n  const lines = [];\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i];\n    const nextPart = parts[i + 1];\n    const nextNextPart = parts[i + 2];\n\n    // Check if it's a tag\n    if (part.startsWith(\"<\")) {\n      // Check if this is an opening tag followed by text and then its closing tag\n      if (\n        !part.startsWith(\"</\") &&\n        !part.endsWith(\"/>\") &&\n        nextPart &&\n        !nextPart.startsWith(\"<\") &&\n        nextNextPart &&\n        nextNextPart.startsWith(\"</\")\n      ) {\n        // Combine them on one line\n        const actualIndent = Math.max(0, indent);\n        lines.push(\"  \".repeat(actualIndent) + part + nextPart + nextNextPart);\n        i += 2; // Skip the next two parts\n      }\n      // Closing tag\n      else if (part.startsWith(\"</\")) {\n        indent--;\n        const actualIndent = Math.max(0, indent);\n        lines.push(\"  \".repeat(actualIndent) + part);\n      }\n      // Self-closing tag\n      else if (part.endsWith(\"/>\") || part.includes(\" />\")) {\n        const actualIndent = Math.max(0, indent);\n        lines.push(\"  \".repeat(actualIndent) + part);\n      }\n      // Opening tag\n      else {\n        const actualIndent = Math.max(0, indent);\n        lines.push(\"  \".repeat(actualIndent) + part);\n        indent++;\n      }\n    }\n    // Text node\n    else if (part) {\n      const actualIndent = Math.max(0, indent);\n      lines.push(\"  \".repeat(actualIndent) + part);\n    }\n  }\n\n  return lines.join(\"\\n\");\n};\n\nconst LOG = (() => {\n  const logs = [];\n  const logTypes = []; // Track the original type of each log\n  let currentIndex = 0;\n  let renderContent = null; // Will hold the render function\n\n  // Add ESC key handler and arrow key navigation\n  document.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Escape\") {\n      e.preventDefault();\n      const dialog = document.getElementById(\"dump-dialog\");\n      const button = document.getElementById(\"log-reopen-button\");\n\n      if (dialog) {\n        // Close dialog\n        dialog.remove();\n        createLogButton();\n      } else if (button) {\n        // Open dialog\n        button.remove();\n        showLogDialog();\n      }\n    } else if (\n      e.key === \"ArrowLeft\" ||\n      e.key === \"ArrowRight\" ||\n      e.key === \"ArrowUp\" ||\n      e.key === \"ArrowDown\"\n    ) {\n      const dialog = document.getElementById(\"dump-dialog\");\n      if (dialog && logs.length > 0) {\n        e.preventDefault();\n        if (e.key === \"ArrowLeft\" && currentIndex > 0) {\n          currentIndex--;\n          localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n          renderContent();\n        } else if (e.key === \"ArrowRight\" && currentIndex < logs.length - 1) {\n          currentIndex++;\n          localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n          renderContent();\n        } else if (e.key === \"ArrowUp\" && currentIndex > 0) {\n          currentIndex = Math.max(0, currentIndex - 5);\n          localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n          renderContent();\n        } else if (e.key === \"ArrowDown\" && currentIndex < logs.length - 1) {\n          currentIndex = Math.min(logs.length - 1, currentIndex + 5);\n          localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n          renderContent();\n        }\n      }\n    }\n  });\n\n  const createLogButton = () => {\n    let btn = document.getElementById(\"log-reopen-button\");\n    if (!btn) {\n      btn = document.body.appendChild(document.createElement(\"button\"));\n      btn.id = \"log-reopen-button\";\n      btn.innerHTML =\n        '<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" style=\"vertical-align:middle;margin-right:4px\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><polyline points=\"10 9 9 9 8 9\"></polyline></svg>LOG';\n      btn.style.cssText =\n        \"position:fixed; top: 10px; right: 10px;\" +\n        \"padding:10px 20px;background:#ff3333;color:#fff;border:none;\" +\n        \"cursor:pointer;font:14px/1.4 monospace;z-index:2147483647;\" +\n        \"border-radius:8px;display:flex;align-items:center;\" +\n        \"opacity:1;visibility:visible;box-shadow:0 4px 12px rgba(255,51,51,0.3)\";\n      btn.onclick = () => {\n        btn.remove();\n        showLogDialog();\n      };\n    }\n  };\n\n  const showLogDialog = () => {\n    // Remove any existing log button when showing dialog\n    const existingBtn = document.getElementById(\"log-reopen-button\");\n    if (existingBtn) existingBtn.remove();\n\n    let d = document.getElementById(\"dump-dialog\");\n    if (!d) {\n      d = document.body.appendChild(document.createElement(\"div\"));\n      d.id = \"dump-dialog\";\n      d.style.cssText =\n        \"position:fixed; top:20px; left:20px; right:20px; max-height:calc(100vh - 40px);\" +\n        \"background:#fff; border:1px solid #333; box-shadow:0 0 10px rgba(0,0,0,0.5);\" +\n        \"padding:20px; overflow:auto; z-index:2147483646; font:13px/1.4 monospace;\" +\n        \"white-space:pre; display:block; opacity:1; visibility:visible\";\n    }\n\n    // Check if we have a saved index and it's still valid\n    const savedIndex = parseInt(localStorage.getItem(\"_LOG_INDEX\"));\n    if (!isNaN(savedIndex) && savedIndex >= 0 && savedIndex < logs.length) {\n      currentIndex = savedIndex;\n    } else {\n      currentIndex = logs.length - 1;\n    }\n\n    renderContent = () => {\n      const buttons = logs\n        .map((_, i) => {\n          let bgColor = \"#f0f0f0\"; // default\n          if (i !== currentIndex) {\n            if (logTypes[i] === \"object\") {\n              bgColor = \"#d6e3ef\"; // super light blue\n            } else if (logTypes[i] === \"array\") {\n              bgColor = \"#d8d5ef\"; // super light indigo\n            }\n          }\n          return `<button style=\"font-size: 14px; font-weight: 400; padding:2px 6px; margin: 0 2px 2px 0;cursor:pointer;background:${i === currentIndex ? \"#333\" : bgColor};color:${i === currentIndex ? \"#fff\" : \"#000\"}\" data-index=\"${i}\">${i + 1}</button>`;\n        })\n        .join(\"\");\n\n      d.innerHTML =\n        '<div style=\"display:flex;flex-direction:column;height:100%\">' +\n        '<div style=\"display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px\">' +\n        '<div style=\"display:flex;flex-wrap:wrap;gap:4px;flex:1;margin-right:10px\">' +\n        buttons +\n        \"</div>\" +\n        '<button style=\"padding:4px 8px;cursor:pointer;flex-shrink:0\">&times;</button>' +\n        \"</div>\" +\n        '<xmp style=\"font-family:monospace;flex:1;overflow:auto;margin:0;padding:0;color:#000;background:#fff;font-size:14px;line-height:22px\">' +\n        logs[currentIndex] +\n        \"</xmp>\" +\n        \"</div>\";\n\n      d.querySelector('button[style*=\"flex-shrink:0\"]').onclick = () => {\n        d.remove();\n        createLogButton();\n      };\n\n      d.querySelectorAll(\"button[data-index]\").forEach((btn) => {\n        btn.onclick = () => {\n          currentIndex = parseInt(btn.dataset.index);\n          localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n          renderContent();\n        };\n      });\n    };\n\n    renderContent();\n  };\n\n  return (o) => {\n    if (!document.body) {\n      window.requestAnimationFrame(() => LOG(o));\n      return;\n    }\n\n    // Store the original type\n    let originalType = typeof o;\n\n    if (o instanceof Node) {\n      if (o.nodeType === Node.TEXT_NODE) {\n        o = o.textContent || String(o);\n      } else {\n        o = log_pretty_print(o.outerHTML);\n      }\n    }\n\n    if (o === undefined) {\n      o = \"undefined\";\n    }\n    if (o === null) {\n      o = \"null\";\n    }\n\n    if (Array.isArray(o)) {\n      originalType = \"array\";\n    } else if (typeof o === \"object\" && o !== null) {\n      originalType = \"object\";\n    }\n\n    if (typeof o != \"string\") {\n      o = JSON.stringify(\n        o,\n        (key, value) => {\n          if (typeof value === \"function\") {\n            return String(value);\n          }\n          return value;\n        },\n        2,\n      ).replaceAll(\"<\", \"&lt;\");\n    }\n\n    o = o.trim();\n\n    logs.push(o + `\\n\\ntype: ${originalType}`);\n    logTypes.push(originalType);\n\n    // Check if log dialog is open by checking for element\n    const isOpen = !!document.getElementById(\"dump-dialog\");\n\n    if (!isOpen) {\n      // Show log dialog by default\n      showLogDialog();\n    } else {\n      // Update current index to the new log and refresh\n      currentIndex = logs.length - 1;\n      localStorage.setItem(\"_LOG_INDEX\", currentIndex);\n      if (renderContent) {\n        renderContent();\n      }\n    }\n  };\n})();\n\nif (typeof window !== \"undefined\" && !window.LOG) {\n  window.LOG = LOG;\n}\n\nexport default LOG;\n", "// Highlight all Fez elements with their names\nconst highlightAll = () => {\n  // Only work if Fez.DEV is true OR (port is above 2999 and Fez.DEV is not false)\n  const port = parseInt(window.location.port) || 80;\n  if (!(Fez.DEV === true || (port > 2999 && Fez.DEV !== false))) return;\n\n  // Check if highlights already exist\n  const existingHighlights = document.querySelectorAll('.fez-highlight-overlay');\n\n  if (existingHighlights.length > 0) {\n    // Remove existing highlights\n    existingHighlights.forEach(el => el.remove());\n    return;\n  }\n\n  // Find all Fez and Svelte elements\n  const allElements = document.querySelectorAll('.fez, .svelte');\n\n  allElements.forEach(el => {\n    let componentName = null;\n    let componentType = null;\n\n    // Check for Fez component\n    if (el.classList.contains('fez') && el.fez && el.fez.fezName) {\n      componentName = el.fez.fezName;\n      componentType = 'fez';\n    }\n    // Check for Svelte component\n    else if (el.classList.contains('svelte') && el.svelte && el.svelte.svelteName) {\n      componentName = el.svelte.svelteName;\n      componentType = 'svelte';\n    }\n\n    if (componentName) {\n      // Create overlay div\n      const overlay = document.createElement('div');\n      overlay.className = 'fez-highlight-overlay';\n\n      // Get element position\n      const rect = el.getBoundingClientRect();\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\n\n      // Style the overlay\n      overlay.style.cssText = `\n        position: absolute;\n        top: ${rect.top + scrollTop}px;\n        left: ${rect.left + scrollLeft}px;\n        width: ${rect.width}px;\n        height: ${rect.height}px;\n        border: 1px solid ${componentType === 'svelte' ? 'blue' : 'red'};\n        pointer-events: none;\n        z-index: 9999;\n      `;\n\n      // Create label for component name\n      const label = document.createElement('div');\n      label.textContent = componentName;\n      label.style.cssText = `\n        position: absolute;\n        top: -20px;\n        left: 0;\n        background: ${componentType === 'svelte' ? 'blue' : 'red'};\n        color: white;\n        padding: 4px 6px 2px 6px;\n        font-size: 14px;\n        font-family: monospace;\n        line-height: 1;\n        white-space: nowrap;\n        cursor: pointer;\n        pointer-events: auto;\n        text-transform: uppercase;\n      `;\n\n      // Add click handler to dump the node\n      label.addEventListener('click', (e) => {\n        e.stopPropagation();\n        Fez.log(el);\n      });\n\n      overlay.appendChild(label);\n      document.body.appendChild(overlay);\n    }\n  });\n}\n\n// Bind Ctrl+E to highlightAll\ndocument.addEventListener('keydown', (event) => {\n  if ((event.ctrlKey || event.metaKey) && event.key === 'e') {\n    // Check if target is not inside a form\n    if (!event.target.closest('form')) {\n      event.preventDefault();\n      highlightAll();\n    }\n  }\n});\n\nexport default highlightAll\n", "/**\n * Fez Component Registration & Connection\n *\n * This file handles:\n * - Registering components with customElements\n * - Transforming plain classes to FezBase subclasses\n * - Instantiating components when they appear in DOM\n *\n * Flow:\n * 1. connect(name, class) - registers custom element\n * 2. connectedCallback() - when element appears in DOM\n * 3. connectNode() - creates instance, renders, calls lifecycle\n */\n\nimport createTemplate from \"./lib/template.js\";\nimport FezBase from \"./instance.js\";\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst SELF_CLOSING_TAGS = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n]);\n\n// Attribute observer for reactive props\nconst attrObserver = new MutationObserver((mutations) => {\n  for (const mutation of mutations) {\n    if (mutation.type === \"attributes\") {\n      const fez = mutation.target.fez;\n      if (fez) {\n        const name = mutation.attributeName;\n        const value = mutation.target.getAttribute(name);\n        fez.props[name] = value;\n        fez.onPropsChange(name, value);\n      }\n    }\n  }\n});\n\n// =============================================================================\n// MAIN CONNECT FUNCTION\n// =============================================================================\n\n/**\n * Register a Fez component\n *\n * @param {string} name - Custom element name (must contain dash)\n * @param {Class} klass - Component class\n *\n * @example\n * Fez('ui-button', class {\n *   HTML = '<button><slot /></button>'\n *   CSS = 'button { color: blue; }'\n *   init() { console.log('created') }\n * })\n */\nexport default function connect(name, klass) {\n  const Fez = globalThis.window?.Fez || globalThis.Fez;\n\n  // Validate name\n  if (!name.includes(\"-\")) {\n    console.error(`Fez: Invalid name \"${name}\". Must contain a dash.`);\n    return;\n  }\n\n  // Transform to FezBase subclass\n  klass = ensureFezBase(Fez, name, klass);\n\n  // Process HTML template\n  if (klass.html) {\n    const slotTag = klass.SLOT || \"div\";\n    klass.html = klass.html\n      .replace(\n        /<slot(\\s[^>]*)?>/,\n        `<${slotTag} class=\"fez-slot fez-slot-${name}\" fez-keep=\"slot-${name}\"$1>`,\n      )\n      .replace(\"</slot>\", `</${slotTag}>`);\n\n    klass.fezHtmlFunc = createTemplate(klass.html, { name });\n  }\n\n  // Register CSS\n  if (klass.css) {\n    klass.css = Fez.globalCss(klass.css, { name });\n  }\n\n  // Store class in index\n  Fez.index.ensure(name).class = klass;\n\n  // Register custom element\n  if (!customElements.get(name)) {\n    customElements.define(\n      name,\n      class extends HTMLElement {\n        connectedCallback() {\n          if (shouldRenderFast(this, klass)) {\n            connectNode(name, this);\n          } else {\n            requestAnimationFrame(() => connectNode(name, this));\n          }\n        }\n      },\n    );\n  }\n}\n\n// =============================================================================\n// CLASS TRANSFORMATION\n// =============================================================================\n\n/**\n * Transform plain class to FezBase subclass\n * Maps uppercase config props (HTML, CSS, etc.)\n */\nfunction ensureFezBase(Fez, name, klass) {\n  // Already a FezBase subclass\n  if (klass.prototype instanceof FezBase) {\n    if (klass.html) klass.html = closeCustomTags(klass.html);\n    return klass;\n  }\n\n  // Create FezBase subclass\n  const instance = new klass();\n  const newKlass = class extends FezBase {};\n\n  // Copy properties and methods\n  const props = [\n    ...Object.getOwnPropertyNames(instance),\n    ...Object.getOwnPropertyNames(klass.prototype),\n  ].filter((p) => p !== \"constructor\" && p !== \"prototype\");\n\n  for (const prop of props) {\n    newKlass.prototype[prop] = instance[prop];\n  }\n\n  // Map config properties\n  const configMap = {\n    FAST: \"FAST\",\n    GLOBAL: \"GLOBAL\",\n    NAME: \"nodeName\",\n  };\n  for (const [from, to] of Object.entries(configMap)) {\n    if (instance[from]) newKlass[to] = instance[from];\n  }\n\n  // Handle CSS (can be string or function)\n  if (instance.CSS) {\n    newKlass.css =\n      typeof instance.CSS === \"function\" ? instance.CSS() : instance.CSS;\n  }\n\n  // Handle HTML (can be string or function)\n  if (instance.HTML) {\n    const html =\n      typeof instance.HTML === \"function\" ? instance.HTML() : instance.HTML;\n    newKlass.html = closeCustomTags(html);\n  }\n\n  // Handle META (generic metadata object)\n  if (instance.META) {\n    newKlass.META = instance.META;\n    Fez.index.ensure(name).meta = instance.META;\n  }\n\n  // Auto-mount global components\n  if (instance.GLOBAL) {\n    Fez.onReady(() => document.body.appendChild(document.createElement(name)));\n  }\n\n  Fez.consoleLog(`${name} compiled`);\n  return newKlass;\n}\n\n/**\n * Convert self-closing custom tags to full format\n * <my-comp /> -> <my-comp></my-comp>\n */\nfunction closeCustomTags(html) {\n  return html.replace(/<([a-z-]+)\\b([^>]*)\\/>/g, (match, tag, attrs) => {\n    return SELF_CLOSING_TAGS.has(tag) ? match : `<${tag}${attrs}></${tag}>`;\n  });\n}\n\n/**\n * Determine if component should render synchronously\n */\nfunction shouldRenderFast(node, klass) {\n  const attr = node.getAttribute(\"fez-fast\");\n  if (attr === \"false\") return false;\n\n  const klassFast =\n    typeof klass.FAST === \"function\" ? klass.FAST(node) : klass.FAST;\n  return !!(attr || klassFast || node.childNodes[0] || node.nextSibling);\n}\n\n// =============================================================================\n// NODE CONNECTION (Instantiation)\n// =============================================================================\n\n/**\n * Initialize component instance from DOM node\n */\nfunction connectNode(name, node) {\n  if (!node.isConnected) return;\n  if (node.classList?.contains(\"fez\")) return;\n\n  const klass = Fez.index[name]?.class;\n  const nodeName =\n    typeof klass.nodeName === \"function\"\n      ? klass.nodeName(node)\n      : klass.nodeName;\n  const newNode = document.createElement(nodeName || \"div\");\n\n  newNode.classList.add(\"fez\", `fez-${name}`);\n\n  if (!node.parentNode) {\n    console.warn(`Fez: ${name} has no parent, skipping`);\n    return;\n  }\n\n  // Replace custom element with component node\n  node.parentNode.replaceChild(newNode, node);\n\n  // Create instance\n  const fez = new klass();\n  fez.UID = ++Fez.instanceCount;\n  Fez.instances.set(fez.UID, fez);\n\n  fez.oldRoot = node;\n  fez.fezName = name;\n  fez.root = newNode;\n  fez.props = klass.getProps(node, newNode);\n  fez.class = klass;\n\n  // Move children (slot content)\n  fez.fezSlot(node, newNode);\n\n  newNode.fez = fez;\n\n  // Global component reference\n  if (klass.GLOBAL && klass.GLOBAL !== true) {\n    window[klass.GLOBAL] ||= fez;\n  }\n\n  // jQuery compatibility\n  if (window.$) fez.$root = $(newNode);\n\n  // Copy ID\n  if (fez.props.id) newNode.setAttribute(\"id\", fez.props.id);\n\n  // === LIFECYCLE ===\n\n  // Setup reactive state\n  fez.fezRegister();\n\n  // Capture children if no slot consumed them\n  if (fez.root.children.length) {\n    fez._fezChildNodes = Array.from(fez.root.children);\n  }\n\n  // Prevent state changes during init/mount from scheduling extra renders\n  fez._isInitializing = true;\n\n  // Init (supports multiple naming conventions)\n  const initMethod = fez.onInit || fez.init || fez.created || fez.connect;\n  initMethod.call(fez, fez.props);\n\n  // Render\n  fez.fezRender();\n\n  // Done initializing - state changes in onMount will now trigger renders\n  fez._isInitializing = false;\n\n  // Mount\n  fez.onMount(fez.props);\n\n  // Form submit handling\n  if (fez.onSubmit) {\n    const form = fez.root.nodeName === \"FORM\" ? fez.root : fez.find(\"form\");\n    if (form) {\n      form.onsubmit = (e) => {\n        e.preventDefault();\n        fez.onSubmit(fez.formData());\n      };\n    }\n  }\n\n  // Watch for attribute changes\n  if (fez.onPropsChange) {\n    attrObserver.observe(newNode, { attributes: true });\n    for (const [key, value] of Object.entries(fez.props)) {\n      fez.onPropsChange(key, value);\n    }\n  }\n}\n", "/**\n * Fez Component Compiler\n *\n * Compiles component definitions from various sources:\n * - <template fez=\"name\">...</template>\n * - <xmp fez=\"name\">...</xmp>\n * - <script fez=\"name\">...</script>\n * - Remote URLs\n *\n * Flow:\n * 1. Source (template/xmp/url) -> compile()\n * 2. Extract parts (script/style/html/demo) -> compileToClass()\n * 3. Generate class string -> Fez('name', class { ... })\n */\n\n// Note: Uses Fez.index directly (set up in root.js)\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\n/**\n * Remove common leading whitespace from all lines\n */\nfunction dedent(text) {\n  const lines = text.split(\"\\n\");\n  // Find minimum indentation (ignoring empty lines)\n  const nonEmptyLines = lines.filter((l) => l.trim());\n  if (!nonEmptyLines.length) return text;\n\n  const minIndent = Math.min(\n    ...nonEmptyLines.map((l) => l.match(/^(\\s*)/)[1].length),\n  );\n  if (minIndent === 0) return text;\n\n  // Remove common indentation\n  return lines.map((l) => l.slice(minIndent)).join(\"\\n\");\n}\n\n// =============================================================================\n// MAIN COMPILE FUNCTION\n// =============================================================================\n\n/**\n * Check if HTML has top-level <xmp fez> or <template fez> elements\n * (not ones inside <demo> blocks)\n */\nfunction hasTopLevelFezElements(html) {\n  if (!html) return false;\n\n  // Remove content inside <demo>...</demo> to avoid false positives\n  const withoutDemo = html.replace(/<demo>[\\s\\S]*?<\\/demo>/gi, \"\");\n\n  // Check for <xmp fez= or <template fez= at top level\n  return /<(xmp|template)\\s+fez\\s*=/i.test(withoutDemo);\n}\n\n/**\n * Compile a Fez component\n *\n * @example\n * Fez.compile()                        // Compile all templates in document\n * Fez.compile(templateNode)            // Compile a template node\n * Fez.compile('ui-foo', htmlString)    // Compile from string\n *\n * @param {string|Node} tagName - Component name or template node\n * @param {string} [html] - Component HTML source\n */\nexport default function compile(tagName, html) {\n  // Single argument: compile node or all templates\n  if (arguments.length === 1) {\n    return compileBulk(tagName);\n  }\n\n  // Multiple xmp/template tags in html? Process them\n  // Check for top-level fez definitions (not ones inside <demo> blocks)\n  if (hasTopLevelFezElements(html)) {\n    // Extract top-level demo/info before processing inner components\n    if (tagName) {\n      const parts = compileToClass(html);\n      if (parts.info?.trim()) {\n        Fez.index.ensure(tagName).info = parts.info;\n      }\n      if (parts.demo?.trim()) {\n        Fez.index.ensure(tagName).demo = parts.demo;\n      }\n    }\n    return compileBulk(html);\n  }\n\n  // Validate component name\n  if (\n    tagName &&\n    !tagName.includes(\"-\") &&\n    !tagName.includes(\".\") &&\n    !tagName.includes(\"/\")\n  ) {\n    console.error(\n      `Fez: Invalid name \"${tagName}\". Must contain a dash (e.g., 'my-element').`,\n    );\n    return;\n  }\n\n  // Store original source\n  Fez.index.ensure(tagName).source = html;\n\n  // Extract and compile\n  const classCode = generateClassCode(tagName, compileToClass(html));\n\n  // Hide custom element until compiled\n  hideCustomElement(tagName);\n\n  // Execute the class code\n  executeClassCode(tagName, classCode);\n}\n\n// =============================================================================\n// COMPILE FROM VARIOUS SOURCES\n// =============================================================================\n\n/**\n * Compile from node or HTML string containing templates\n */\nfunction compileBulk(data) {\n  // Single template node\n  if (data instanceof Node) {\n    const node = data;\n    node.remove();\n\n    const fezName = node.getAttribute(\"fez\");\n\n    // URL reference\n    if (fezName?.includes(\".\") || fezName?.includes(\"/\")) {\n      return compileFromUrl(fezName);\n    }\n\n    // Validate name\n    if (fezName && !fezName.includes(\"-\")) {\n      console.error(`Fez: Invalid name \"${fezName}\". Must contain a dash.`);\n      return;\n    }\n\n    return compile(fezName, node.innerHTML);\n  }\n\n  // HTML string or document\n  const root = data ? Fez.domRoot(data) : document.body;\n  root\n    .querySelectorAll(\"template[fez], xmp[fez]\")\n    .forEach((n) => compileBulk(n));\n}\n\n/**\n * Compile component(s) from remote URL\n * Supports .fez files and .txt files (component lists)\n */\nfunction compileFromUrl(url) {\n  Fez.consoleLog(`Loading from ${url}`);\n\n  // Handle .txt files as component lists\n  if (url.endsWith(\".txt\")) {\n    Fez.head({ fez: url });\n    return;\n  }\n\n  Fez.fetch(url)\n    .then((content) => {\n      const doc = new DOMParser().parseFromString(content, \"text/html\");\n      const fezElements = doc.querySelectorAll(\"template[fez], xmp[fez]\");\n\n      if (fezElements.length > 0) {\n        // Extract top-level info/demo before the xmp elements (for multi-component files)\n        const fileName = url.split(\"/\").pop().split(\".\")[0];\n        const parts = compileToClass(content);\n        if (parts.info?.trim()) {\n          Fez.index.ensure(fileName).info = parts.info;\n        }\n        if (parts.demo?.trim()) {\n          Fez.index.ensure(fileName).demo = parts.demo;\n        }\n\n        // Multiple components in file\n        fezElements.forEach((el) => {\n          const name = el.getAttribute(\"fez\");\n          if (\n            name &&\n            !name.includes(\"-\") &&\n            !name.includes(\".\") &&\n            !name.includes(\"/\")\n          ) {\n            console.error(`Fez: Invalid name \"${name}\". Must contain a dash.`);\n            return;\n          }\n          compile(name, el.innerHTML);\n        });\n      } else {\n        // Single component, derive name from URL\n        const name = url.split(\"/\").pop().split(\".\")[0];\n        compile(name, content);\n      }\n    })\n    .catch((error) => {\n      Fez.onError(\"compile\", `Load error for \"${url}\": ${error.message}`);\n    });\n}\n\nexport { compileFromUrl as compile_from_url };\n\n// =============================================================================\n// PARSE COMPONENT SOURCE\n// =============================================================================\n\n/**\n * Parse component HTML into { script, style, html, head, demo, info }\n */\nfunction compileToClass(html) {\n  const result = {\n    script: \"\",\n    style: \"\",\n    html: \"\",\n    head: \"\",\n    demo: \"\",\n    info: \"\",\n  };\n  const lines = html.split(\"\\n\");\n\n  let block = [];\n  let type = \"\";\n\n  for (let line of lines) {\n    const trimmedLine = line.trim();\n\n    // Start blocks - demo/info can contain other tags, so skip nested detection\n    if (trimmedLine.startsWith(\"<demo\") && !result.demo && !type) {\n      type = \"demo\";\n    } else if (trimmedLine.startsWith(\"<info\") && !result.info && !type) {\n      type = \"info\";\n    } else if (\n      trimmedLine.startsWith(\"<script\") &&\n      !result.script &&\n      type !== \"head\" &&\n      type !== \"demo\" &&\n      type !== \"info\"\n    ) {\n      type = \"script\";\n    } else if (\n      trimmedLine.startsWith(\"<head\") &&\n      !result.script &&\n      type !== \"demo\" &&\n      type !== \"info\"\n    ) {\n      type = \"head\";\n    } else if (\n      trimmedLine.startsWith(\"<style\") &&\n      type !== \"demo\" &&\n      type !== \"info\"\n    ) {\n      type = \"style\";\n\n      // End blocks\n    } else if (trimmedLine.endsWith(\"</demo>\") && type === \"demo\") {\n      result.demo = dedent(block.join(\"\\n\"));\n      block = [];\n      type = \"\";\n    } else if (trimmedLine.endsWith(\"</info>\") && type === \"info\") {\n      result.info = dedent(block.join(\"\\n\"));\n      block = [];\n      type = \"\";\n    } else if (\n      trimmedLine.endsWith(\"</script>\") &&\n      type === \"script\" &&\n      !result.script\n    ) {\n      result.script = block.join(\"\\n\");\n      block = [];\n      type = \"\";\n    } else if (trimmedLine.endsWith(\"</style>\") && type === \"style\") {\n      result.style = block.join(\"\\n\");\n      block = [];\n      type = \"\";\n    } else if (\n      (trimmedLine.endsWith(\"</head>\") || trimmedLine.endsWith(\"</header>\")) &&\n      type === \"head\"\n    ) {\n      result.head = block.join(\"\\n\");\n      block = [];\n      type = \"\";\n\n      // Collect content - preserve original indentation for demo and info\n    } else if (type) {\n      block.push(type === \"demo\" || type === \"info\" ? line : trimmedLine);\n    } else {\n      result.html += trimmedLine + \"\\n\";\n    }\n  }\n\n  // Process head elements (scripts, links, etc.)\n  if (result.head) {\n    processHeadElements(result.head);\n  }\n\n  return result;\n}\n\n/**\n * Process <head> elements from component\n */\nfunction processHeadElements(headHtml) {\n  const container = Fez.domRoot(headHtml);\n\n  Array.from(container.children).forEach((node) => {\n    if (node.tagName === \"SCRIPT\") {\n      const script = document.createElement(\"script\");\n      Array.from(node.attributes).forEach((attr) => {\n        script.setAttribute(attr.name, attr.value);\n      });\n      script.type ||= \"text/javascript\";\n\n      if (node.src) {\n        document.head.appendChild(script);\n      } else if (\n        script.type.includes(\"javascript\") ||\n        script.type === \"module\"\n      ) {\n        script.textContent = node.textContent;\n        document.head.appendChild(script);\n      }\n    } else {\n      document.head.appendChild(node.cloneNode(true));\n    }\n  });\n}\n\n// =============================================================================\n// GENERATE CLASS CODE\n// =============================================================================\n\n/**\n * Generate executable class code from parsed parts\n */\nfunction generateClassCode(tagName, parts) {\n  let klass = parts.script;\n\n  // Wrap in class if needed\n  if (!/class\\s+\\{/.test(klass)) {\n    klass = `class {\\n${klass}\\n}`;\n  }\n\n  // Add CSS\n  if (String(parts.style).includes(\":\")) {\n    let css = Fez.cssMixin(parts.style);\n    css =\n      css.includes(\":fez\") || /(?:^|\\s)body\\s*\\{/.test(css)\n        ? css\n        : `:fez {\\n${css}\\n}`;\n    klass = klass.replace(/\\}\\s*$/, `\\n  CSS = \\`${css}\\`\\n}`);\n  }\n\n  // Add HTML\n  if (/\\w/.test(String(parts.html))) {\n    const html = parts.html.replaceAll(\"`\", \"&#x60;\").replaceAll(\"$\", \"\\\\$\");\n    klass = klass.replace(/\\}\\s*$/, `\\n  HTML = \\`${html}\\`\\n}`);\n  }\n\n  // Store demo content in index\n  if (parts.demo?.trim()) {\n    Fez.index.ensure(tagName).demo = parts.demo;\n  }\n\n  // Store info content in index\n  if (parts.info?.trim()) {\n    Fez.index.ensure(tagName).info = parts.info;\n  }\n\n  // Wrap in Fez call\n  const [before, after] = klass.split(/class\\s+\\{/, 2);\n  return `${before};\\n\\nwindow.Fez('${tagName}', class {\\n${after})`;\n}\n\n/**\n * Execute generated class code\n */\nfunction executeClassCode(tagName, code) {\n  // Module imports require script tag\n  if (code.includes(\"import \")) {\n    Fez.head({ script: code });\n\n    // Check for compile errors after delay\n    setTimeout(() => {\n      if (!Fez.index[tagName]?.class) {\n        Fez.consoleError(`Template \"${tagName}\" possible compile error.`);\n      }\n    }, 2000);\n  } else {\n    try {\n      new Function(code)();\n    } catch (e) {\n      Fez.consoleError(`Template \"${tagName}\" compile error: ${e.message}`);\n      console.log(code);\n    }\n  }\n}\n\n/**\n * Add CSS to hide custom element until compiled\n */\nfunction hideCustomElement(tagName) {\n  if (!tagName) return;\n\n  let styleEl = document.getElementById(\"fez-hidden-styles\");\n  if (!styleEl) {\n    styleEl = document.createElement(\"style\");\n    styleEl.id = \"fez-hidden-styles\";\n    document.head.appendChild(styleEl);\n  }\n\n  const allTags = [...Fez.index.names(), tagName].sort().join(\", \");\n  styleEl.textContent = `${allTags} { display: none; }\\n`;\n}\n", "// Global state manager with automatic component subscription\n//\n// Components access state via this.globalState proxy which automatically:\n// - Registers component as listener when reading a value\n// - Notifies component when that value changes\n// - Calls onGlobalStateChange(key, value) if defined, then fezRender()\n//\n// Example usage:\n//\n//   class Counter extends FezBase {\n//     increment() {\n//       this.globalState.count = (this.globalState.count || 0) + 1\n//     }\n//\n//     onGlobalStateChange(key, value) {\n//       console.log(`State ${key} changed to ${value}`)\n//     }\n//\n//     render() {\n//       return `<button onclick=\"fez.increment()\">\n//         Count: ${this.globalState.count || 0}\n//       </button>`\n//     }\n//   }\n//\n// External access:\n//   Fez.state.set('count', 10)\n//   Fez.state.get('count') // 10\n\nconst GlobalState = {\n  data: {},\n  listeners: new Map(), // key -> Set of components\n  subscribers: new Map(), // key -> Set of functions (for subscribe method)\n  globalSubscribers: new Set(), // Set of functions that listen to all changes\n\n  notify(key, value, oldValue) {\n    Fez.consoleLog(`Global state change for ${key}: ${value} (from ${oldValue})`)\n\n    // Notify component listeners\n    const listeners = this.listeners.get(key)\n    if (listeners) {\n      listeners.forEach(comp => {\n        if (comp.isConnected) {\n          try {\n            comp.onGlobalStateChange(key, value, oldValue)\n            comp.fezRender()\n          } catch (error) {\n            console.error(`Error in component listener for key ${key}:`, error)\n          }\n        } else {\n          listeners.delete(comp)\n        }\n      })\n    }\n\n    // Notify key-specific subscribers\n    const subscribers = this.subscribers.get(key)\n    if (subscribers) {\n      subscribers.forEach(func => {\n        try {\n          func(value, oldValue, key)\n        } catch (error) {\n          console.error(`Error in subscriber for key ${key}:`, error)\n        }\n      })\n    }\n\n    // Notify global subscribers\n    this.globalSubscribers.forEach(func => {\n      try {\n        func(key, value, oldValue)\n      } catch (error) {\n        console.error(`Error in global subscriber:`, error)\n      }\n    })\n  },\n\n  createProxy(component) {\n    // Register cleanup when component is destroyed\n    component.addOnDestroy(() => {\n      for (const [key, listeners] of this.listeners) {\n        listeners.delete(component)\n      }\n      component._globalStateKeys?.clear()\n    })\n\n    return new Proxy({}, {\n      get: (target, key) => {\n        // Skip symbol keys and prototype methods\n        if (typeof key === 'symbol') return undefined\n\n        // Skip if already listening to this key\n        component._globalStateKeys ||= new Set()\n        if (!component._globalStateKeys.has(key)) {\n          component._globalStateKeys.add(key)\n\n          if (!this.listeners.has(key)) {\n            this.listeners.set(key, new Set())\n          }\n          this.listeners.get(key).add(component)\n        }\n\n        return this.data[key]\n      },\n\n      set: (target, key, value) => {\n        // Skip symbol keys\n        if (typeof key === 'symbol') return true\n\n        const oldValue = this.data[key]\n        if (oldValue !== value) {\n          this.data[key] = value\n          this.notify(key, value, oldValue)\n        }\n        return true\n      }\n    })\n  },\n\n  // Direct methods for use outside components\n  set(key, value) {\n    const oldValue = this.data[key]\n    if (oldValue !== value) {\n      this.data[key] = value\n      this.notify(key, value, oldValue)\n    }\n  },\n\n  get(key) {\n    return this.data[key]\n  },\n\n  // Execute function for each component listening to a key\n  forEach(key, func) {\n    const listeners = this.listeners.get(key)\n    if (listeners) {\n      listeners.forEach(comp => {\n        if (comp.isConnected) {\n          func(comp)\n        } else {\n          listeners.delete(comp)\n        }\n      })\n    }\n  },\n\n  // Subscribe to state changes\n  // Usage: Fez.state.subscribe(func) - listen to all changes\n  //        Fez.state.subscribe(key, func) - listen to specific key changes\n  subscribe(keyOrFunc, func) {\n    if (typeof keyOrFunc === 'function') {\n      // subscribe(func) - global subscription\n      this.globalSubscribers.add(keyOrFunc)\n      return () => this.globalSubscribers.delete(keyOrFunc)\n    } else {\n      // subscribe(key, func) - key-specific subscription\n      const key = keyOrFunc\n      if (!this.subscribers.has(key)) {\n        this.subscribers.set(key, new Set())\n      }\n      this.subscribers.get(key).add(func)\n      return () => {\n        const keySubscribers = this.subscribers.get(key)\n        if (keySubscribers) {\n          keySubscribers.delete(func)\n          if (keySubscribers.size === 0) {\n            this.subscribers.delete(key)\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default GlobalState\n", "/**\n * localStorage wrapper with automatic JSON serialization\n * Preserves types: integers, floats, strings, objects, arrays, booleans, null\n *\n * @example\n * localStorage.set('count', 42)\n * localStorage.get('count') // 42 (number, not string)\n *\n * localStorage.set('user', { name: 'John', age: 30 })\n * localStorage.get('user') // { name: 'John', age: 30 }\n *\n * localStorage.get('missing', 'default') // 'default'\n */\n\nconst storage = () => globalThis.localStorage || window.localStorage\n\nfunction set(key, value) {\n  try {\n    storage().setItem(key, JSON.stringify(value))\n  } catch (e) {\n    console.error(`Fez localStorage: Failed to set \"${key}\"`, e)\n  }\n}\n\nfunction get(key, defaultValue = null) {\n  try {\n    const item = storage().getItem(key)\n    if (item === null) return defaultValue\n    return JSON.parse(item)\n  } catch (e) {\n    console.error(`Fez localStorage: Failed to get \"${key}\"`, e)\n    return defaultValue\n  }\n}\n\nfunction remove(key) {\n  storage().removeItem(key)\n}\n\nfunction clear() {\n  storage().clear()\n}\n\nexport default { set, get, remove, clear }\n", "/**\n * Async await helper for {#await} blocks in templates\n *\n * Manages promise state tracking and triggers re-renders when promises resolve/reject.\n */\n\n/**\n * Handle promise state for {#await} blocks in templates\n * Returns { status: 'pending'|'resolved'|'rejected', value, error }\n *\n * @param {FezBase} component - The component instance\n * @param {number} awaitId - Unique ID for this await block\n * @param {Promise|any} promiseOrValue - The promise or value to await\n * @returns {Object} { status, value, error }\n */\nexport default function awaitHelper(component, awaitId, promiseOrValue) {\n  // Initialize await states map on the component\n  component._awaitStates ||= new Map()\n\n  // Check if we already have state for this await block\n  const existing = component._awaitStates.get(awaitId)\n\n  // If not a promise, return resolved immediately\n  if (!promiseOrValue || typeof promiseOrValue.then !== 'function') {\n    return { status: 'resolved', value: promiseOrValue, error: null }\n  }\n\n  // If we have existing state for this exact promise, return it\n  if (existing && existing.promise === promiseOrValue) {\n    return existing\n  }\n\n  // New promise - set pending state and start tracking\n  const state = { status: 'pending', value: null, error: null, promise: promiseOrValue }\n  component._awaitStates.set(awaitId, state)\n\n  // Handle promise resolution\n  promiseOrValue\n    .then(value => {\n      // Only update if this is still the current promise for this await block\n      const current = component._awaitStates.get(awaitId)\n      if (current && current.promise === promiseOrValue) {\n        current.status = 'resolved'\n        current.value = value\n        // Trigger re-render\n        if (component.isConnected) {\n          component.fezNextTick(component.fezRender, 'fezRender')\n        }\n      }\n    })\n    .catch(error => {\n      const current = component._awaitStates.get(awaitId)\n      if (current && current.promise === promiseOrValue) {\n        current.status = 'rejected'\n        current.error = error\n        // Trigger re-render\n        if (component.isConnected) {\n          component.fezNextTick(component.fezRender, 'fezRender')\n        }\n      }\n    })\n\n  return state\n}\n", "/**\n * Unified Component Index\n *\n * Single source of truth for all component data:\n *   Fez.index['ui-btn'].class   - Component class\n *   Fez.index['ui-btn'].meta    - Metadata from META = {...}\n *   Fez.index['ui-btn'].demo    - Demo HTML string\n *   Fez.index['ui-btn'].info    - Info HTML string\n *   Fez.index['ui-btn'].source  - Raw .fez source\n *\n * Helper methods:\n *   Fez.index.get('ui-btn')     - Get entry with DOM nodes for demo/info\n *   Fez.index.apply('ui-btn', el) - Render demo into element\n *   Fez.index.names()           - Get all registered component names\n *   Fez.index.withDemo()        - Get names of components with demos\n *   Fez.index.all()             - Get all components as object\n */\n\nfunction createDomNode(html) {\n  const node = document.createElement(\"div\");\n  node.innerHTML = html;\n  return node;\n}\n\nconst index = {\n  // Component entries stored directly: index['ui-btn'] = { class, meta, ... }\n\n  /**\n   * Get or create entry for component\n   * @param {string} name - Component name\n   * @returns {{ class: Function|null, meta: Object|null, demo: string|null, info: string|null, source: string|null }}\n   */\n  ensure(name) {\n    if (\n      !this[name] ||\n      typeof this[name] !== \"object\" ||\n      !(\"class\" in this[name])\n    ) {\n      this[name] = {\n        class: null,\n        meta: null,\n        demo: null,\n        info: null,\n        source: null,\n      };\n    }\n    return this[name];\n  },\n\n  /**\n   * Get component data with DOM nodes for demo/info\n   * @param {string} name - Component name\n   * @returns {{ class: Function|null, meta: Object|null, demo: HTMLDivElement|null, info: HTMLDivElement|null, source: string|null }}\n   */\n  get(name) {\n    const entry = this[name];\n    if (!entry || typeof entry !== \"object\" || !(\"class\" in entry)) {\n      return { class: null, meta: null, demo: null, info: null, source: null };\n    }\n\n    return {\n      class: entry.class,\n      meta: entry.meta,\n      source: entry.source,\n      demo: entry.demo ? createDomNode(entry.demo) : null,\n      info: entry.info ? createDomNode(entry.info) : null,\n    };\n  },\n\n  /**\n   * Apply demo to element and execute scripts\n   * Scripts are executed first to define data/variables, then DOM is injected\n   * @param {string} name - Component name\n   * @param {HTMLElement} target - Target element to render into\n   * @returns {boolean} - True if demo was found and applied\n   */\n  apply(name, target) {\n    const entry = this[name];\n    if (!entry?.demo || !target) return false;\n\n    const tempDiv = document.createElement(\"div\");\n    tempDiv.innerHTML = entry.demo;\n\n    // Execute top-level scripts first (before DOM parsing triggers components)\n    tempDiv.querySelectorAll(\":scope > script\").forEach((script) => {\n      const content = script.textContent;\n      if (content.trim()) {\n        try {\n          new Function(content)();\n        } catch (e) {\n          console.error(`Fez.index.apply(\"${name}\") script error:`, e.message);\n        }\n      }\n      script.remove();\n    });\n\n    target.innerHTML = tempDiv.innerHTML;\n    return true;\n  },\n\n  /**\n   * Get all registered component names\n   * @returns {string[]}\n   */\n  names() {\n    return Object.keys(this).filter(\n      (k) =>\n        typeof this[k] === \"object\" && this[k] !== null && \"class\" in this[k],\n    );\n  },\n\n  /**\n   * Get names of components that have demos\n   * @returns {string[]}\n   */\n  withDemo() {\n    return this.names().filter((name) => this[name].demo);\n  },\n\n  /**\n   * Get all components as object with DOM nodes\n   * @returns {Object} Object with component names as keys\n   */\n  all() {\n    const result = {};\n    for (const name of this.names()) {\n      result[name] = this.get(name);\n    }\n    return result;\n  },\n\n  /**\n   * Print registered components to console\n   */\n  info() {\n    console.log(\"Fez components:\", this.names());\n  },\n};\n\nexport default index;\n", "// Utility functions that extend Fez\nexport default (Fez) => {\n  // Script from URL\n  //   Fez.head({ js: 'https://example.com/script.js' });\n  // Script with attributes\n  //   Fez.head({ js: 'https://example.com/script.js', type: 'module', async: true });\n  // Script with callback\n  //   Fez.head({ js: 'https://example.com/script.js' }, () => { console.log('loaded') });\n  // Module loading with auto-import to window\n  //   Fez.head({ js: 'https://example.com/module.js', module: 'MyModule' }); // imports and sets window.MyModule\n  // CSS inclusion\n  //   Fez.head({ css: 'https://example.com/styles.css' });\n  // CSS with additional attributes and callback\n  //   Fez.head({ css: 'https://example.com/styles.css', media: 'print' }, () => { console.log('CSS loaded') })\n  // Inline script evaluation\n  //   Fez.head({ script: 'console.log(\"Hello world\")' })\n  // Fez component loading\n  //   Fez.head({ fez: 'path/to/component.fez' })\n  // Extract from nodes\n  //   Fez.head(domNode)\n  Fez.head = (config, callback) => {\n    if (config.nodeName) {\n      if (config.nodeName == \"SCRIPT\") {\n        Fez.head({ script: config.innerText });\n        config.remove();\n      } else {\n        config.querySelectorAll(\"script\").forEach((n) => Fez.head(n));\n        config\n          .querySelectorAll(\"template[fez], xmp[fez], script[fez]\")\n          .forEach((n) => Fez.compile(n));\n      }\n\n      return;\n    }\n\n    if (typeof config !== \"object\" || config === null) {\n      throw new Error(\"head requires an object parameter\");\n    }\n\n    let src,\n      attributes = {},\n      elementType;\n\n    // Load Fez component(s) from URL\n    // Supports:\n    //   - Single component: { fez: 'path/to/component.fez' }\n    //   - Component list:   { fez: 'path/to/components.txt' }\n    //     txt file contains one component path per line (relative to txt location or absolute if starts with /)\n    if (config.fez) {\n      const fezPath = config.fez;\n\n      // If it's a txt file, load it as a component list\n      if (fezPath.endsWith(\".txt\")) {\n        Fez.fetch(fezPath).then((content) => {\n          // Get base path from txt file location\n          const basePath = fezPath.substring(0, fezPath.lastIndexOf(\"/\") + 1);\n\n          // Parse lines, filter empty lines and comments\n          const lines = content\n            .split(\"\\n\")\n            .map((line) => line.trim())\n            .filter((line) => line && !line.startsWith(\"#\"));\n\n          // Load each component\n          let loaded = 0;\n          const total = lines.length;\n\n          lines.forEach((line) => {\n            // Determine full path\n            // - If starts with /, it's absolute from root\n            // - Otherwise, relative to txt file location\n            let componentPath;\n            if (line.startsWith(\"/\")) {\n              componentPath = line;\n            } else {\n              // Add .fez extension if not present\n              const path = line.endsWith(\".fez\") ? line : line + \".fez\";\n              componentPath = basePath + path;\n            }\n\n            // Extract component name from path\n            const name = componentPath.split(\"/\").pop().split(\".\")[0];\n\n            Fez.fetch(componentPath).then((componentContent) => {\n              Fez.compile(name, componentContent);\n              loaded++;\n              if (loaded === total && callback) callback();\n            });\n          });\n        });\n        return;\n      }\n\n      // Single .fez component\n      Fez.fetch(fezPath).then((content) => {\n        const name = fezPath.split(\"/\").pop().split(\".\")[0];\n        Fez.compile(name, content);\n        if (callback) callback();\n      });\n      return;\n    }\n\n    if (config.script) {\n      if (config.script.includes(\"import \")) {\n        if (callback) {\n          Fez.consoleError(\n            \"Fez.head callback is not supported when script with import is passed (module context).\",\n          );\n        }\n\n        // Evaluate inline script in context in the module\n        const script = document.createElement(\"script\");\n        script.type = \"module\";\n        script.textContent = config.script;\n        document.head.appendChild(script);\n        requestAnimationFrame(() => script.remove());\n      } else {\n        try {\n          new Function(config.script)();\n          if (callback) callback();\n        } catch (error) {\n          Fez.consoleError(\"Error executing script:\", error);\n          console.log(config.script);\n        }\n      }\n      return;\n    } else if (config.js) {\n      src = config.js;\n      elementType = \"script\";\n      // Copy all properties except 'js' as attributes\n      for (const [key, value] of Object.entries(config)) {\n        if (key !== \"js\" && key !== \"module\") {\n          attributes[key] = value;\n        }\n      }\n      // Handle module loading\n      if (config.module) {\n        attributes.type = \"module\";\n      }\n    } else if (config.css) {\n      src = config.css;\n      elementType = \"link\";\n      attributes.rel = \"stylesheet\";\n      // Copy all properties except 'css' as attributes\n      for (const [key, value] of Object.entries(config)) {\n        if (key !== \"css\") {\n          attributes[key] = value;\n        }\n      }\n    } else {\n      throw new Error('head requires either \"script\", \"js\" or \"css\" property');\n    }\n\n    const existingNode = document.querySelector(\n      `${elementType}[src=\"${src}\"], ${elementType}[href=\"${src}\"]`,\n    );\n    if (existingNode) {\n      if (callback) callback();\n      return existingNode;\n    }\n\n    const element = document.createElement(elementType);\n\n    if (elementType === \"link\") {\n      element.href = src;\n    } else {\n      element.src = src;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      element.setAttribute(key, value);\n    }\n\n    if (callback || config.module) {\n      element.onload = () => {\n        // If module name is provided, import it and assign to window\n        if (config.module && elementType === \"script\") {\n          import(src)\n            .then((module) => {\n              window[config.module] =\n                module.default || module[config.module] || module;\n            })\n            .catch((error) => {\n              console.error(`Error importing module ${config.module}:`, error);\n            });\n        }\n        if (callback) callback();\n      };\n    }\n\n    document.head.appendChild(element);\n\n    return element;\n  };\n\n  // Cache configuration\n  const FETCH_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n  const FETCH_CACHE_MAX_SIZE = 100;\n\n  // Fetch wrapper with automatic caching and data handling\n  // Usage:\n  //   Fez.fetch(url) - GET request (default)\n  //   Fez.fetch(url, callback) - GET with callback\n  //   Fez.fetch(url, data) - GET with query params (?foo=bar&baz=qux)\n  //   Fez.fetch(url, data, callback) - GET with query params and callback\n  //   Fez.fetch('POST', url, data) - POST with FormData body (multipart/form-data)\n  //   Fez.fetch('POST', url, data, callback) - POST with FormData and callback\n  // Data object is automatically converted:\n  //   - GET: appended as URL query parameters\n  //   - POST: sent as FormData (multipart/form-data) without custom headers\n  Fez.fetch = function (...args) {\n    // Initialize cache if not exists\n    Fez._fetchCache ||= new Map();\n\n    let method = \"GET\";\n    let url;\n    let callback;\n\n    // Check if first arg is HTTP method (uppercase letters)\n    if (typeof args[0] === \"string\" && /^[A-Z]+$/.test(args[0])) {\n      method = args.shift();\n    }\n\n    // URL is required\n    url = args.shift();\n\n    // Check for data/options object\n    let opts = {};\n    let data = null;\n    if (typeof args[0] === \"object\") {\n      data = args.shift();\n    }\n\n    // Check for callback function\n    if (typeof args[0] === \"function\") {\n      callback = args.shift();\n    }\n\n    // Handle data based on method\n    if (data) {\n      if (method === \"GET\") {\n        // For GET, append data as query parameters\n        const params = new URLSearchParams(data);\n        url += (url.includes(\"?\") ? \"&\" : \"?\") + params.toString();\n      } else if (method === \"POST\") {\n        // For POST, convert to FormData\n        const formData = new FormData();\n        for (const [key, value] of Object.entries(data)) {\n          formData.append(key, value);\n        }\n        opts.body = formData;\n      }\n    }\n\n    // Set method\n    opts.method = method;\n\n    // Create cache key from method, url, and stringified opts\n    const cacheKey = `${method}:${url}:${JSON.stringify(opts)}`;\n\n    // Check cache first (with TTL validation)\n    const cached = Fez._fetchCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < FETCH_CACHE_TTL) {\n      Fez.consoleLog(`fetch cache hit: ${method} ${url}`);\n      if (callback) {\n        callback(cached.data);\n        return;\n      }\n      return Promise.resolve(cached.data);\n    }\n\n    // Log live fetch\n    Fez.consoleLog(`fetch live: ${method} ${url}`);\n\n    // Helper to process and cache response\n    const processResponse = (response) => {\n      if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n        return response.json();\n      }\n      return response.text();\n    };\n\n    // Helper to store in cache with size limit\n    const storeInCache = (key, data) => {\n      // Enforce max cache size by removing oldest entries\n      if (Fez._fetchCache.size >= FETCH_CACHE_MAX_SIZE) {\n        const oldestKey = Fez._fetchCache.keys().next().value;\n        Fez._fetchCache.delete(oldestKey);\n      }\n      Fez._fetchCache.set(key, { data, timestamp: Date.now() });\n    };\n\n    // If callback provided, execute and handle\n    if (callback) {\n      fetch(url, opts)\n        .then(processResponse)\n        .then((data) => {\n          storeInCache(cacheKey, data);\n          callback(data);\n        })\n        .catch((error) => Fez.onError(\"fetch\", error));\n      return;\n    }\n\n    // Return promise with automatic JSON parsing\n    return fetch(url, opts)\n      .then(processResponse)\n      .then((data) => {\n        storeInCache(cacheKey, data);\n        return data;\n      });\n  };\n\n  // Clear fetch cache (useful for testing or manual cache invalidation)\n  Fez.clearFetchCache = () => {\n    Fez._fetchCache?.clear();\n  };\n\n  Fez.darkenColor = (color, percent = 20) => {\n    // Convert hex to RGB\n    const num = parseInt(color.replace(\"#\", \"\"), 16);\n    const amt = Math.round(2.55 * percent);\n    const R = (num >> 16) - amt;\n    const G = ((num >> 8) & 0x00ff) - amt;\n    const B = (num & 0x0000ff) - amt;\n    return (\n      \"#\" +\n      (\n        0x1000000 +\n        (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +\n        (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +\n        (B < 255 ? (B < 1 ? 0 : B) : 255)\n      )\n        .toString(16)\n        .slice(1)\n    );\n  };\n\n  Fez.lightenColor = (color, percent = 20) => {\n    // Convert hex to RGB\n    const num = parseInt(color.replace(\"#\", \"\"), 16);\n    const amt = Math.round(2.55 * percent);\n    const R = (num >> 16) + amt;\n    const G = ((num >> 8) & 0x00ff) + amt;\n    const B = (num & 0x0000ff) + amt;\n    return (\n      \"#\" +\n      (\n        0x1000000 +\n        (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +\n        (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +\n        (B < 255 ? (B < 1 ? 0 : B) : 255)\n      )\n        .toString(16)\n        .slice(1)\n    );\n  };\n\n  /**\n   * Escapes HTML special characters in a string\n   * Also strips font-family styles (common source of XSS via CSS)\n   */\n  Fez.htmlEscape = (text) => {\n    if (typeof text === \"string\") {\n      return text\n        .replace(/font-family\\s*:\\s*(?:&[^;]+;|[^;])*?;/gi, \"\") // Strip font-family (CSS safety)\n        .replaceAll(\"&\", \"&amp;\")\n        .replaceAll(\"'\", \"&apos;\")\n        .replaceAll('\"', \"&quot;\")\n        .replaceAll(\"<\", \"&lt;\")\n        .replaceAll(\">\", \"&gt;\");\n    }\n    return text === undefined ? \"\" : text;\n  };\n\n  // create dom root and return it\n  Fez.domRoot = (data, name = \"div\") => {\n    if (data instanceof Node) {\n      return data;\n    } else {\n      const root = document.createElement(name);\n      root.innerHTML = data;\n      return root;\n    }\n  };\n\n  // add class by name to node and remove it from siblings\n  Fez.activateNode = (node, klass = \"active\") => {\n    if (!node || !node.parentElement) return;\n    Array.from(node.parentElement.children).forEach((child) => {\n      child.classList.remove(klass);\n    });\n    node.classList.add(klass);\n  };\n\n  Fez.isTrue = (val) => {\n    return [\"1\", \"true\", \"on\"].includes(String(val).toLowerCase());\n  };\n\n  // get document unique ID\n  Fez.UID = 111;\n  Fez.uid = () => {\n    return \"fez_uid_\" + (++Fez.UID).toString(32);\n  };\n\n  // get global function pointer, used to pass functions to nested or inline elements\n  // <some-node :callback=\"${Fez.pointer(opts.callback)}\" ...>\n  // Pointers are automatically cleaned up after first use (one-time use by default)\n  // Use Fez.pointer(func, { persist: true }) to keep the pointer\n  Fez.POINTER_SEQ = 0;\n  Fez.POINTER = {};\n  Fez.pointer = (func, opts = {}) => {\n    if (typeof func == \"function\") {\n      const uid = ++Fez.POINTER_SEQ;\n\n      if (opts.persist) {\n        // Persistent pointer - stays until manually removed\n        Fez.POINTER[uid] = func;\n      } else {\n        // One-time use pointer - auto-cleanup after first call\n        Fez.POINTER[uid] = (...args) => {\n          const result = func(...args);\n          delete Fez.POINTER[uid];\n          return result;\n        };\n      }\n\n      return `Fez.POINTER[${uid}]`;\n    }\n  };\n\n  // Manually clear all pointers (useful for testing or cleanup)\n  Fez.clearPointers = () => {\n    Fez.POINTER = {};\n  };\n\n  // Resolve a function from a string or function reference\n  Fez.getFunction = (pointer) => {\n    if (!pointer) {\n      return () => {};\n    } else if (typeof pointer === \"function\") {\n      return pointer;\n    } else if (typeof pointer === \"string\") {\n      // Check if it's a function expression (arrow function or function keyword)\n      // Arrow function: (args) => or args =>\n      const arrowFuncPattern = /^\\s*\\(?\\s*\\w+(\\s*,\\s*\\w+)*\\s*\\)?\\s*=>/;\n      const functionPattern = /^\\s*function\\s*\\(/;\n\n      if (arrowFuncPattern.test(pointer) || functionPattern.test(pointer)) {\n        return new Function(\"return \" + pointer)();\n      } else if (pointer.includes(\".\") && !pointer.includes(\"(\")) {\n        // It's a property access like \"this.focus\" - return a function that calls it\n        return new Function(`return function() { return ${pointer}(); }`);\n      } else {\n        // It's a function body\n        return new Function(pointer);\n      }\n    }\n  };\n\n  // Execute a function when DOM is ready or immediately if already loaded\n  Fez.onReady = (callback) => {\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\n        \"DOMContentLoaded\",\n        () => {\n          callback();\n        },\n        { once: true },\n      );\n    } else {\n      callback();\n    }\n  };\n\n  // get unique id from string\n  Fez.fnv1 = (str) => {\n    var FNV_OFFSET_BASIS, FNV_PRIME, hash, i, j, ref;\n    FNV_OFFSET_BASIS = 2166136261;\n    FNV_PRIME = 16777619;\n    hash = FNV_OFFSET_BASIS;\n    for (\n      i = j = 0, ref = str.length - 1;\n      0 <= ref ? j <= ref : j >= ref;\n      i = 0 <= ref ? ++j : --j\n    ) {\n      hash ^= str.charCodeAt(i);\n      hash *= FNV_PRIME;\n    }\n    return hash.toString(36).replaceAll(\"-\", \"\");\n  };\n\n  Fez.tag = (tag, opts = {}, html = \"\") => {\n    const json = encodeURIComponent(JSON.stringify(opts));\n    return `<${tag} data-props=\"${json}\">${html}</${tag}>`;\n    // const json = JSON.stringify(opts, null, 2)\n    // const data = `<script type=\"text/template\">${json}</script><${tag} data-json-template=\"true\">${html}</${tag}>`\n    // return data\n  };\n\n  // execute function until it returns true\n  Fez.untilTrue = (func, pingRate) => {\n    pingRate ||= 200;\n\n    if (!func()) {\n      setTimeout(() => {\n        Fez.untilTrue(func, pingRate);\n      }, pingRate);\n    }\n  };\n\n  // Default throttle delay in ms\n  const DEFAULT_THROTTLE_DELAY = 200;\n\n  // throttle function calls\n  Fez.throttle = (func, delay = DEFAULT_THROTTLE_DELAY) => {\n    let lastRun = 0;\n    let timeout;\n\n    return function (...args) {\n      const now = Date.now();\n\n      if (now - lastRun >= delay) {\n        func.apply(this, args);\n        lastRun = now;\n      } else {\n        clearTimeout(timeout);\n        timeout = setTimeout(\n          () => {\n            func.apply(this, args);\n            lastRun = Date.now();\n          },\n          delay - (now - lastRun),\n        );\n      }\n    };\n  };\n\n  // Convert any collection to pairs for loop destructuring\n  // Array: ['a', 'b'] \u2192 [['a', 0], ['b', 1]] (value, index)\n  // Object: {x: 1} \u2192 [['x', 1]] (key, value)\n  Fez.toPairs = (c) => {\n    if (Array.isArray(c)) return c.map((v, i) => [v, i]);\n    if (c && typeof c === \"object\") return Object.entries(c);\n    return [];\n  };\n\n  // Returns short type identifier for data:\n  //   'o' - object, 'f' - function, 's' - string, 'a' - array, 'i' - integer, 'n' - float/number, 'u' - undefined/null\n  Fez.typeof = (data) => {\n    if (data === null || data === undefined) return \"u\";\n    if (Array.isArray(data)) return \"a\";\n    const t = typeof data;\n    if (t === \"function\") return \"f\";\n    if (t === \"string\") return \"s\";\n    if (t === \"number\") return Number.isInteger(data) ? \"i\" : \"n\";\n    if (t === \"object\") return \"o\";\n    return t[0];\n  };\n};\n", "// define custom style macro - simple scss mixin\n// :mobile { ... } -> @media (max-width:  768px) { ... }\n// @include mobile { ... } -> @media (max-width:  768px) { ... }\n// demo/fez/ui-style.fez\n\nconst CssMixins = {}\n\nexport default (Fez) => {\n  Fez.cssMixin = (name, content) => {\n    if (content) {\n      CssMixins[name] = content\n    } else {\n      Object.entries(CssMixins).forEach(([key, val])=>{\n        name = name.replaceAll(`:${key} `, `${val} `)\n        name = name.replaceAll(`@include ${key} `, `${val} `)\n      })\n\n      return name\n    }\n  }\n\n  Fez.cssMixin('mobile', '@media (max-width: 767px)')\n  Fez.cssMixin('tablet', '@media (min-width: 768px) and (max-width: 1023px)')\n  Fez.cssMixin('desktop', '@media (min-width:  1200px)')\n}\n", "/**\n * Fez - Main Framework Object\n *\n * This file contains:\n * - Main Fez function (component registration and lookup)\n * - Component registry\n * - CSS utilities\n * - Pub/Sub system\n * - DOM morphing\n * - Error handling\n * - Temporary store\n *\n * For component instance methods, see instance.js\n */\n\n// =============================================================================\n// IMPORTS\n// =============================================================================\n\nimport Gobber from \"./vendor/gobber.js\";\nimport { Idiomorph } from \"./vendor/idiomorph.js\";\nimport objectDump from \"./utils/dump.js\";\nimport highlightAll from \"./utils/highlight_all.js\";\nimport connect from \"./connect.js\";\nimport compile from \"./compile.js\";\nimport state from \"./lib/global-state.js\";\nimport createTemplate from \"./lib/template.js\";\nimport { subscribe, publish } from \"./lib/pubsub.js\";\nimport fezLocalStorage from \"./lib/localstorage.js\";\nimport fezAwait from \"./lib/await-helper.js\";\nimport index from \"./lib/index.js\";\n\n// =============================================================================\n// MAIN FEZ FUNCTION\n// =============================================================================\n\n/**\n * Main Fez function - register or find components\n *\n * @example\n * Fez('ui-foo', class { ... })  // Register component\n * Fez('ui-foo')                  // Find first instance\n * Fez(123)                       // Find by UID\n * Fez(domNode)                   // Find from DOM node\n * Fez('ui-foo', fn)              // Find all & execute callback\n *\n * @param {string|number|Node} name - Component name, UID, or DOM node\n * @param {Class|Function} [klass] - Component class or callback\n * @returns {FezBase|Array|void}\n */\nconst Fez = (name, klass) => {\n  // Find by UID\n  if (typeof name === \"number\") {\n    const fez = Fez.instances.get(name);\n    if (fez) return fez;\n    Fez.consoleError(`Instance with UID \"${name}\" not found.`);\n    return;\n  }\n\n  if (!name) {\n    Fez.consoleError(\"Fez() ?\");\n    return;\n  }\n\n  // With second argument\n  if (klass) {\n    const isPureFn =\n      typeof klass === \"function\" &&\n      !/^\\s*class/.test(klass.toString()) &&\n      !/\\b(this|new)\\b/.test(klass.toString());\n\n    // Fez('name', callback) - find all & execute\n    if (isPureFn) {\n      const list = Array.from(\n        document.querySelectorAll(`.fez.fez-${name}`),\n      ).filter((n) => n.fez);\n      list.forEach((el) => klass(el.fez));\n      return list;\n    }\n\n    // Fez('name', selector) - find with context\n    if (typeof klass !== \"function\") {\n      return Fez.find(name, klass);\n    }\n\n    // Fez('name', class) - register component\n    return connect(name, klass);\n  }\n\n  // Find instance by name or node\n  const node = name.nodeName\n    ? name.closest(\".fez\")\n    : document.querySelector(name.includes(\"#\") ? name : `.fez.fez-${name}`);\n\n  if (!node) {\n    Fez.consoleError(`node \"${name}\" not found.`);\n    return;\n  }\n\n  if (!node.fez) {\n    Fez.consoleError(`node \"${name}\" has no Fez attached.`);\n    return;\n  }\n\n  return node.fez;\n};\n\n// =============================================================================\n// COMPONENT REGISTRY\n// =============================================================================\n\n/** Unified component index - Fez.index['name'] = { class, meta, demo, info, source } */\nFez.index = index;\n\n/** Counter for unique instance IDs */\nFez.instanceCount = 0;\n\n/** Active component instances by UID */\nFez.instances = new Map();\n\n/**\n * Find a component instance from a DOM node\n * @param {Node|string} onode - DOM node or selector\n * @param {string} [name] - Optional component name filter\n * @returns {FezBase|undefined}\n */\nFez.find = (onode, name) => {\n  let node =\n    typeof onode === \"string\" ? document.body.querySelector(onode) : onode;\n\n  // jQuery compatibility\n  if (typeof node.val === \"function\") node = node[0];\n\n  const selector = name ? `.fez.fez-${name}` : \".fez\";\n  const closestNode = node.closest(selector);\n\n  if (closestNode?.fez) return closestNode.fez;\n\n  Fez.onError(\"find\", \"Node connector not found\", {\n    original: onode,\n    resolved: node,\n  });\n};\n\n// =============================================================================\n// CSS UTILITIES\n// =============================================================================\n\n/**\n * Generate unique CSS class from CSS text (via Goober)\n * @param {string} text - CSS rules\n * @returns {string} Generated class name\n */\nFez.cssClass = (text) => {\n  // In test environments without proper DOM, goober may fail\n  // Return a placeholder class name based on hash\n  try {\n    return Gobber.css(text);\n  } catch {\n    // Fallback: generate simple hash-based class name\n    let hash = 0;\n    for (let i = 0; i < text.length; i++) {\n      hash = ((hash << 5) - hash + text.charCodeAt(i)) | 0;\n    }\n    return \"fez-\" + Math.abs(hash).toString(36);\n  }\n};\n\n/**\n * Register global CSS styles\n * @param {string|Function} cssClass - CSS text or function\n * @param {Object} opts - { name, wrap }\n * @returns {string} Generated class name\n */\nFez.globalCss = (cssClass, opts = {}) => {\n  if (typeof cssClass === \"function\") cssClass = cssClass();\n\n  if (cssClass.includes(\":\")) {\n    let text = cssClass\n      .split(\"\\n\")\n      .filter((line) => !/^\\s*\\/\\//.test(line))\n      .join(\"\\n\");\n\n    if (opts.wrap) text = `:fez { ${text} }`;\n    text = text.replace(/\\:fez|\\:host/, `.fez.fez-${opts.name}`);\n    cssClass = Fez.cssClass(text);\n  }\n\n  Fez.onReady(() => document.body.parentElement.classList.add(cssClass));\n  return cssClass;\n};\n\n// =============================================================================\n// DOM MORPHING\n// =============================================================================\n\n/**\n * Shallow equality check for props\n */\nfunction shallowEqual(obj1, obj2) {\n  if (obj1 === obj2) return true;\n  if (!obj1 || !obj2) return false;\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n  for (const key of keys1) {\n    if (obj1[key] !== obj2[key]) return false;\n  }\n  return true;\n}\n\n/**\n * Morph DOM node to new state (via Idiomorph)\n * Preserves child Fez components and only updates their props if changed\n * @param {Element} target - Element to morph\n * @param {Element} newNode - New state\n */\nFez.morphdom = (target, newNode) => {\n  // Preserve attributes\n  Array.from(target.attributes).forEach((attr) => {\n    newNode.setAttribute(attr.name, attr.value);\n  });\n\n  Idiomorph.morph(target, newNode, {\n    morphStyle: \"outerHTML\",\n    ignoreActiveValue: true,\n    callbacks: {\n      // Skip morphing child fez components - preserve them entirely\n      beforeNodeMorphed: (oldNode, newNode) => {\n        // Check if this is a child fez component (not the root being morphed)\n        if (\n          oldNode !== target &&\n          oldNode.classList?.contains(\"fez\") &&\n          oldNode.fez &&\n          !oldNode.fez._destroyed\n        ) {\n          Fez.consoleLog(\n            `Preserving child component ${oldNode.fez.fezName} (UID ${oldNode.fez.UID})`,\n          );\n\n          // Get new props from the newNode\n          const newProps =\n            Fez.index[oldNode.fez.fezName]?.class?.getProps?.(\n              newNode,\n              oldNode,\n            ) || {};\n          const oldProps = oldNode.fez.props || {};\n\n          // Only trigger update if props actually changed\n          if (!shallowEqual(oldProps, newProps)) {\n            oldNode.fez.props = newProps;\n            oldNode.fez.onPropsChange?.(newProps, oldProps);\n            // Schedule re-render of child with new props\n            oldNode.fez.fezNextTick(oldNode.fez.fezRender, \"fezRender\");\n          }\n\n          // Return false to skip morphing this element - preserve it as is\n          return false;\n        }\n        return true;\n      },\n\n      // When removing a node, check if it's a fez component and cleanup\n      beforeNodeRemoved: (node) => {\n        if (node.classList?.contains(\"fez\") && node.fez) {\n          node.fez.fezOnDestroy();\n        }\n        return true;\n      },\n    },\n  });\n\n  // Clean up whitespace\n  const next = target.nextSibling;\n  if (next?.nodeType === Node.TEXT_NODE && !next.textContent.trim()) {\n    next.remove();\n  }\n};\n\n// =============================================================================\n// PUB/SUB SYSTEM (see lib/pubsub.js)\n// =============================================================================\n\nFez.subscribe = subscribe;\nFez.publish = publish;\n\n// =============================================================================\n// LOCAL STORAGE (see lib/localstorage.js)\n// =============================================================================\n\nFez.localStorage = fezLocalStorage;\n\n// =============================================================================\n// ASYNC AWAIT HELPER (see lib/await-helper.js)\n// =============================================================================\n\nFez.fezAwait = fezAwait;\n\n// =============================================================================\n// ERROR HANDLING & LOGGING\n// =============================================================================\n\nFez.consoleError = (text, show) => {\n  text = `Fez: ${text}`;\n  console.error(text);\n  if (show) {\n    return `<span style=\"border: 1px solid red; font-size: 14px; padding: 3px 7px; background: #fee; border-radius: 4px;\">${text}</span>`;\n  }\n};\n\nFez.consoleLog = (text) => {\n  if (Fez.LOG) {\n    console.log(`Fez: ${String(text).substring(0, 180)}`);\n  }\n};\n\n/** Error handler - can be overridden */\nFez.onError = (kind, message, context) => {\n  const errorMsg = `Fez ${kind}: ${message?.toString?.() || message}`;\n  console.error(errorMsg, context || \"\");\n  return errorMsg;\n};\n\n// =============================================================================\n// LOAD UTILITIES & EXPORTS\n// =============================================================================\n\nimport addUtilities from \"./utility.js\";\nimport cssMixin from \"./utils/css_mixin.js\";\n\naddUtilities(Fez);\ncssMixin(Fez);\n\nFez.compile = compile;\nFez.createTemplate = createTemplate;\nFez.state = state;\nFez.log = objectDump;\nFez.highlightAll = highlightAll;\n\nFez.onReady(() => Fez.consoleLog(\"Fez.LOG === true, logging enabled.\"));\n\nexport default Fez;\n", "/**\n * Fez - Runtime Custom DOM Elements Library\n *\n * Entry point that:\n * - Exports FezBase and Fez\n * - Sets up auto-compilation observer\n * - Handles garbage collection\n */\n\n// =============================================================================\n// EXPORTS\n// =============================================================================\n\nimport FezBase from './fez/instance.js'\nimport Fez from './fez/root.js'\n\n// Expose to window\nif (typeof window !== 'undefined') {\n  window.FezBase = FezBase\n  window.Fez = Fez\n}\n\n// Load default components\nimport('./fez/defaults.js')\n\n// =============================================================================\n// AUTO-COMPILATION OBSERVER\n// =============================================================================\n\n// Watch for template/xmp/script[fez] elements and compile them\nconst observer = new MutationObserver(mutations => {\n  for (const { addedNodes, removedNodes } of mutations) {\n    // Compile new fez templates\n    addedNodes.forEach(node => {\n      if (node.nodeType !== 1) return\n\n      if (node.matches?.('template[fez], xmp[fez], script[fez]')) {\n        Fez.compile(node)\n        node.remove()\n      }\n\n      node.querySelectorAll?.('template[fez], xmp[fez], script[fez]').forEach(tpl => {\n        Fez.compile(tpl)\n        tpl.remove()\n      })\n    })\n\n    // Cleanup removed components\n    // Use microtask to check if node was just moved (will be reconnected)\n    // vs actually removed from the document\n    removedNodes.forEach(node => {\n      if (node.nodeType !== 1) return\n\n      // Helper to cleanup a single element\n      const cleanup = (el) => {\n        if (el.fez && !el.fez._destroyed) {\n          // Delay cleanup to check if node is reconnected (just moved, not removed)\n          queueMicrotask(() => {\n            // If still not connected and not destroyed, cleanup\n            if (!el.isConnected && el.fez && !el.fez._destroyed) {\n              Fez.instances.delete(el.fez.UID)\n              el.fez.fezOnDestroy()\n            }\n          })\n        }\n      }\n\n      // Check if removed node itself is a fez component\n      cleanup(node)\n\n      // Check all children for fez components\n      node.querySelectorAll?.('.fez')?.forEach(cleanup)\n    })\n  }\n})\n\nobserver.observe(document.documentElement, {\n  childList: true,\n  subtree: true\n})\n\n// =============================================================================\n// MODULE EXPORTS\n// =============================================================================\n\nexport default Fez\nexport { Fez, FezBase }\n"],
  "mappings": "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",
  "names": ["defaults_exports", "__export", "loadDefaults", "init_defaults", "__esmMin", "props", "tag", "data", "dom", "urlParams", "name", "url", "checkReady", "names", "html", "demo", "code", "body", "form", "input", "el", "n", "name", "attrs", "data", "parts", "c", "node", "k", "v", "value", "parseLoopBinding", "binding", "match", "s", "parts", "getLoopVarNames", "parsed", "names", "getLoopItemVars", "buildCollectionExpr", "collection", "buildLoopParams", "destructure", "indexName", "params", "index", "isArrowFunction", "expr", "transformArrowToHandler", "loopVars", "loopItemVars", "arrowMatch", "body", "eventParam", "hasEventParam", "varName", "eventRegex", "funcName", "varRegex", "extractBracedExpression", "text", "startIndex", "depth", "i", "char", "quote", "getAttributeContext", "pos", "j", "attrEnd", "attrName", "getEventAttributeContext", "attr", "createSvelteTemplate", "text", "opts", "componentName", "blocks", "_", "name", "content", "match", "attr", "expr", "result", "i", "ifStack", "loopVarStack", "loopItemVarStack", "loopStack", "awaitStack", "awaitCounter", "depth", "expression", "endIndex", "extractBracedExpression", "cond", "loopInfo", "hasElse", "isEach", "collection", "binding", "rest", "asIdx", "inIdx", "collectionExpr", "buildCollectionExpr", "loopParams", "buildLoopParams", "getLoopVarNames", "getLoopItemVars", "promiseExpr", "awaitId", "awaitInfo", "isArrowFunction", "getEventAttributeContext", "allLoopVars", "allItemVars", "handler", "transformArrowToHandler", "getAttributeContext", "funcBody", "tplFunc", "ctx", "e", "cache", "createTemplate", "text", "opts", "hasLegacySyntax", "convertLegacySyntax", "fn", "createSvelteTemplate", "hasLegacySyntax", "text", "convertLegacySyntax", "componentName", "globalSubs", "componentSubs", "subscribe", "nodeOrSelector", "channelOrCallback", "callback", "selector", "node", "channel", "channelSubs", "sub", "subscription", "publish", "args", "target", "e", "comp", "cb", "componentSubscribe", "component", "componentPublish", "handlePublish", "c", "parent", "FezBase", "node", "newNode", "attrs", "attr", "key", "val", "newVal", "e", "data", "formNode", "formData", "formObject", "value", "n", "kind", "message", "context", "name", "v", "callback", "text", "base", "func", "template", "nodeName", "renderedTpl", "createTemplate", "savedInputValues", "el", "saved", "input", "fetchAttr", "target", "classes", "lastClass", "c", "isCb", "eventName", "newEl", "isSlot", "oldEl", "candidates", "parent", "isNested", "child", "method", "obj", "handler", "o", "k", "oldValue", "createReactive", "property", "receiver", "currentValue", "result", "selector", "children", "prop", "klass", "inNode", "nodes", "delay", "throttledFunc", "observer", "timeoutID", "tick", "intervalID", "channel", "args", "componentPublish", "unsubscribe", "componentSubscribe", "source", "e", "t", "a", "r", "l", "s", "n", "o", "c", "i", "p", "u", "d", "f", "g", "b", "m", "h", "y", "gobber_default", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromAttributes", "toAttributes", "fromAttribute", "syncClassList", "error", "i", "toAttribute", "syncInputValue", "fromClasses", "toClasses", "cls", "syncBooleanAttribute", "attributeName", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "log", "mergeDefaults", "finalConfig", "createIdMap", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "log_pretty_print", "html", "parts", "p", "indent", "lines", "i", "part", "nextPart", "nextNextPart", "actualIndent", "LOG", "logs", "logTypes", "currentIndex", "renderContent", "e", "dialog", "button", "createLogButton", "showLogDialog", "btn", "existingBtn", "d", "savedIndex", "buttons", "_", "bgColor", "o", "originalType", "key", "value", "dump_default", "highlightAll", "port", "existingHighlights", "el", "componentName", "componentType", "overlay", "rect", "scrollTop", "scrollLeft", "label", "e", "event", "highlight_all_default", "SELF_CLOSING_TAGS", "attrObserver", "mutations", "mutation", "fez", "name", "value", "connect", "klass", "Fez", "ensureFezBase", "slotTag", "createTemplate", "shouldRenderFast", "connectNode", "FezBase", "closeCustomTags", "instance", "newKlass", "props", "p", "prop", "configMap", "from", "to", "html", "match", "tag", "attrs", "node", "attr", "klassFast", "nodeName", "newNode", "form", "e", "key", "dedent", "text", "lines", "nonEmptyLines", "l", "minIndent", "hasTopLevelFezElements", "html", "withoutDemo", "compile", "tagName", "compileBulk", "parts", "compileToClass", "classCode", "generateClassCode", "hideCustomElement", "executeClassCode", "data", "node", "fezName", "compileFromUrl", "n", "url", "content", "fezElements", "fileName", "el", "name", "error", "compileToClass", "html", "result", "lines", "block", "type", "line", "trimmedLine", "dedent", "processHeadElements", "headHtml", "container", "node", "script", "attr", "generateClassCode", "tagName", "parts", "klass", "css", "before", "after", "executeClassCode", "code", "e", "hideCustomElement", "styleEl", "allTags", "GlobalState", "key", "value", "oldValue", "listeners", "comp", "error", "subscribers", "func", "component", "target", "keyOrFunc", "keySubscribers", "global_state_default", "storage", "set", "key", "value", "e", "get", "defaultValue", "item", "remove", "clear", "localstorage_default", "awaitHelper", "component", "awaitId", "promiseOrValue", "existing", "state", "value", "current", "error", "createDomNode", "html", "node", "index", "name", "entry", "target", "tempDiv", "script", "content", "e", "k", "result", "lib_default", "utility_default", "Fez", "config", "callback", "n", "src", "attributes", "elementType", "fezPath", "content", "basePath", "lines", "line", "loaded", "total", "componentPath", "path", "name", "componentContent", "script", "error", "key", "value", "existingNode", "element", "module", "FETCH_CACHE_TTL", "FETCH_CACHE_MAX_SIZE", "args", "method", "url", "opts", "data", "params", "formData", "cacheKey", "cached", "processResponse", "response", "storeInCache", "oldestKey", "color", "percent", "num", "amt", "R", "G", "B", "text", "root", "node", "klass", "child", "val", "func", "uid", "result", "pointer", "arrowFuncPattern", "functionPattern", "str", "FNV_OFFSET_BASIS", "FNV_PRIME", "hash", "i", "j", "ref", "tag", "html", "json", "pingRate", "DEFAULT_THROTTLE_DELAY", "delay", "lastRun", "timeout", "now", "c", "v", "t", "CssMixins", "css_mixin_default", "Fez", "name", "content", "key", "val", "Fez", "name", "klass", "fez", "list", "n", "el", "connect", "node", "lib_default", "onode", "selector", "closestNode", "text", "gobber_default", "hash", "i", "cssClass", "opts", "line", "shallowEqual", "obj1", "obj2", "keys1", "keys2", "key", "target", "newNode", "attr", "Idiomorph", "oldNode", "newProps", "oldProps", "next", "subscribe", "publish", "localstorage_default", "awaitHelper", "show", "kind", "message", "context", "errorMsg", "utility_default", "css_mixin_default", "compile", "createTemplate", "global_state_default", "dump_default", "highlight_all_default", "root_default", "FezBase", "root_default", "observer", "mutations", "addedNodes", "removedNodes", "node", "tpl", "cleanup", "el", "fez_default"]
}
