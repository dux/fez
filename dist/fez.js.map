{
  "version": 3,
  "sources": ["../src/lib/stache.js", "../src/lib/idiomorph.js", "../src/lib/gobber.js", "../src/lib/n.js", "../src/fez.js"],
  "sourcesContent": ["// https://github.com/ryanmorr/stache\nexport default function renderStache(tpl, context) {\n  const NEW_LINES_RE = /(\\r\\n|\\r|\\n)/g;\n  const TEMPLATE_RE = /{{\\s*(.+?)\\s*}}/g;\n  const EACH_RE = /^each\\s+(.*)\\s+as\\s+(.*)$/;\n  const IF_RE = /^if\\s+(.*)$/;\n  const ELSE_IF_RE = /^else if\\s+(.*)$/;\n\n  function stache(source) {\n    const monkey = (t) => t.replaceAll('@', 'this.')\n\n    let func = `\n      let _strings = [], _sequence = [], _values = [];\n\n      function htmlEscape(text) {\n        if (typeof text === 'string') {\n          return text\n            .replaceAll(\"'\", '&apos;')\n            .replaceAll('\"', '&quot;')\n            .replaceAll('<', '&lt;')\n            .replaceAll('>', '&gt;')\n        } else {\n          return text\n        }\n      }\n\n      _sequence.push('${\n        source.trim().replace(NEW_LINES_RE, '\\\\n').replace(TEMPLATE_RE, (all, code) => {\n          // {{#if -> {{#if\n          code = code.replace(/^[#:]/, '')\n\n          if (code.startsWith('each') || code.startsWith('for')) {\n            // support fro #for\n            const parts = code.split(/\\s+/)\n            if (parts.shift() === 'for') {\n              const list = parts.pop()\n              parts.pop()\n              code = `each ${list} as ${parts.join(' ')}`\n            }\n\n            let loop = EACH_RE.exec(code);\n            if (loop) {\n                loop[1] = monkey(loop[1])\n                return `');\\n (!Array.isArray(${loop[1]}) ? Array.from(Object.entries(${loop[1]} || []), ([key, value]) => [key, value]) : ${loop[1]}).forEach((${loop[2]}) => { _sequence.push('`\n              }\n          } else if (code.startsWith('if')) {\n            let conditional = (IF_RE).exec(code);\n            if (conditional) {\n              conditional[1] = monkey(conditional[1])\n              return `');\\n if (${conditional[1]}) { _sequence.push('`\n            }\n          } else if (code.startsWith('else if')) {\n            let conditionalElse = (ELSE_IF_RE).exec(code);\n            if (conditionalElse) {\n              conditionalElse[1] = monkey(conditionalElse[1])\n              return `');\\n } else if (${conditionalElse[1]}) { _sequence.push('`\n            }\n          } else if (code === 'else') {\n            return `');\\n } else { _sequence.push('` // eslint-disable-line quotes\n          } else if (code === '/each' || code === '/for') {\n            return `');\\n }); _sequence.push('` // eslint-disable-line quotes\n          } else if (code === '/if') {\n            return `');\\n } _sequence.push('` // eslint-disable-line quotes\n          }\n\n          // support for @html -> {{@html raw}} -> same as in svelte\n          const codeParts = code.split(/^\\@html\\s+/)\n          if (codeParts[1]) {\n            code = monkey(codeParts[1])\n          } else {\n            code = `htmlEscape(${monkey(code)})`\n          }\n\n          return `');\\n _strings.push(_sequence.join(''));\\n _sequence = [];\\n _values.push(${code});\\n _sequence.push('`;\n        })\n      }');\n      _strings.push(_sequence.join(''));\n      return [_strings, _values];\n    `\n\n    // console.log(func)\n    return new Function('_data', func);\n  }\n\n  function createTemplate(source) {\n    const tpl = stache(source);\n    return () => {\n      const [strings, values] = tpl.bind(context)();\n      return strings.reduce((acc, str, i) => acc + (values[i - 1]) + str);\n    };\n  }\n\n  function closeCustomTags(html) {\n    const selfClosingTags = new Set([\n      'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'source', 'track', 'wbr'\n    ])\n\n    return html.replace(/<([a-z-]+)\\b([^>]*)\\/>/g, (match, tagName, attributes) => {\n      return selfClosingTags.has(tagName) ? match : `<${tagName}${attributes}></${tagName}>`\n    })\n  }\n\n  tpl = closeCustomTags(tpl)\n  const out = createTemplate(tpl)().replace(/\\n\\s*\\n/g, \"\\n\")\n  return out\n}\n", "// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n", "/**\n * Skipped minification because the original files appears to be already minified.\n * Original file: /npm/goober@2.1.14/dist/goober.modern.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\nlet e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,a=e=>{let a=t(e),r=a.data;return a.data=\"\",r},r=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,l=/\\/\\*[^]*?\\*\\/|  +/g,s=/\\n+/g,n=(e,t)=>{let a=\"\",r=\"\",l=\"\";for(let s in e){let o=e[s];\"@\"==s[0]?\"i\"==s[1]?a=s+\" \"+o+\";\":r+=\"f\"==s[1]?n(o,s):s+\"{\"+n(o,\"k\"==s[1]?\"\":t)+\"}\":\"object\"==typeof o?r+=n(o,t?t.replace(/([^,])+/g,(e=>s.replace(/(^:.*)|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)))):s):null!=o&&(s=/^--/.test(s)?s:s.replace(/[A-Z]/g,\"-$&\").toLowerCase(),l+=n.p?n.p(s,o):s+\":\"+o+\";\")}return a+(t&&l?t+\"{\"+l+\"}\":l)+r},o={},c=e=>{if(\"object\"==typeof e){let t=\"\";for(let a in e)t+=a+c(e[a]);return t}return e},i=(e,t,a,i,p)=>{let u=c(e),d=o[u]||(o[u]=(e=>{let t=0,a=11;for(;t<e.length;)a=101*a+e.charCodeAt(t++)>>>0;return\"go\"+a})(u));if(!o[d]){let t=u!==e?e:(e=>{let t,a,n=[{}];for(;t=r.exec(e.replace(l,\"\"));)t[4]?n.shift():t[3]?(a=t[3].replace(s,\" \").trim(),n.unshift(n[0][a]=n[0][a]||{})):n[0][t[1]]=t[2].replace(s,\" \").trim();return n[0]})(e);o[d]=n(p?{[\"@keyframes \"+d]:t}:t,a?\"\":\".\"+d)}let f=a&&o.g?o.g:null;return a&&(o.g=o[d]),((e,t,a,r)=>{r?t.data=t.data.replace(r,e):-1===t.data.indexOf(e)&&(t.data=a?e+t.data:t.data+e)})(o[d],t,i,f),d},p=(e,t,a)=>e.reduce(((e,r,l)=>{let s=t[l];if(s&&s.call){let e=s(a),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;s=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":n(e,\"\"):!1===e?\"\":e}return e+r+(null==s?\"\":s)}),\"\");function u(e){let a=this||{},r=e.call?e(a.p):e;return i(r.unshift?r.raw?p(r,[].slice.call(arguments,1),a.p):r.reduce(((e,t)=>Object.assign(e,t&&t.call?t(a.p):t)),{}):r,t(a.target),a.g,a.o,a.k)}let d,f,g,b=u.bind({g:1}),m=u.bind({k:1});function h(e,t,a,r){n.p=t,d=e,f=a,g=r}function y(e,t){let a=this||{};return function(){let r=arguments;function l(s,n){let o=Object.assign({},s),c=o.className||l.className;a.p=Object.assign({theme:f&&f()},o),a.o=/ *go\\d+/.test(c),o.className=u.apply(a,r)+(c?\" \"+c:\"\"),t&&(o.ref=n);let i=e;return e[0]&&(i=o.as||e,delete o.as),g&&i[0]&&g(o),d(i,o)}return t?t(l):l}}\nexport default { css:u, extractCss: a, glob: b, keyframes: m, setup: h, styled: y }\n", "// copyright @dux, 2024\n// Licence MIT\n\nexport default function n(name, attrs = {}, data) {\n  if (typeof attrs === 'string') {\n    [attrs, data] = [data, attrs]\n    attrs ||= {}\n  }\n\n  if (attrs instanceof Node) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (Array.isArray(name)) {\n    data = name\n    name = 'div'\n  }\n\n  if (typeof attrs !== 'object' || Array.isArray(attrs)) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (name.includes('.')) {\n    const parts = name.split('.')\n    name = parts.shift() || 'div'\n    const c = parts.join(' ');\n    if (attrs.class) {\n      attrs.class += ` ${c}`;\n    } else {\n      attrs.class = c\n    }\n  }\n\n  const node = document.createElement(name);\n\n  for (const [k, v] of Object.entries(attrs)) {\n    if (typeof v === 'function') {\n      node[k] = v.bind(this)\n    } else {\n      const value = String(v).replaceAll('$$.', this.fezHtmlRoot);\n      node.setAttribute(k, value)\n    }\n  }\n\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const n of data) {\n        node.appendChild(n)\n      }\n    } else if (data instanceof Node) {\n      node.appendChild(data)\n    } else {\n      node.innerHTML = String(data)\n    }\n  }\n\n  return node\n}\n", "// templating\nimport renderStache from './lib/stache'\n\n// morph dom from one state to another\nimport { Idiomorph } from './lib/idiomorph'\n\n// runtime scss\nimport Gobber from './lib/gobber'\n\n// HTML node builder\nimport parseNode from './lib/n'\n\nclass FezBase {\n  static __objects = []\n\n  static find(node, name) {\n    return Fez.find(node, name)\n  }\n\n  // get unique id from string\n  static fnv1(str) {\n    var FNV_OFFSET_BASIS, FNV_PRIME, hash, i, j, ref;\n    FNV_OFFSET_BASIS = 2166136261;\n    FNV_PRIME = 16777619;\n    hash = FNV_OFFSET_BASIS;\n    for (i = j = 0, ref = str.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n      hash ^= str.charCodeAt(i);\n      hash *= FNV_PRIME;\n    }\n    return hash.toString(36).replaceAll('-', '');\n  }\n\n  // get node attributes as object\n  static getProps(node) {\n    const attrs = {}\n    for (const attr of node.attributes) {\n      attrs[attr.name] = attr.value\n    }\n    return attrs\n  }\n\n  static formData(node) {\n    const formData = new FormData(node.closest('form'))\n    const formObject = {}\n    formData.forEach((value, key) => {\n      formObject[key] = value\n    });\n    return formObject\n  }\n\n  static fastBind() {\n    // return true to bind without requestAnimationFrame\n    // you can do this if you are sure you are not expecting innerHTML data\n    return false\n  }\n\n  // instance methods\n\n  constructor() {\n    this.__int = {}\n  }\n\n  n = parseNode\n\n  // string selector for use in HTML nodes\n  get fezHtmlRoot() {\n    return `Fez.find(this, \"${this.fezName}\").`\n  }\n\n  // checks if node is attached and clears all if not\n  get isAttached() {\n    if (this.root?.parentNode) {\n      return true\n    } else {\n      Object.keys(this.__int).forEach((key)=> {\n        clearInterval(this.__int[key])\n      })\n      this.root.fez = null\n      this.root = null\n      return false\n    }\n  }\n\n  // get single node property\n  prop(name) {\n    let v = this.oldRoot[name] || this.props[name]\n    if (typeof v == 'function') {\n      // if @prop('onclick'), we want \"this\" to point to this.root (dom node)\n      v = v.bind(this.root)\n    }\n    return v\n  }\n\n  // copy attributes to root node\n  copy() {\n    for (const name of Array.from(arguments)) {\n      let value = this.props[name]\n\n      if (value !== undefined) {\n        if (name == 'class') {\n          const klass = this.root.getAttribute(name, value)\n\n          if (klass) {\n            value = [klass, value].join(' ')\n          }\n        }\n\n        if (typeof value == 'string') {\n          this.root.setAttribute(name, value)\n        } else {\n          this.root[name] = value\n        }\n      }\n    }\n  }\n\n  // copy child nodes, natively to preserve bound events\n  // if node name is SLOT insert adjacent and remove SLOT, else as a child nodes\n  slot(source, target) {\n    target ||= document.createElement('template')\n    const isSlot = target.nodeName == 'SLOT'\n\n    while (source.firstChild) {\n      if (isSlot) {\n        target.parentNode.insertBefore(source.lastChild, target.nextSibling);\n      } else {\n        target.appendChild(source.firstChild)\n      }\n    }\n\n    if (isSlot) {\n      target.parentNode.removeChild(target)\n    } else {\n      source.innerHTML = ''\n    }\n\n    return target\n  }\n\n  style() { console.error('call Fez static style') }\n\n  connect() {\n    console.error('Fez is missing \"connect\" method.', this.root)\n  }\n\n  parseHtml(text, context) {\n    if (typeof text == 'object') {\n      text = text[0]\n    }\n\n    text = text.replaceAll('$$.', this.fezHtmlRoot.replaceAll('\"', '&quot;'))\n\n    if (text.includes('{{')) {\n      try {\n        // TODO: return template function pointer\n        text = renderStache(text, this)\n      } catch(error) {\n        console.error(`Fez stache template error in \"${this.fezName}\"`, error)\n      }\n    }\n\n    // text = text.replaceAll('>,<', \"><\").replace(/\\s*undefined\\s*/g, '')\n\n    return text\n  }\n\n  // inject htmlString as innerHTML and replace $$. with local pointer\n  // $$. will point to current fez instance\n  // <slot></slot> will be replaced with current root\n  // this.html('...loading')\n  // this.html('.images', '...loading')\n  html(target, body) {\n    if (!target) {\n      target = this.class.html\n    }\n\n    if (typeof body == 'undefined') {\n      body = target\n      target = this.root\n    }\n\n    if (typeof target == 'string') {\n      target = this.find(target)\n    }\n\n    const newNode = document.createElement('div')\n\n    if (Array.isArray(body)) {\n      if (body[0] instanceof Node) {\n        body.forEach((n)=>{\n          newNode.appendChild(n)\n        })\n      } else {\n        body = body.join('')\n      }\n    } else if (typeof body === 'string') {\n      newNode.innerHTML = this.parseHtml(body)\n    } else {\n      newNode.appendChild(body)\n    }\n\n    const slot = newNode.querySelector('slot')\n    if (slot) {\n      this.slot(target, slot)\n    }\n\n    // old way, just replace\n    // target.innerHTML = ''\n    // this.slot(newNode, target)\n\n    Fez.morphdom(target, newNode)\n\n    const fetchAttr = (name, func) => {\n      target.querySelectorAll(`*[${name}]`).forEach((n)=>{\n        let value = n.getAttribute(name)\n        n.removeAttribute(name)\n        if (value) {\n          func.bind(this)(value, n)\n        }\n      })\n    }\n\n    fetchAttr('fez-this', (value, n) => {\n      this[value] = n\n    })\n\n    fetchAttr('fez-use', (value, n) => {\n      const target = this[value]\n      if (typeof target == 'function') {\n        target(n)\n      } else {\n        console.error(`Fez error: \"${value}\" is not a function in ${this.fezName}`)\n      }\n    })\n\n    fetchAttr('fez-class', (value) => {\n      let classes = value.split(/\\s+/)\n      let lastClass = classes.pop()\n      classes.forEach((c)=> n.classList.add(c) )\n      if (lastClass) {\n        setTimeout(()=>{\n          n.classList.add(lastClass)\n        }, 1000)\n      }\n    })\n  }\n\n  // run only if node is attached, clear otherwise\n  setInterval(func, tick, name) {\n    if (typeof func == 'number') {\n      [tick, func] = [func, tick]\n    }\n\n    name ||= this.class.fnv1(String(func))\n\n    clearInterval(this.__int[name])\n\n    this.__int[name] = setInterval(() => {\n      if (this.isAttached) {\n        func()\n      }\n    }, tick)\n\n    return this.__int[name]\n  }\n\n  // add css class for scss styled text\n  css(text, isGlobal) {\n    const className = Fez.css(text)\n\n    if (isGlobal) {\n      this.root.classList.add(className)\n    }\n\n    return className\n  }\n\n  find(selector) {\n    return this.root.querySelector(selector)\n  }\n\n  val(selector, data) {\n    const node = this.find('.time')\n\n    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(node.nodeName)) {\n      node.value = data\n    } else {\n      node.innerHTML = new Date()\n    }\n  }\n\n  formData(node) {\n    return this.class.formData(node || this.root)\n  }\n\n  // get or set attribute\n  attr(name, value) {\n    if (typeof value === 'undefined') {\n      return this.root.getAttribute(name)\n    } else {\n      this.root.setAttribute(name, value)\n      return value\n    }\n  }\n\n  // get root node child nodes as array\n  childNodes(func) {\n    const list = Array.from(this.root.querySelectorAll(\":scope > *\"))\n\n    if (func) {\n      list.forEach(func)\n    } else {\n      return list\n    }\n  }\n\n  subscribe(channel, func) {\n    Fez._subs ||= {}\n    Fez._subs[channel] ||= []\n    Fez._subs[channel] = Fez._subs[channel].filter((el) => el[0].isAttached)\n    Fez._subs[channel].push([this, func])\n  }\n\n  fezRegister() {\n    if (this.class.css) {\n      if (typeof this.class.css == 'function') {\n        this.class.css = this.class.css(this)\n      }\n\n      if (this.class.css.includes(':')) {\n        this.class.css = Fez.css(this.class.css)\n      }\n      this.root.classList.add(this.class.css)\n    }\n\n    this.fezRegisterBindMethods()\n  }\n\n  // bind all instance method to this, to avoid calling with .bind(this)\n  fezRegisterBindMethods() {\n    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n      .filter(method => method !== 'constructor' && typeof this[method] === 'function')\n\n    methods.forEach(method => this[method] = this[method].bind(this))\n  }\n}\n\n// clear all unnatached nodes\nsetInterval(() => {\n  FezBase.__objects = FezBase.__objects.filter(\n    (el) => el.isAttached\n  )\n}, 10_000)\n\n//\n\nconst observer = new MutationObserver((mutationsList, _) => {\n  for (const mutation of mutationsList) {\n    if (mutation.type === 'attributes') {\n      const fez = mutation.target.fez\n      const name = mutation.attributeName\n      const value = mutation.target.getAttribute(name)\n      fez.props[name] = value\n      fez.onPropsChange(name, value)\n      // console.log(`The [${name}] attribute was modified to [${value}].`);\n    }\n  }\n});\n\nconst Fez = (name, klass) => {\n  function connect() {\n    const parentNode = this.parentNode\n    if (parentNode) {\n      const nodeName = typeof klass.nodeName == 'function' ? klass.nodeName(this) : klass.nodeName\n      const newNode = document.createElement(nodeName || 'div')\n\n      newNode.classList.add('fez')\n      newNode.classList.add(`fez-${name}`)\n\n      parentNode.replaceChild(newNode, this);\n\n      const object =  new klass()\n      object.oldRoot = this\n      object.fezName = name\n      object.root = newNode\n      object.props = klass.getProps(this)\n      object.class = klass\n\n      // copy child nodes, natively to preserve bound events\n      object.slot(this, newNode)\n\n      newNode.fez = object\n\n      if (window.$) {\n        object.$root = $(newNode)\n      }\n\n      if (object.props.id) {\n        newNode.setAttribute('id', object.props.id)\n      }\n\n      object.fezRegister()\n      object.connect(object.props)\n      klass.__objects.push(object)\n\n      if (klass.html) {\n        if (typeof klass.html == 'function') {\n          klass.html = klass.html(this)\n        }\n        object.html()\n      }\n\n      if (object.onPropsChange) {\n        observer.observe(newNode, {attributes:true})\n      }\n    }\n  }\n\n  function forceFastRender(n) {\n    return typeof klass.fastBind === 'function' ? klass.fastBind(n) : klass.fastBind\n  }\n\n  if (!name) {\n    return FezBase\n  }\n\n  if (typeof klass != 'function') {\n    return Fez.find(name, klass)\n  }\n\n  customElements.define(name, class extends HTMLElement {\n    connectedCallback() {\n      // when we render nested fez components, and under Svelte, sometimes node innerHTML is empty, but it should not be\n      // in that case, we need to wait for another tick to get content\n      // this solution looks like it is not efficient, because it slow renders fez components that do not have and are not intended to have body, but by testing this looks like it is not effecting render performance\n      // if you want to force fast render, add static fastBind = true or check\n      if (this.firstChild || forceFastRender(this)) {\n        Fez.info(`fast bind: ${name}`)\n        connect.bind(this)()\n      } else {\n        Fez.info(`slow bind: ${name}`)\n        window.requestAnimationFrame(()=>{\n          connect.bind(this)()\n        })\n      }\n    }\n  })\n}\n\nFez.find = (node, name) => {\n  if (typeof node == 'string') {\n    node = document.body.querySelector(node)\n  }\n\n  if (typeof node.val == 'function') {\n    node = node[0]\n  }\n\n  const klass = name ? `.fez-${name}` : '.fez'\n\n  return node.closest(klass).fez\n}\n\nFez.globalCss = (text) => {\n  const cssClass = Fez.css(text)\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    document.body.classList.add(cssClass)\n  })\n  return cssClass\n}\n\nFez.css = (text) => {\n  return Gobber.css(text)\n}\n\nFez.info = (text) => {\n  if (window.DEBUG) {\n    console.log(`Fez: ${text}`)\n  }\n}\n\nFez.morphdom = (target, newNode, opts = {}) => {\n  if (opts.childrenOnly === undefined) {\n    opts.childrenOnly = true\n  }\n\n  // Morphdom(target, newNode, opts)\n  Idiomorph.morph(target, newNode, { morphStyle: 'innerHTML'})\n}\n\nFez.htmlEscape = (text) => {\n  return text\n    .replaceAll(\"'\", '&apos;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n}\n\nFez.publish = (channel, ...args) => {\n  Fez._subs[channel] ||= []\n  Fez._subs[channel].forEach((el) => {\n    el[1].bind(el[0])(...args)\n  })\n}\n\nwindow.Fez = Fez\nwindow.FezBase = FezBase\n"],
  "mappings": "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",
  "names": ["renderStache", "tpl", "context", "NEW_LINES_RE", "TEMPLATE_RE", "EACH_RE", "IF_RE", "ELSE_IF_RE", "stache", "source", "monkey", "t", "func", "all", "code", "parts", "list", "loop", "conditional", "conditionalElse", "codeParts", "createTemplate", "strings", "values", "acc", "str", "i", "closeCustomTags", "html", "selfClosingTags", "match", "tagName", "attributes", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromAttributes", "toAttributes", "fromAttribute", "i", "toAttribute", "syncInputValue", "syncBooleanAttribute", "attributeName", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "log", "mergeDefaults", "finalConfig", "createIdMap", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "e", "t", "a", "r", "l", "s", "n", "o", "c", "i", "u", "d", "f", "p", "g", "b", "m", "h", "y", "gobber_default", "n", "name", "attrs", "data", "parts", "c", "node", "k", "v", "value", "FezBase", "node", "name", "Fez", "str", "FNV_OFFSET_BASIS", "FNV_PRIME", "hash", "i", "j", "ref", "attrs", "attr", "formData", "formObject", "value", "key", "n", "v", "klass", "source", "target", "isSlot", "text", "context", "renderStache", "error", "body", "newNode", "slot", "fetchAttr", "func", "classes", "lastClass", "c", "tick", "isGlobal", "className", "selector", "data", "list", "channel", "el", "method", "observer", "mutationsList", "_", "mutation", "fez", "connect", "parentNode", "nodeName", "object", "forceFastRender", "cssClass", "gobber_default", "opts", "Idiomorph", "args"]
}
