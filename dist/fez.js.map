{
  "version": 3,
  "sources": ["../src/vendor/n.js", "../src/vendor/template.js", "../src/lib/fez-base.js", "../src/vendor/gobber.js", "../src/vendor/idiomorph.js", "../src/lib/fez-connect.js", "../src/lib/fez-root.js", "../src/fez.js"],
  "sourcesContent": ["// Exposes node building method, that gets node name, attrs and body.\n// n('span', {id: id}), n('.foo', {id: id}, body), n('.foo', {id: id}, [...])\n// * you can switch places for attrs and body, and body can be list of nodes\n// * n('.foo.bar') -> n('div', { class: 'foo bar' })\n//\n// copyright @dux, 2024\n// Licence MIT\n\nexport default function n(name, attrs = {}, data) {\n  if (typeof attrs === 'string') {\n    [attrs, data] = [data, attrs]\n    attrs ||= {}\n  }\n\n  if (attrs instanceof Node) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (Array.isArray(name)) {\n    data = name\n    name = 'div'\n  }\n\n  if (typeof attrs !== 'object' || Array.isArray(attrs)) {\n    data = attrs\n    attrs = {}\n  }\n\n  if (name.includes('.')) {\n    const parts = name.split('.')\n    name = parts.shift() || 'div'\n    const c = parts.join(' ');\n    if (attrs.class) {\n      attrs.class += ` ${c}`;\n    } else {\n      attrs.class = c\n    }\n  }\n\n  const node = document.createElement(name);\n\n  for (const [k, v] of Object.entries(attrs)) {\n    if (typeof v === 'function') {\n      node[k] = v.bind(this)\n    } else {\n      const value = String(v).replaceAll('$$.', this.fezHtmlRoot);\n      node.setAttribute(k, value)\n    }\n  }\n\n  if (data) {\n    if (Array.isArray(data)) {\n      for (const n of data) {\n        node.appendChild(n)\n      }\n    } else if (data instanceof Node) {\n      node.appendChild(data)\n    } else {\n      node.innerHTML = String(data)\n    }\n  }\n\n  return node\n}\n", "function parseBlock(data, ifStack) {\n  data = data.replaceAll('@', 'this.')\n\n  // Handle #if directive\n  if (data.startsWith('#if') || data.startsWith('if')) {\n    ifStack.push(false)\n    data = data.replace(/^#?if/, '')\n    return `\\${ ${data} ? \\``\n  }\n  else if (data.startsWith('#for') || data.startsWith('for')) {\n    data = data.replace(/^#?for/, '')\n    const el = data.split(' in ', 2)\n    return '${' + el[1] + '.map((' + el[0] + ')=>`'\n  }\n  else if (data.startsWith('#each') || data.startsWith('each')) {\n    data = data.replace(/^#?each/, '')\n    const el = data.split(' as ', 2)\n    return '${' + el[0] + '.map((' + el[1] + ')=>`'\n  }\n  else if (data == ':else' || data == 'else') {\n    ifStack[ifStack.length - 1] = true\n    return '` : `'\n  }\n  else if (data == '/if') {\n    return ifStack.pop() ? '`}' : '` : ``}'\n  }\n  else if (data == '/for' || data == '/each') {\n    return '`).join(\"\")}'\n  }\n  else {\n    const prefix = 'this.html '\n\n    if (data.startsWith(prefix)) {\n      data = data.replace(prefix, '')\n    } else {\n      data = `Fez.htmlEscape(${data})`\n    }\n\n    // return '${' + (returnRaw ? Fez.htmlEscape(data) : data) + '}'\n    return '${' + data + '}'\n  }\n}\n\n// let tpl = createTemplate(sting)\n// tpl({ ... this sate ...})\nexport default function createTemplate(text) {\n  const ifStack = []\n\n  let result = text.replace(/\\s*{{(.*?)}}\\s*/g, (match, content) => {\n    const parsedData = parseBlock(content, ifStack);\n    return parsedData\n  });\n\n  //result = result.replace(/>\\s+</g, '><')\n\n  result = '`' + result + '`'\n\n  // console.log(result)\n\n  try {\n    const tplFunc = new Function(`return ${result}`)\n    const outFunc = (o) => {\n      try {\n        return tplFunc.bind(o)()\n      } catch(e) {\n        const msg = `FEZ template runtime error: ${e.message}`\n        console.error(msg)\n        console.log(text)\n        return `${msg} (check console for template info)`\n      }\n    }\n    return outFunc\n  } catch(e) {\n    console.error(`FEZ template compile error: ${e.message}`)\n    console.log(text)\n  }\n}\n", "// HTML node builder\nimport parseNode from '../vendor/n'\nimport createTemplate from '../vendor/template'\n\nexport default class FezBase {\n  static __objects = []\n\n  // get node attributes as object\n  static getProps(node, newNode) {\n    let attrs = {}\n    for (const attr of node.attributes) {\n      attrs[attr.name] = attr.value\n    }\n\n    if (attrs['data-props']) {\n      let data = attrs['data-props']\n      if (data[0] != '{') {\n        data = decodeURIComponent(data)\n      }\n      // console.log(data)\n      // console.log(data)\n      attrs = JSON.parse(data)\n    }\n\n    // pass props as json template\n    // <script type=\"text/template\">{...}</script>\n    // <foo-bar data-json-template=\"true\"></foo-bar>\n    if (attrs['data-json-template']) {\n      const data = newNode.previousSibling?.textContent\n      if (data) {\n        attrs = JSON.parse(data)\n      }\n    }\n\n    for (const [key, val] of Object.entries(attrs)) {\n      if (key[0] == ':') {\n        delete attrs[key]\n        const context = node.closest('.fez')?.fez || window\n        const newVal = new Function(`return (${val})`).bind(context)()\n        attrs[key.replace(':', '')] = newVal\n      }\n    }\n\n    return attrs\n  }\n\n  static formData(node) {\n    const formNode = node.closest('form') || node.querySelector('form')\n    const formData = new FormData(formNode)\n    const formObject = {}\n    formData.forEach((value, key) => {\n      formObject[key] = value\n    });\n    return formObject\n  }\n\n  static fastBind() {\n    // return true to bind without requestAnimationFrame\n    // you can do this if you are sure you are not expecting innerHTML data\n    return false\n  }\n\n  static nodeName = 'div'\n\n  // instance methods\n\n  constructor() {}\n\n  n = parseNode\n\n  // string selector for use in HTML nodes\n  get fezHtmlRoot() {\n    return `Fez.find(this, \"${this.fezName}\").`\n  }\n\n  // checks if node is attached and clears all if not\n  get isAttached() {\n    if (this.root?.parentNode) {\n      return true\n    } else {\n      this._setIntervalCache ||= {}\n      Object.keys(this._setIntervalCache).forEach((key)=> {\n        clearInterval(this._setIntervalCache[key])\n      })\n\n      this.onDestroy()\n\n      if (this.root) {\n        this.root.fez = null\n      }\n\n      this.root = null\n      return false\n    }\n  }\n\n  // get single node property\n  prop(name) {\n    let v = this.oldRoot[name] || this.props[name]\n    if (typeof v == 'function') {\n      // if @prop('onclick'), we want \"this\" to point to this.root (dom node)\n      v = v.bind(this.root)\n    }\n    return v\n  }\n\n  // copy attributes to root node\n  copy() {\n    for (const name of Array.from(arguments)) {\n      let value = this.props[name]\n\n      if (value !== undefined) {\n        if (name == 'class') {\n          const klass = this.root.getAttribute(name, value)\n\n          if (klass) {\n            value = [klass, value].join(' ')\n          }\n        }\n\n        if (typeof value == 'string') {\n          this.root.setAttribute(name, value)\n        } else {\n          this.root[name] = value\n        }\n      }\n    }\n  }\n\n  // copy child nodes, natively to preserve bound events\n  // if node name is SLOT insert adjacent and remove SLOT, else as a child nodes\n  slot(source, target) {\n    target ||= document.createElement('template')\n    const isSlot = target.nodeName == 'SLOT'\n\n    while (source.firstChild) {\n      if (isSlot) {\n        target.parentNode.insertBefore(source.lastChild, target.nextSibling);\n      } else {\n        target.appendChild(source.firstChild)\n      }\n    }\n\n    if (isSlot) {\n      target.parentNode.removeChild(target)\n    } else {\n      source.innerHTML = ''\n    }\n\n    return target\n  }\n\n  style() { console.error('call Fez static style') }\n\n  connect() {\n    // if (! this.class.html) {\n    //   console.error('Fez is missing \"connect\" method.', this.root)\n    // }\n  }\n\n  afterConnect() {}\n  onMount() {}\n  beforeRender() {}\n  afterRender() {}\n  onDestroy() {}\n\n  parseHtml(text) {\n    const base = this.fezHtmlRoot.replaceAll('\"', '&quot;')\n    text = text\n      .replaceAll('$$.', base)\n      .replace(/([^\\w\\.])fez\\./g, `$1${base}`)\n\n    return text\n  }\n\n  // pass name to have only one tick of a kind\n  nextTick(func, name) {\n    if (name) {\n      this._nextTicks ||= {}\n      this._nextTicks[name] ||= window.requestAnimationFrame(() => {\n        func.bind(this)()\n        this._nextTicks[name] = null\n      }, name)\n    } else {\n      window.requestAnimationFrame(func.bind(this))\n    }\n  }\n\n  // inject htmlString as innerHTML and replace $$. with local pointer\n  // $$. will point to current fez instance\n  // <slot></slot> will be replaced with current root\n  // this.render('...loading')\n  // this.render('.images', '...loading')\n  render(template) {\n    template ||= this?.class?.fezHtmlFunc\n\n    if (!template) return\n\n    this.beforeRender()\n\n    const newNode = document.createElement(this.class.nodeName || 'div')\n\n    let renderedTpl\n    if (Array.isArray(template)) {\n      // array nodes this.n(...), look tabs example\n      if (template[0] instanceof Node) {\n        template.forEach( n => newNode.appendChild(n) )\n      } else{\n        renderedTpl = template.join('')\n      }\n    }\n    else if (typeof template == 'string') {\n      renderedTpl = createTemplate(template)(this)\n    }\n    else if (typeof template == 'function') {\n      renderedTpl = template(this)\n    }\n\n    if (renderedTpl) {\n      newNode.innerHTML = this.parseHtml(renderedTpl)\n    }\n\n    // this comes only from array nodes this.n(...)\n    const slot = newNode.querySelector('slot')\n    if (slot) {\n      this.slot(this.root, slot.parentNode)\n      slot.parentNode.removeChild(slot)\n    }\n\n    let currentSlot = this.find('.fez-slot')\n    if (currentSlot) {\n      const newSLot = newNode.querySelector('.fez-slot')\n      if (newSLot) {\n        newSLot.parentNode.replaceChild(currentSlot, newSLot)\n      }\n    }\n\n    Fez.morphdom(this.root, newNode)\n\n    this.renderFezPostProcess()\n\n    this.afterRender()\n  }\n\n  renderFezPostProcess() {\n    const fetchAttr = (name, func) => {\n      this.root.querySelectorAll(`*[${name}]`).forEach((n)=>{\n        let value = n.getAttribute(name)\n        n.removeAttribute(name)\n        if (value) {\n          func.bind(this)(value, n)\n        }\n      })\n    }\n\n    // <button fez-this=\"button\" -> this.button = node\n    fetchAttr('fez-this', (value, n) => {\n      (new Function('n', `this.${value} = n`)).bind(this)(n)\n    })\n\n    // <button fez-use=\"animate\" -> this.animate(node]\n    fetchAttr('fez-use', (value, n) => {\n      const target = this[value]\n      if (typeof target == 'function') {\n        target(n)\n      } else {\n        console.error(`Fez error: \"${value}\" is not a function in ${this.fezName}`)\n      }\n    })\n\n    // <button fez-class=\"dialog animate\" -> add class \"animate\" after node init to trigger animation\n    fetchAttr('fez-class', (value) => {\n      let classes = value.split(/\\s+/)\n      let lastClass = classes.pop()\n      classes.forEach((c)=> n.classList.add(c) )\n      if (lastClass) {\n        setTimeout(()=>{\n          n.classList.add(lastClass)\n        }, 300)\n      }\n    })\n\n    // <input fez-bind=\"state.inputNode\" -> this.state.inputNode will be the value of input\n    fetchAttr('fez-bind', (text, n) => {\n      const value = (new Function(`return this.${text}`)).bind(this)()\n      const isCb = n.type.toLowerCase() == 'checkbox'\n      const eventName = ['SELECT'].includes(n.nodeName) || isCb ? 'onchange' : 'onkeyup'\n      n.setAttribute(eventName, `${this.fezHtmlRoot}${text} = this.${isCb ? 'checked' : 'value'}`)\n      this.val(n, value)\n    })\n  }\n\n  // refresh single node only\n  refresh(selector) {\n    alert('NEEDS FIX and remove htmlTemplate')\n    if (selector) {\n      const n = document.createElement('div')\n      n.innerHTML = this.class.htmlTemplate\n      const tpl = n.querySelector(selector).innerHTML\n      this.render(selector, tpl)\n    } else {\n      this.render()\n    }\n  }\n\n  // run only if node is attached, clear otherwise\n  setInterval(func, tick, name) {\n    if (typeof func == 'number') {\n      [tick, func] = [func, tick]\n    }\n\n    name ||= Fez.fnv1(String(func))\n\n    this._setIntervalCache ||= {}\n    clearInterval(this._setIntervalCache[name])\n\n    this._setIntervalCache[name] = setInterval(() => {\n      if (this.isAttached) {\n        func()\n      }\n    }, tick)\n\n    return this._setIntervalCache[name]\n  }\n\n  find(selector) {\n    return typeof selector == 'string' ? this.root.querySelector(selector) : selector\n  }\n\n  // get or set node value\n  val(selector, data) {\n    const node = this.find(selector)\n\n    if (node) {\n      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(node.nodeName)) {\n        if (typeof data != 'undefined') {\n          if (node.type == 'checkbox') {\n            node.checked = !!data\n          } else {\n            node.value = data\n          }\n        } else {\n          return node.value\n        }\n      } else {\n        if (typeof data != 'undefined') {\n          node.innerHTML = data\n        } else {\n          return node.innerHTML\n        }\n      }\n    }\n  }\n\n  formData(node) {\n    return this.class.formData(node || this.root)\n  }\n\n  // get or set attribute\n  attr(name, value) {\n    if (typeof value === 'undefined') {\n      return this.root.getAttribute(name)\n    } else {\n      this.root.setAttribute(name, value)\n      return value\n    }\n  }\n\n  // get root node child nodes as array\n  childNodes(func) {\n    let list = Array.from(this.root.querySelectorAll(\":scope > *\"))\n\n    if (func) {\n      list = list.map(func)\n    }\n    return list\n  }\n\n  subscribe(channel, func) {\n    Fez._subs ||= {}\n    Fez._subs[channel] ||= []\n    Fez._subs[channel] = Fez._subs[channel].filter((el) => el[0].isAttached)\n    Fez._subs[channel].push([this, func])\n  }\n\n  fezRegister() {\n    if (this.css) {\n      this.css = Fez.globalCss(this.css, {name: this.fezName, wrap: true})\n    }\n\n    if (this.class.css) {\n      this.class.css = Fez.globalCss(this.class.css, {name: this.fezName})\n    }\n\n    this.state ||= this.reactiveStore()\n    this.data ||= {}\n\n    this.fezRegisterBindMethods()\n  }\n\n  // bind all instance method to this, to avoid calling with .bind(this)\n  fezRegisterBindMethods() {\n    const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this))\n      .filter(method => method !== 'constructor' && typeof this[method] === 'function')\n\n    methods.forEach(method => this[method] = this[method].bind(this))\n  }\n\n  reactiveStore(obj, handler) {\n    obj ||= {}\n\n    handler ||= (o, k, v) => {\n      this.nextTick(this.render, 'render')\n    }\n\n    handler.bind(this)\n\n    // licence ? -> generated by ChatGPT 2024\n    function createReactive(obj, handler) {\n      if (typeof obj !== 'object' || obj === null) {\n        return obj;\n      }\n\n      return new Proxy(obj, {\n        set(target, property, value, receiver) {\n          if (typeof value === 'object' && value !== null) {\n            value = createReactive(value, handler)\n          }\n          const result = Reflect.set(target, property, value, receiver)\n          handler(target, property, value)\n          return result\n        },\n        get(target, property, receiver) {\n          const value = Reflect.get(target, property, receiver)\n          if (typeof value === 'object' && value !== null) {\n            return createReactive(value, handler)\n          }\n          return value\n        }\n      });\n    }\n\n    return createReactive(obj, handler);\n  }\n}\n", "/**\n * Skipped minification because the original files appears to be already minified.\n * Original file: /npm/goober@2.1.14/dist/goober.modern.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\nlet e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,a=e=>{let a=t(e),r=a.data;return a.data=\"\",r},r=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,l=/\\/\\*[^]*?\\*\\/|  +/g,s=/\\n+/g,n=(e,t)=>{let a=\"\",r=\"\",l=\"\";for(let s in e){let o=e[s];\"@\"==s[0]?\"i\"==s[1]?a=s+\" \"+o+\";\":r+=\"f\"==s[1]?n(o,s):s+\"{\"+n(o,\"k\"==s[1]?\"\":t)+\"}\":\"object\"==typeof o?r+=n(o,t?t.replace(/([^,])+/g,(e=>s.replace(/(^:.*)|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)))):s):null!=o&&(s=/^--/.test(s)?s:s.replace(/[A-Z]/g,\"-$&\").toLowerCase(),l+=n.p?n.p(s,o):s+\":\"+o+\";\")}return a+(t&&l?t+\"{\"+l+\"}\":l)+r},o={},c=e=>{if(\"object\"==typeof e){let t=\"\";for(let a in e)t+=a+c(e[a]);return t}return e},i=(e,t,a,i,p)=>{let u=c(e),d=o[u]||(o[u]=(e=>{let t=0,a=11;for(;t<e.length;)a=101*a+e.charCodeAt(t++)>>>0;return\"go\"+a})(u));if(!o[d]){let t=u!==e?e:(e=>{let t,a,n=[{}];for(;t=r.exec(e.replace(l,\"\"));)t[4]?n.shift():t[3]?(a=t[3].replace(s,\" \").trim(),n.unshift(n[0][a]=n[0][a]||{})):n[0][t[1]]=t[2].replace(s,\" \").trim();return n[0]})(e);o[d]=n(p?{[\"@keyframes \"+d]:t}:t,a?\"\":\".\"+d)}let f=a&&o.g?o.g:null;return a&&(o.g=o[d]),((e,t,a,r)=>{r?t.data=t.data.replace(r,e):-1===t.data.indexOf(e)&&(t.data=a?e+t.data:t.data+e)})(o[d],t,i,f),d},p=(e,t,a)=>e.reduce(((e,r,l)=>{let s=t[l];if(s&&s.call){let e=s(a),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;s=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":n(e,\"\"):!1===e?\"\":e}return e+r+(null==s?\"\":s)}),\"\");function u(e){let a=this||{},r=e.call?e(a.p):e;return i(r.unshift?r.raw?p(r,[].slice.call(arguments,1),a.p):r.reduce(((e,t)=>Object.assign(e,t&&t.call?t(a.p):t)),{}):r,t(a.target),a.g,a.o,a.k)}let d,f,g,b=u.bind({g:1}),m=u.bind({k:1});function h(e,t,a,r){n.p=t,d=e,f=a,g=r}function y(e,t){let a=this||{};return function(){let r=arguments;function l(s,n){let o=Object.assign({},s),c=o.className||l.className;a.p=Object.assign({theme:f&&f()},o),a.o=/ *go\\d+/.test(c),o.className=u.apply(a,r)+(c?\" \"+c:\"\"),t&&(o.ref=n);let i=e;return e[0]&&(i=o.as||e,delete o.as),g&&i[0]&&g(o),d(i,o)}return t?t(l):l}}\nexport default { css:u, extractCss: a, glob: b, keyframes: m, setup: h, styled: y }\n", "// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n", "// templating\nimport createTemplate from '../vendor/template'\n\nexport default function(name, klass) {\n  // to allow anonymous class and then re-attach (does not work)\n  // Fez('ui-todo', class { ... # instead Fez('ui-todo', class extends FezBase {\n  if (!klass.__objects) {\n    const klassObj = new klass()\n    const newKlass = class extends FezBase {}\n\n    const props = Object.getOwnPropertyNames(klassObj)\n      .concat(Object.getOwnPropertyNames(klass.prototype))\n      .filter(el => !['constructor', 'prototype'].includes(el))\n\n    props.forEach(prop => newKlass.prototype[prop] = klassObj[prop])\n\n    if (klassObj.CSS) { newKlass.css = klassObj.CSS }\n    if (klassObj.HTML) { newKlass.html = klassObj.HTML }\n    if (klassObj.NAME) { newKlass.nodeName = klassObj.NAME }\n    if (klassObj.FAST) { newKlass.fastBind = klassObj.FAST }\n\n    klass = newKlass\n  }\n\n  if (klass.html) {\n    klass.html = closeCustomTags(klass.html)\n\n    // wrap slot to enable reactive re-renders. It will use existing .fez-slot if found\n    klass.html = klass.html.replace(/<slot\\s*\\/>|<slot\\s*>\\s*<\\/slot>/g, () => {\n      const name = klass.slotNodeName || 'div'\n      return `<${name} class=\"fez-slot\"></${name}>`\n    })\n\n    klass.fezHtmlFunc = createTemplate(klass.html)\n  }\n\n  // we have to register global css on component init, because some other component can depend on it (it is global)\n  if (klass.css) {\n    klass.css = Fez.globalCss(klass.css, {name: name})\n  }\n\n  Fez._classCache[name] = klass\n\n  if (!customElements.get(name)) {\n    customElements.define(name, class extends HTMLElement {\n      connectedCallback() {\n        // when we render nested fez components, and under Svelte, sometimes node innerHTML is empty, but it should not be\n        // in that case, we need to wait for another tick to get content\n        // this solution looks like it is not efficient, because it slow renders fez components that do not have and are not intended to have body, but by testing this looks like it is not effecting render performance\n        // if you want to force fast render, add static fastBind = true or check\n        // console.log(this)\n        if (this.firstChild || this.getAttribute('data-props') || forceFastRender(this, klass)) {\n          Fez.info(`fast bind: ${name}`)\n          connectDom(name, this, Fez._classCache[name])\n        } else {\n          Fez.info(`slow bind: ${name}`)\n          window.requestAnimationFrame(()=>{\n            if (this.parentNode) {\n              connectDom(name, this, Fez._classCache[name])\n            }\n          })\n        }\n      }\n    })\n  }\n}\n\n//\n\nfunction closeCustomTags(html) {\n  const selfClosingTags = new Set([\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'source', 'track', 'wbr'\n  ])\n\n  return html.replace(/<([a-z-]+)\\b([^>]*)\\/>/g, (match, tagName, attributes) => {\n    return selfClosingTags.has(tagName) ? match : `<${tagName}${attributes}></${tagName}>`\n  })\n}\n\nfunction connectDom(name, node, klass) {\n  const parentNode = node.parentNode\n\n  if (parentNode) {\n    const nodeName = typeof klass.nodeName == 'function' ? klass.nodeName(node) : klass.nodeName\n    const newNode = document.createElement(nodeName || 'div')\n\n    newNode.classList.add('fez')\n    newNode.classList.add(`fez-${name}`)\n\n    parentNode.replaceChild(newNode, node);\n\n    const object = new klass()\n    object.oldRoot = node\n    object.fezName = name\n    object.root = newNode\n    object.props = klass.getProps(node, newNode) // TODO: simplify by move up\n    object.class = klass\n\n    // copy child nodes, natively to preserve bound events\n    object.slot(node, newNode)\n\n    newNode.fez = object\n\n    if (window.$) {\n      object.$root = $(newNode)\n    }\n\n    if (object.props.id) {\n      newNode.setAttribute('id', object.props.id)\n    }\n\n    object.fezRegister()\n    object.connect(object.props)\n    klass.__objects.push(object)\n\n    const oldRoot = object.root.cloneNode(true)\n\n    if (object.class.fezHtmlFunc) {\n      object.render()\n    }\n\n    const slot = object.root.querySelector('.fez-slot')\n    if (slot) {\n      object.slot(oldRoot, slot)\n    }\n\n    if (object.onSubmit) {\n      const form = object.root.nodeName == 'FORM' ? object.root : object.find('form')\n      form.onsubmit = (e) => {\n        e.preventDefault()\n        object.onSubmit(object.formData())\n      }\n    }\n\n    object.afterConnect()\n    object.onMount()\n\n    // parse code in props\n    // size=\"{{ document.getElementById('icon-range').value }}\"\n    for (let [key, value] of Object.entries(object.props)) {\n      if (/^\\{\\{/.test(value) && /\\}\\}$/.test(value)) {\n        value = value.replace(/^\\{\\{/, 'return (').replace(/\\}\\}$/, ')')\n        value = (new Function(value)).bind(object.root)()\n        object.props[key] = value\n      }\n    }\n\n    // if onPropsChange method defined, add observer and trigger call on all attributes once component is loaded\n    if (object.onPropsChange) {\n      observer.observe(newNode, {attributes:true})\n      for (const [key, value] of Object.entries(object.props)) {\n        object.onPropsChange(key, value)\n      }\n    }\n  }\n}\n\nfunction forceFastRender(n, klass) {\n  return typeof klass.fastBind === 'function' ? klass.fastBind(n) : klass.fastBind\n}\n\nconst observer = new MutationObserver((mutationsList, _) => {\n  for (const mutation of mutationsList) {\n    if (mutation.type === 'attributes') {\n      const fez = mutation.target.fez\n      const name = mutation.attributeName\n      const value = mutation.target.getAttribute(name)\n      fez.props[name] = value\n      fez.onPropsChange(name, value)\n      // console.log(`The [${name}] attribute was modified to [${value}].`);\n    }\n  }\n});\n\n", "// runtime scss\nimport Gobber from '../vendor/gobber'\n\n// morph dom from one state to another\nimport { Idiomorph } from '../vendor/idiomorph'\n\nimport connect from './fez-connect'\n\nconst Fez = (name, klass) => {\n  if (!name) {\n    return FezBase\n  }\n\n  if (typeof klass != 'function') {\n    return Fez.find(name, klass)\n  }\n\n  return connect(name, klass)\n}\n\nFez._classCache = {}\n\nFez.find = (node, name) => {\n  if (typeof node == 'string') {\n    node = document.body.querySelector(node)\n  }\n\n  if (typeof node.val == 'function') {\n    node = node[0]\n  }\n\n  const klass = name ? `.fez-${name}` : '.fez'\n\n  return node.closest(klass).fez\n}\n\nFez.cssClass = (text) => {\n  return Gobber.css(text)\n}\n\nFez.globalCss = (cssClass, opts = {}) => {\n  if (typeof cssClass === 'function') {\n    cssClass = cssClass()\n  }\n\n  if (cssClass.includes(':')) {\n    let text = cssClass\n      .split(\"\\n\")\n      .filter(line => !(/^\\s*\\/\\//.test(line)))\n      .join(\"\\n\")\n    text = text.replace(/\\:fez|\\:host/, `.fez.fez-${opts.name}`)\n\n    if (opts.wrap) {\n      text = `.fez.fez-${opts.name} { ${text} }`\n    }\n\n    cssClass = Fez.cssClass(text)\n  }\n\n  if (document.body) {\n    document.body.classList.add(cssClass)\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      document.body.classList.add(cssClass)\n    })\n  }\n\n  return cssClass\n}\n\nFez.info = (text) => {\n  if (window.DEBUG) {\n    console.log(`Fez: ${text}`)\n  }\n}\n\nFez.morphdom = (target, newNode, opts = {}) => {\n  if (opts.childrenOnly === undefined) {\n    opts.childrenOnly = true\n  }\n\n  // Morphdom(target, newNode, opts)\n  Idiomorph.morph(target, newNode, { morphStyle: 'innerHTML' })\n\n  // I tried to ignore custom DOM nodes, cant do it\n  // Idiomorph.defaults.callbacks.beforeNodeMorphed = (oldNode, newNode) => {\n  //   console.log('-', oldNode.outerHTML)\n  //   const klass = oldNode.getAttribute ? oldNode.getAttribute('class') : null\n  //   if (klass) {\n  //     console.log(klass)\n  //     return false\n  //   }\n  // }\n}\n\nFez.htmlEscape = (text) => {\n  if (typeof text == 'string') {\n    return text\n      .replaceAll('&', \"&amp;\")\n      .replaceAll(\"'\", '&apos;')\n      .replaceAll('\"', '&quot;')\n      .replaceAll('<', '&lt;')\n      .replaceAll('>', '&gt;')\n  } else {\n    return text\n  }\n}\n\nFez.publish = (channel, ...args) => {\n  Fez._subs ||= {}\n  Fez._subs[channel] ||= []\n  Fez._subs[channel].forEach((el) => {\n    el[1].bind(el[0])(...args)\n  })\n}\n\n  // get unique id from string\nFez.fnv1 = (str) => {\n  var FNV_OFFSET_BASIS, FNV_PRIME, hash, i, j, ref;\n  FNV_OFFSET_BASIS = 2166136261;\n  FNV_PRIME = 16777619;\n  hash = FNV_OFFSET_BASIS;\n  for (i = j = 0, ref = str.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {\n    hash ^= str.charCodeAt(i);\n    hash *= FNV_PRIME;\n  }\n  return hash.toString(36).replaceAll('-', '');\n}\n\nFez.tag = function(tag, opts = {}, html = '') {\n  const json = encodeURIComponent(JSON.stringify(opts));\n  return `<${tag} data-props=\"${json}\">${html}</${tag}>`;\n};\n\n// <template fez=\"ui-form\">\n// Fez.loadTemplate('ui-form')    # loads template[fez=ui-form]\n// Fez.loadTemplate(templateNode)\n// Fez.loadTemplate('ui-form', templateNode.innerHTML)\n\nFez.loadTemplate = function(tagName, html) {\n  if (tagName instanceof Node) {\n    // template reference\n    tagName.parentNode.removeChild(tagName)\n    html = tagName.innerHTML\n    tagName = tagName.getAttribute('fez')\n  }\n\n  if (!html) {\n    const selector = `template[fez=${tagName}]`\n    const node = document.querySelector(selector)\n    if (node) {\n      html = node.innerHTML\n    } else {\n      console.error(`Fez template not found: ${selector}`)\n      return\n    }\n  }\n\n  const result = { script: '', style: '', html: '' }\n  const lines = html.split('\\n')\n\n  let currentBlock = []\n  let currentType = ''\n\n  for (const line of lines) {\n    if (line.trim().startsWith('<script') && !result.script) {\n      currentType = 'script';\n    } else if (line.trim().startsWith('<style')) {\n      currentType = 'style';\n    } else if (line.trim().endsWith('</script>') && currentType === 'script' && !result.script) {\n      result.script = currentBlock.join('\\n');\n      currentBlock = [];\n      currentType = null;\n    } else if (line.trim().endsWith('</style>') && currentType === 'style') {\n      result.style = currentBlock.join('\\n');\n      currentBlock = [];\n      currentType = null;\n    } else if (currentType) {\n      currentBlock.push(line);\n    } else {\n      result.html += line + '\\n';\n    }\n  }\n\n  let klass = result.script\n\n  if (! /class\\s+\\{/.test(klass)) {\n    klass = `class {\\n${klass}\\n}`\n  }\n\n  if (String(result.style).includes(':')) {\n    result.style = result.style.includes(':fez') ? result.style : `:fez {\\n${result.style}\\n}`\n    klass = klass.replace(/\\}\\s*$/, `\\n  CSS = \\`${result.style}\\`\\n}`)\n  }\n\n  if (/\\w/.test(String(result.html))) {\n    result.html = result.html.replaceAll('$', '\\\\$')\n    klass = klass.replace(/\\}\\s*$/, `\\n  HTML = \\`${result.html}\\`\\n}`)\n  }\n\n  const parts = klass.split(/class\\s+\\{/, 2)\n\n  if (/\\w/.test(String(parts[2]))) {\n    klass = `${parts[0]};\\n\\nwindow.Fez('${tagName}', class {\\n${parts[1]})`\n  } else {\n    klass = `window.Fez('${tagName}', class {\\n${parts[0]})`\n  }\n\n  // if (tagName == 'x-counter') {\n  //   console.log(klass)\n  // }\n\n  try {\n    new Function(klass)()\n  } catch(e) {\n    console.error(`FEZ template \"${tagName}\" compile error: ${e.message}`)\n    console.log(klass)\n  }\n}\n\nFez.loadTemplates = function() {\n  document.querySelectorAll('template[fez]').forEach((n) => Fez.loadTemplate(n))\n}\n\nexport default Fez\n", "// base class for custom dom objects\nimport FezBase from './lib/fez-base'\nwindow.FezBase = FezBase\n\n// base class for custom dom objects\nimport Fez from './lib/fez-root'\nwindow.Fez = Fez\n\n// clear all unattached nodes\nsetInterval(() => {\n  FezBase.__objects = FezBase.__objects.filter(\n    (el) => el.isAttached()\n  )\n}, 5_000)\n\ndocument.addEventListener('DOMContentLoaded', Fez.loadTemplates)\n\n// runtime fez tag creation\n//<fez-template tag=\"app-editor\">\n//  <script>\nFez('fez-template', class {\n  connect(params) {\n    const tagName = params.tag || console.error(`FEZ template: tag name not given`)\n    const tpl = this.find('template')\n\n    if (tpl) {\n      Fez.loadTemplate(tagName, tpl.innerHTML)\n    } else {\n      console.error(`FEZ template: fez-template contents has to be wrapped in <template></template> tag.`)\n    }\n  }\n})\n\n// attach fez to a first child, do not alter the node\nFez('fez-use', class {\n  connect(params) {\n  }\n})\n"],
  "mappings": "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",
  "names": ["n", "name", "attrs", "data", "parts", "node", "k", "v", "value", "parseBlock", "data", "ifStack", "el", "prefix", "createTemplate", "text", "result", "match", "content", "tplFunc", "o", "e", "msg", "FezBase", "node", "newNode", "attrs", "attr", "data", "key", "val", "context", "newVal", "formNode", "formData", "formObject", "value", "n", "name", "v", "klass", "source", "target", "isSlot", "text", "base", "func", "template", "renderedTpl", "createTemplate", "slot", "currentSlot", "newSLot", "fetchAttr", "classes", "lastClass", "isCb", "eventName", "selector", "tpl", "tick", "list", "channel", "el", "method", "obj", "handler", "o", "k", "createReactive", "property", "receiver", "result", "e", "t", "a", "r", "l", "s", "n", "o", "c", "i", "p", "u", "d", "f", "g", "b", "m", "h", "y", "gobber_default", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromAttributes", "toAttributes", "fromAttribute", "i", "toAttribute", "syncInputValue", "syncBooleanAttribute", "attributeName", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "log", "mergeDefaults", "finalConfig", "createIdMap", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "populateIdMapForNode", "idMap", "nodeParent", "idElements", "current", "oldContent", "fez_connect_default", "name", "klass", "klassObj", "newKlass", "el", "prop", "closeCustomTags", "createTemplate", "forceFastRender", "connectDom", "html", "selfClosingTags", "match", "tagName", "attributes", "node", "parentNode", "nodeName", "newNode", "object", "oldRoot", "slot", "form", "e", "key", "value", "observer", "n", "mutationsList", "_", "mutation", "fez", "Fez", "name", "klass", "fez_connect_default", "node", "text", "gobber_default", "cssClass", "opts", "line", "target", "newNode", "Idiomorph", "channel", "args", "el", "str", "FNV_OFFSET_BASIS", "FNV_PRIME", "hash", "i", "j", "ref", "tag", "html", "json", "tagName", "selector", "result", "lines", "currentBlock", "currentType", "parts", "e", "n", "fez_root_default", "FezBase", "fez_root_default", "el", "params", "tagName", "tpl"]
}
